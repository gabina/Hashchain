\section{Preliminares}\label{sec:prelim}

%% Agregar algo de firmas criptográficas.

En esta sección se presenta una breve descripción de los conceptos principales
necesarios para la comprensión y discusión sobre las
contribuciones de este trabajo.

\subsection{Sistemas distribuídos: donde todo comenzó}

La computación distribuída nació a fines de la década de 1970 cuando investigadores y profesionales
comenzaron a tener en cuenta las características intrínsecas de los sistemas distribuídos físicamente.
El campo luego emergió como un área de investigación especializada distinta al de redes, al de sistemas
operativos, y al de computación paralela.~\cite{raynal.dist.systems}

La computación distribuída surge cuando se tiene que resolver un problema en términos de entidades
distribuídas (usualmente llamadas procesos, nodos, actores, agentes, pares, etc) en donde cada
entidad tiene conocimiento parcial sobre los diversos parámetros involucrados en el problema que
se tiene que resolver.
Es usual, en este contexto, hacer hincapié en dos tipos distintos fundamentales de procesos:
los \textit{clientes} (o procesos clientes) y los \textit{servidores} (o procesos servidores).
Así, los servidores son aquellos que proveen determinado recurso o servicio, mientras que los
clientes son quienes los demandan.

Es clave notar que el hecho de que las entidades (y la información que consume cada una de ellas)
estén distribuídas no es una propiedad que se encuentre bajo el control de los programadores, sino 
que es una imposición dada por las características propias del problema. En la 
Figura ~\ref{fig:distributed-systems} se expresa esto mediante un punto de vista
de la arquitectura del sistema, en donde cada par $(p_i, e_i)$ denota una entidad informática $p_i$ y su
entrada asociada $e_i$.

\begin{figure}
  \centering
  \includegraphics[scale=0.25]{figures/distributed-systems.png}
  \caption{Estructura básica de la computación distribuída}
  \label{fig:distributed-systems}
\end{figure}


Como se ilustra en la Figura ~\ref{fig:distributed-systems}, un sistema distribuído está hecho de una
colección de unidades de computación (llamadas también unidades informáticas) distribuídas, cada una
abstraída a través de la noción de un proceso, interconectada a través de un medio de comunicación.
Se asume que los procesos cooperan por un objetivo común, lo cual significa que intercambian
información de una manera u otra. Es interesante notar que el hecho de que las entidades
cooperen no significa la asunción de que todas las entidades se comportarán de la forma
acordada, ya sea por un error (por ejemplo, en la programación o en una red) o por un comportamiento
malintencionado.
Se profundizará en este punto en la siguiente sección. % ~\ref{subsubsec:consensus}.

% Two main process failures models are considered in this book:
% • Crash failures. A process commits a crash failure when it prematurely stops its execution. Until
% it crashes (if it ever crashes), a process correctly executes its local algorithm.
% • Byzantine failures. A process commits a Byzantine failure when it does not follow the behav-
% ior assigned to it by its local algorithm. This kind of failure is also called arbitrary failure
% (sometimes known as malicious when the failure is intentional). Let us notice that crash failures
% (which are an unexpected deﬁnitive halt) are a proper subset of Byzantine failures.
% A simple example of a Byzantine failure is the the following: while it is assumed to send the
% same value to all processes, a process sends different values to different subsets of processes,
% and no value at all to other processes. This is a typical Byzantine behavior. Moreover, Byzantine
% processes can collude to foil the processes that are not Byzantine.
% From a terminology point of view, let us consider an execution E (an execution is also called a
% run). The processes that commit failures are said to be faulty in E. The other processes are said to
% be correct or non-faulty in E. It is not known in advance if a given process is correct or faulty, this is
% speciﬁc to each execution.
% Given a process failure model, the model parameter t is used to denote the maximal number of
% processes that can be faulty in an execution.

% Fuente: Fault-Tolerant Message-Passing Distributed Systems An Algorithmic Approach

\subsection{Algoritmos de consenso}\label{subsubsec:consensus}
El problema de consenso es uno de los más celebrados en los sistemas de computación distribuída tolerante a fallas.
%
Abstrae diversos problemas en donde, de una manera u otra, los procesos deben ponerse de acuerdo.
%

Los problemas de consenso requieren acuerdo entre un número de procesos para determinar un valor particular.
%
Algunos de los procesos pueden fallar o ser no confiables de diversas maneras, por lo que los protocolos de
consenso deben ser resilientes a fallas.
%
Los procesos deben de alguna forma establecer sus valores candidatos, comunicándose entre ellos, y
poniéndose de acuerdo en un valor específico.
%
Los protocolos que resuelven el problema de consenso son diseñados para lidiar con un número limitado de procesos
que fallan.
%
Estos protoclos deben satisfacer un número de requerimientos para ser utilizados.
%
A lo largo de la historia se han desarrollado distintos algoritmos de consenso, que funcionan bajo diferentes
escenarios (cantidad de nodos, cantidad de nodos que pueden fallar, formas en las que pueden fallar, etc.)

%

Si bien a lo largo de este trabajo no se entrará en detalles sobre ningún algoritmo de consenso en particular,
es pertienente discutir conceptos y nomenclatura básica.

\subsubsection{El problema de los generales bizantinos}

Los sistemas de computación confiables deben lidiar con componentes que, por mal funcionamiento,
dan información conflictiva a diferentes partes del sistema.
La situación puede ser expresada abstractamente
en términos de un grupo de generales de la armada bizantina que acampan con sus tropas alrededor de una
ciudad enemiga.
Comunicándose solo a través de mensajeros, los generales deben ponerse de acuerdo en una plan
de batalla común.
Sin embargo, uno o más de ellos pueden ser traidores, quienes tratarán de confundir a los
otros.
El problema es encontrar un algoritmo que asegure que los generales leales lleguen a un acuerdo.
Está demostrado que, usando solo mensajes orales, este problema es resoluble si y solo si más de dos tercios
de los generales son leales~\cite{byzantineproblem}.
La habilidad de tolerar máquinas que fallan de formas arbritarias, incluyendo aquellas maliciosas,
es conocida como tolerancia a fallas bizantinas (\textit{Bizantyne fault-tolerance}).

%

Con esta analogía de los generales bizantinos, Lamport inició el estudio de los algoritmos de consenso tolerantes a fallas
bizantinas (\textit{Bizantyne fault-tolerant}), también conocidos como algoritmos de consenso BFT (por sus siglas en inglés).
Si bien la teoría de
BFT es de décadas pasadas, las implementaciones de software se han vuelto populares recientemente,
debido al amplio éxito de tecnologías blockchains como Bitcoin~\cite{nakamoto06bitcoin} y Ethereum~\cite{ethereum}.

\subsection{Firmas digitales}\label{subsec:signatures}
Usualmente, los protocolos BFT hacen un uso muy fuerte de la criptografía, fundamentalmente para autenticar
mensajes y decisiones que, a su vez, pueden ser utilizadas por otros para validar criptográficamente los resultados
obtenidos gracias al protocolo de consenso.

%
Las firmas digitales son una de las primitivas más poderosas de la criptografía.
Son similares a las firmas de puño y letra, en el sentido de que apuntan a cumplir las mismas propiedades
(pero, al ser firmas criptográficas, presentan garantías):
\begin{itemize}
  \item La firma solo puede ser utilizada por su dueño para firmar mensajes arbritarios.
  \item Cualquiera puede verificar la firma de un mensaje.
\end{itemize}
 
Los \textit{esquemas de firmas digitales} pertenecen al dominio de lo que se conoce como \textit{criptografía asimétrica}
o \textit{criptografía de clave pública}.
%
Esta categoría de la criptografía hace uso de distintas claves para distintas funciones (en oposición a una única
clave usada en la \textit{criptografía simétrica}), o provee diferentes puntos de vistas a diferentes participantes.
%
En líneas generales esto se puede expresar mediante la existencia de dos claves: una clave pública (conocida por cualquiera)
y una clave privada (que debe mantenerse secreta). Estas claves se encuentras conectadas entre sí y tienen roles complementarios.


Un esquema de firmas típicamente consiste de algoritmos diferentes:
\begin{itemize}
  \item Un algoritmo de generación de pares de claves que un firmante usa para crear una nueva clave privada y una pública.
  \item Un algoritmo para firmar que toma una clave privada y un mensaje, y produce una firma del mismo.
  \item Un algoritmo de verificación de firmas que toma una clave pública, un mensaje, y una firma, y determina si la firma
  fue creada para dicho mensaje con la clave privada asociada a la clave pública. 
\end{itemize}

La clave privada es también conocida como la \textit{clave de firmado} y la clave pública como la \textit{clave de verificación}.
En la Figura ~\ref{fig:digital-signatures} se recapitulan estos tres algoritmos.

\begin{figure}
  \centering
  \subfloat[Generación de claves]{\includegraphics[width = 1.7in]{figures/signature-00.png}}
  \hspace{1.4em}
  \subfloat[Firma de mensajes]{\includegraphics[width = 1.7in]{figures/signature-1.png}}
  \hspace{1.4em}
  \subfloat[Verificación de firma]{\includegraphics[width = 1.7in]{figures/signature-2.png}}
  \caption{Interfaz de firma digital.}
  \label{fig:digital-signatures}
\end{figure}


Las firmas son utilizadas para autenticar el \textit{origen} de un mensaje (el mensaje fue generado por el dueño de la clave privada
asociada a la firma), así como también la \textit{integridad} del mismo (ya que si el mensaje fuese cambiado, la firma sería invalidada).

%

Existen distintos estándares para los esquemas de firmas digitales, basados en aritmética de módulo sobre grandes números (por ejemplo,
RSA-PSS~\cite{pss.rsa}) o en curvas elípticas (como ECDSA~\cite{ecdsa}).
Sin embargo, no se entrará en detalles sobre ellos.

\subsection{Los orígenes de la blockchain: Bitcoin}
% Fuente: Mastering Bitcoin. Programming the open blockchain.
Las blockchains tomaron popularidad con la invención de Bitcoin en 2008, luego de la publicación
de un artículo llamado \textit{Bitcoin: A Peer-to-Peer
Electronic Cash System}\footnote{Bitcoin: un sistema de dinero electrónico de par a par.}, escrito
bajo el pseudónimo de Satoshi Nakamoto.
Nakamoto combinó diversas invenciones previas como
\textit{b-money}~\cite{b.money} y \textit{HashCash}~\cite{hashcash} para crear un sistema de dinero electrónico completamente
descentralizado que, justamente, no necesita confiar en ninguna autoridad central para la emisión de monedas,
o la ejecución de transacciones. 
La innovación clave en Bitcoin fue el uso de un sistema de cómputo distribuído que lleva
a cabo una elección global de las nuevas transacciones, permitiendo
a la red descentralizada llegar a un consenso sobre el estado de las mismas. Estas transacciones
se guardan empaquetadas como bloques en una bitácora distribuída pública conocida como blockchain.~\cite{mastering.bitcoin}
%
Se dice que estas transacciones se encuentran totalmente ordenadas porque es posible determinar para
dos transacciones cualesquieras en la blockchain cuál de ellas ocurrió antes.

%Esto resolvió de forma elegante el problema del doble gasto,
%en el cual una misma unidad de moneda se utiliza dos veces. Previamente, el problema del doble gasto fue
%una debilidad de los sistemas de moneda digital que fue abordado mediante servidores de información centrales.

%Bitcoin es una colección de conceptos y tecnologías que forman las bases de un ecosistema de dinero
%digital.
%
Si bien la noción de Bitcoin como criptomoneda no es imprescindible para la comprensión de las
contribuciones de este trabajo, es el primer caso de uso que da particular importancia a la blockchain
como tal, y a su rendimiento. Por este motivo se considera pertinente presentar un breve resumen sobre
su funcionamiento, poniendo foco en el aspecto técnico del mismo (no monetario).

\subsubsection{Cuentas y transacciones}

Un usuario de Bitcoin está necesariamente lidiando con primitivas criptográficas.
%
Para comenzar, los usuarios de Bitcoin no tienen un nombre de usuario y una contraseña
con la cual inician sesión; en lugar de eso, tienen un par de claves ECDSA (\textit{Eliptic
Curve Digital Signature Algorithm}) que generan ellos mismos mediante la interfaz de firmas
digitales vista en la sección anterior.
%
El balance de un usuario no es más que una cantidad de BTCs asociada a una clave pública,
y por lo tanto, para recibir BTCs, simplemente se debe compartir la clave pública con otros.

%
Para utilizar los BTCs que tiene disponible, el usuario firma una transacción con su clave privada.
%
De forma simplificada, una transacción se podría pensar tan solo como un mensaje (firmado) del tipo
\textquotedblleft Envío X BTCs a la clave pública Y\textquotedblright.

Una característica fundamental de Bitcoin es que no existe una base de datos real que contenga los
balances de cada cuenta.
%
En lugar de eso, los usuarios tienen BTCs dispnibles para gastar, llamados
\textit{Unspent Transaction Outputs} (UTXOs).
%
Cada usuario puede gastar únicamente sus propios UTXOs
(puesto que necesita la clave privada asociada para hacerlo).
%
Cuando una transacción gasta algunos de estos UTXOs, desaparecen y aparecen nuevos,
disponibles para gastar para el usuario destino de la transacción.
%

De este modo, para saber cuántos BTCs tiene una cuenta, se deben contar todos los UTXOs que fueron
asignados a dicha clave pública.
%
En otras palabras, se debe contar todo el dinero que fue enviado a dicha clave pública y aún no
fue gastado.

Ahora surgen algunas preguntas. ¿Quién está a cargo de elegir y ordenar las transacciones?
¿Quién mantiene el registro de todas ellas y cómo lo hace?
% Las unidades de moneda llamadas bitcoins son usadas para almacenar y transmitir valor a través
% de los participantes de la red de bitcoin. Los usuarios se comunican entre ellos usando un protocolo 
% específico principalmente mediante internet. La pila del
% protocolo bitcoin, disponible como software de código abierto, se puede correr en una amplia gama de
% dispositivos, incluyendo computadoras portátiles y teléfonos inteligentes, haciéndolo una tecnología
% de fácil acceso.

% Los usuarios pueden transferir bitcoins en la red y hacer básicamente cualquier operación que puede ser
% realizada con monedas tradicionales: comprar y vender bienes, enviar dinero a personas u
% organizaciones, o extender créditos. Los bitcoins también pueden ser vendidos, comprados, o intercambiados por
% otras monedas en casas de cambio especializadas.

% A diferencia de las monedas tradicionales, los bitcoins son completamente virtuales. No hay monedas
% físicas e incluso no existen monedas en sí. Las monedas se representan en transacciones que transfieren
% valor desde el remitente hacia el destinatario. Los usuarios de bitcoin poseen claves criptográficas
% que permiten probar la propiedad de los bitcoins en la red. Con estas claves se pueden firmar las
% transacciones para desbloquear el valor y utilizarlo transfiriéndolo a un nuevo dueño. 
%Las claves
%son a menudo guardadas en billeteras digitales en las computadoras o celulares de los usuarios. La
%posesión de una clave que puede firmar una transacción es el único prerequisito para utilizar bitcoin,
%poniendo el control enteramente en manos de cada usuario.

% Bitcoin es un sistema distribuído de par a par. Como tal no tiene un servidor central o un punto de control.
% Los bitcoins son creados a través de un proceso llamado \textit{minería}, el cual involucra una competencia
% para encontrar solución a un problema matemático mientras se procesan las transacciones de bitcoin.
% Cualquier participante de la red (es decir, cualquiera quien use un dispositivo que corre la pila
% completa de protocolo de bitcoin) puede operar como minero, usando el poder de procesamiento de su
% computadora para verificar y guardar transacciones. Cada 10 minutos, en promedio, alguien logra validar
% las transacciones de los últimos 10 minutos y es compensando con bitcoin nuevo. Esencialmente, la minería
% de bitcoins descentraliza la emisión de moneda y las funciones de compensación de un banco central, evitando
% la necesidad del mismo.

% El protocolo de bitcoin incluye algoritmos nativos que regulan las funciones de minería a lo largo de la
% red. La dificultad de la tarea de procesamiento que los mineros deben realizar se ajusta dinámicamente
% de modo que, en promedio, alguien tiene éxito cada 10 minutos sin importar la cantidad de mineros (y
% de poder de cómputo) existente en un momento dado. El protocolo además disminuye a la mitad el ratio de creación
% de bitcoins cada 4 años, y limita el número total de bitcoins que serán creados a un número fijo de
% aproximadamente 21 millones de bitcoins.

%El resultado es que el número de bitcoins en circulación
%sigue una curva predecible fácilmente que llega a 21 millones para el 2140. Debido a la disminución de
%emisión de bitcoins, a largo plazo, el bitcoin es deflacionario. Incluso más, bitcoin no puede sufrir
%inflación por "imprimir" más dinero más allá de ratio esperado. 

%Detrás de escena, bitcoin es el nombre de un protocolo, una red de pares, y una innovación de
%computación distribuída.
% Bitcoin representa la culminación de décadas de investigación en criptografía
% y sistemas distribuídos, e incluye 4 innovaciones claves funcionando juntas:
% \begin{itemize}
%   \item Una red de par a par descentralizada (el protocolo de bitcoin).
%   \item Una bitácora distribuída pública de transacciones organizadas en bloques (la blockchain).
%   \item Un conjunto de reglas para la validación independiente de transacciones y la emisión de monedas (reglas de consenso).
%   \item Un mecanismo para lograr un consenso global descentralizado en la blockchain (algoritmo de prueba de trabajo).
% \end{itemize}

 \subsubsection{Prueba de trabajo}

 Para acordar el ordenamiento de las transacciones, Bitcoin permite a cualquiera proponer una lista
 de transacciones a incluírse en la siguiente página de la bitácora.
 %
 Esta propuesta contiene una lista de transacciones llamada \textit{bloque}.
 %
 Sin embargo, dado que la participación en Bitcoin es abierta a cualquiera, la propuesta de nuevos
 bloques debe ser restringida de alguna forma, de modo que solo una persona haga una propuesta
 para el siguiente bloque.
 %

Para lograr esto, el protocolo de Bitcoin establece que para proponer un bloque debe resolverse
un problema lo suficientemente difícil.
%
Este mecanismo se conoce como prueba de trabajo (\textit{PoW}, por sus siglas en inglés).
%
En el caso de Bitcoin, el rompecabezas a resolver consisten en que el hash del bloque a proponer
tenga una representación binaria que comience con un número dado de ceros.

%
Las personas que se dedican a resolver el rompecabezas y proponer los nuevos bloques de transacciones
son denominadas \textit{mineros}.

\subsubsection{La forma de la blockchain}

La blockchain es la bitácora pública de Bitcoin, un registro ordenado, y con fecha y hora de las transacciones.
%
Cada nodo completo en la red de Bitcoin guarda independientemente una blockchain que contiene solo
bloques validados por ese nodo.
%
Cuando cierta cantidad de nodos tienen los mismos bloques en su propia blockchain
se dice que llegaron a un consenso. 
%The validation rules these nodes follow to maintain consensus are
%called consensus rules. This section describes many of the consensus rules used by Bitcoin Core.

La Figura \ref{fig:blockchain} muestra una versión simplificada de una blockchain.
En la sección de datos de un bloque
se agrupan y alojan una o más transacciones nuevas. Copias de cada transacción se hashean, los hashes luego
se emparejan, se hashean, se emparejan de nuevo, y se hashean hasta que queda un único hash: la raíz de un
\textit{merkle tree}~\cite{merkle.tree}. 

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.4]{figures/blockchain.png}
  \caption{Versión simplificada de la blockchain}
  \label{fig:blockchain}
\end{figure}


En la Figura \ref{fig:merkle-tree} se muestra un ejemplo de este tipo de árboles.
La raíz del merkle tree se aloja en el encabezado del bloque.

%
Cada bloque además contiene el hash del encabezado del bloque anterior, encadenándolos.
La blockchain es realmente una sucesión de bloques, donde cada bloque refiere al previo,
hasta llegar al primero, conocido como \textit{génesis}.
Esto asegura que una transacción no pueda modificarse sin modificar el bloque
que la contiene y todos los bloques siguientes~\cite{bitcoin}.

\begin{figure}[h]
  \centering
  \includegraphics[scale=0.4]{figures/merkle-tree.png}
  \caption{Merkle tree}
  \label{fig:merkle-tree}
\end{figure}

%Las transacciones también están encadenadas. Es decir, cada transacción gasta los \textit{satoshis}\footnote{
%Satoshi es la unidad mínima de Bitcoin, llamada así por el pseudónimo de su creador, Satoshi Nakamoto. Un bitcoin
%es equivalente a 100 millones de Satoshis.} previamente recibidos en una o más transacciones previas, por lo
%que la entrada de una transacción es la salida de una transacción previa.

% Fuente: https://developer.bitcoin.org/devguide/block_chain.html

%\subsection{Blockchain actuales}

\subsection{Setchain}~\label{sec:setchain}

\setchain~\cite{Capretto.2022.Setchain} es un tipo de datos concurrente y distribuído que implementa
conjuntos distribuídos de solo crecimiento, con barreras de sincronización (llamadas épocas), y tolerante
a comportamientos bizantinos.
%
Las barreras imponen un orden entre elementos pertenecientes a diferentes épocas pero no entre elementos
de la misma época.
%
Por lo tanto, \setchain relaja el requerimiento de orden total impuesto por las blockchains y, en consecuencia,
puede lograr mayor rendimiento y escalabilidad.

La idea básica de funcionamiento de la \setchain involucra tanto nodos clientes como servidores.
Los clientes se comunican con algún nodo servidor (quien mantiene la \setchain) para solicitar añadir un nuevo
elemento.
A su vez, los procesos clientes pueden pedirle a los servidores que les retornen el estado actual de la \setchain.


\subsubsection{La interfaz de Setchain}
Sea \(U\) un conjunto de elementos que los procesos clientes pueden inyectar en la \setchain.
%
Sea \isValidElement\ una función que los nodos pueden usar para validar elementos en \(U\)
localmente. De este modo, llamaremos \textit{elementos válidos} a aquellos para los cuales
$\isValidElement(e)$ retorne verdadero.
%
Luego, una \setchain es una estructura de datos distribuída donde una colleción de nodos servidores
mantienen:
\begin{itemize}
  \item un conjunto $\THESET \subseteq U$ de elementos agregados;
  \item un número natural $\EPOCH \in \mathds{N}$;
  \item una función $\HISTORY : [1..\EPOCH] \rightarrow \mathcal{P}(U)$\footnote{$\mathcal{P}(U)$ denota el conjunto potencia
  de $U$.} que describe los conjuntos de elementos que fueron estampados con un número de época.
\end{itemize}

%
%Los nodos servidores soportan dos operaciones: \<add> y \<get>.
%
%La operación \<add> agrega un elemento, mientras que la operación \<get> retorna la terna (\THESET,\HISTORY,\EPOCH) mantenida
% por el nodo.

% %

%Se usará notación de punto para invocar estas operaciones. Sea $v$ un nodo servidor, y $e$ un elemento:
%se notará $v.\<add>(e)$ para solicitarle añadir el elemento $e$ al nodo $v$, y $v.\<get>$ para pedirle al nodo $v$
%que retorne la terna en cuestión.

Cada nodo servidor $v$ soporta dos operaciones, disponibles para todos los procesos clientes:
\begin{itemize}
  \item $v.\<add>(e)$: solicita agregar el elemento $e$ a $\THESET$.
  \item $v.\<get>()$: retorna los valores de $\THESET $, $\HISTORY $,
    y $\EPOCH $, según $v$.
\end{itemize}
  
Cuando se impone una nueva barrera de sincronización, los nodos que mantienen la \setchain colaborativamente
deciden cuáles elementos añadidos son estampados con la época actual, y se incrementa el número de época.
%
Estos eventos se llaman \textit{incrementos de época}.
%
Se asume que las barreras de sincronización se lanzan periódicamente.
%

Un flujo de trabajo típico desde el punto de vista del cliente es como sigue: un cliente invoca $\<add>(e)$ en
uno (o más) servidores para insertar un nuevo elemento válido $e$ en la \setchain.
% 
El elemento $e$ será propagado hacia los servidores, y cuando un incremento de época ocurra, los servidores
intentarán incluirlo en la nueva época.
%
Después de esperar cierto tiempo, el cliente invoca \<get> en uno (o más) servidores para chequear que el
elemento fue efectivamente agregado y estampado con una época.

\subsubsection{Propiedades}\label{subsubsec:setchain-properties}
Para asegurar correctitud, las implementaciones de \setchain deben satisfacer ciertas propiedades que
proveen garantías eventuales para elementos añadidos y garantía de consistencia entre los servidores
correctos.
%
Estas propiedades razonan sobre los servidores correctos, dado que los servidores bizantinos no proveen
ninguna garantía.

La primera propiedad establece que las épocas solo contienen elementos que provienen del conjunto
de solo crecimiento.
%
\newcounter{prop:consistent-set}
\setcounter{prop:consistent-set}{\value{property}}

\begin{property}[Consistent Sets]\label{api:consistent-set}
  Sea $(S,H,h)=v.\<get>()$ el resultado de una invocación a un servidor correcto $v$.
  %
  Luego, para cada $i\leq h, H(i) \subseteq S$.
\end{property}
%
La segunda propiedad declara que todo elemento añadido a un servidor correcto es eventualmente
retornado en todas las llamadas a \<get> futuras.
%
\begin{property}[Add-Get-Local]\label{api:history->theset-local}
  Sea $v.\<add>(e)$ una operación invocada en un servidor correcto $v$.
  %
  Luego, eventualmente todas las invocaciones $(S,H,h)=v.\<get>()$ 
  satisfacen $e\in S$.
\end{property}
La siguiente propiedad establece que los elementos presentes es un servidor correcto son propagados
a todos los servidores correctos.

\begin{property}[Get-Global]\label{api:history->theset}
  Sean $v$ y $w$ dos servidores correctos, sea $e \in U$ y
  $(S,H,h)=v.\<get>()$.
  %
  Si $e \in S$, luego eventualmente todas las invocaciones
  $(S',H',h')=w.\<get>()$ satisfacen que $e \in S'$.
\end{property}
%

La siguiente propiedad establece que todos los elementos añadidos son eventualmente estampados
con un número de época.
%
\begin{property}[Eventual-Get]\label{api:theset->history}
  Sea $v$ un servidor correcto, $e \in U$ y  $(S,H,h)=v.\<get>()$.
  % 
  Si $e \in S$, luego eventualmente todas las invocaciones
  $(S',H',h')=v.\<get>()$ satisfacen que $e \in H'$.
\end{property}

%
Las tres propiedaes previas implican la siguiente propiedad.
%
\begin{property}[Get-After-Add]\label{api:get-after-add}
  Sea $v.\<add>(e)$ una operación invocada en un servidor correcto $v$ con $e \in U$.
  %
  Luego, eventualmente todas las invocaciones $(S,H,h)=w.\<get>()$ en servidores correctos
  $w$ satisfaccen que $e\in H$.
\end{property}
%

La siguiente propiedad establece que un elemento puede estar en a lo sumo una época,
y que ningún elemento puede estar en dos épocas diferentes incluso si los conjuntos historiales se
obtienen de invocaciones \<get> a distintos servidores (ambos correctos).

%
\begin{property}[Unique Epoch]\label{api:local_unique_stamp}
  Sean $v$ un servidor correcto,
  $(S,H,h)=v.\<get>()$, y
  $i,i'\leq{}h$ con $i\neq i'$.
  %
  Luego, $H(i)\cap{}H(i')=\emptyset$.
\end{property}
%
La siguiente propiedad establece que los servidores están de acuerdo en el contenido
de las épocas.
%
\begin{property}[Consistent Gets]\label{api:consistent-gets}
  Sean $v,w$ servidores correctos, $(S,H,h)=v.\<get>()$ y
  $(S',H',h')=w.\<get>()$, y sea $i\leq \min(h,h')$. Luego
  $H(i)=H'(i)$.
\end{property}
%
%
% Property~\ref{api:consistent-gets} states that the histories returned
% by two $\<get>$ invocations to correct servers are one the prefix of
% the other.
% %
% However, since two elements $e$ and $e'$ can be inserted at two
% different correct servers---which can take time to propagate---, the
% $\<theset>$ part of $\<get>$ obtained from two correct servers may not
% be contained in one another.

Finalmente, se requiere que todo elemento in el historia provenga del resultado de un cliente
añadiendo un elemento.

%
\begin{property}[Add-before-Get]\label{api:get->add}
  Sea $v$ un servidor correcto, $(S,H,h)=v.\<get>()$,
  y $e \in S$.
  %
  Luego, hubo una operación $w.\<add>(e)$ en el pasado en algún servidor $w$.
\end{property}

Propiedades~\ref{api:consistent-set}, \ref{api:local_unique_stamp},
\ref{api:consistent-gets} y \ref{api:get->add} son propiedades de \textit{safety}.
%
Propiedades~\ref{api:history->theset-local}, \ref{api:history->theset},
\ref{api:theset->history} y \ref{api:get-after-add} son propiedades de \textit{liveness}.

% \begin{itemize}
%   \item Cada elemento válido agregado en un servidor correcto eventualmente es retornado en
%   todas las futuras invocaciones a \<get> hechas sobre servidores correctos.
%   \item Todos los elementos válidos agregados en un servidor correcto deben eventualmente ser
%   estampados con un número de época en todos los servidores correctos.
%   \item Una vez que un elemento es estampado con una época, no puede ser des-estampado, ni puede
%   ser estampado con otro número de época.
%   \item Dos servidores correctos cualesquieras están de acuerdo en el contenido de todas las épocas
%   que hayan sido computadas~\footnote{No todos los servidores correctos procesan los incrementos de
%   época simultáneamente, dado que algunos pueden estar más atrasados que otros.}.
%   \item Cada elemento que se estampa con una época proviene del resultado de un cliente añadiendo
%   el elemento.
% \end{itemize}
% \gabina{Epoch proofs are part of the epoch but are not coming directly from the result of a client adding element.}

\subsection{Tendermint}\label{sec:tendermint}
Tendermint es un motor de replicación de máquinas de estado que tolera fallas bizantinas.
%
Fue uno de los primeros sistemas en adaptar protocolos de consenso clásicos tolerantes a fallas bizantinas
al paradigma de blockchain.
%
Es decir, donde el consenso se ejecuta sobre lotes de transacciones vinculados mediante
hashes criptográficos (usualmente llamados bloques) en una red pública y abierta.

%

Tendermint funciona como una capa intermedia de blockchain que soporta la replicación de aplicaciones arbitrarias,
escritas en cualquier lenguaje de programación~\cite{tendermint.design}.
%
En la Figura~\ref{fig:replication} se muestra un esquema general de la arquitectura de la replicación de máquinas de
estado.
%
Las transacciones se reciben desde el cliente, quien se comunica, mediante una API, con una (o más) de las máquinas
en la red.
%
Estas transacciones pasan a través del protocolo de consenso, quien es el encargado de ordernar dichas
transacciones en bloques, mediante una serie de pasos que involucra comunicación entre todas las máquinas
(señalizada en la figura con líneas punteadas).
%
Una vez ordenadas, las transacciones son ejecutadas en cada una de las máquinas, modificando el estado
de cada una de ellas.
%
De esta forma, se replican lotes de transacciones enviadas por los distintos clientes, que son ejecutadas en el mismo
orden en cada una de las máquinas en la red, resultando en un mismo estado a lo largo de múltiples máquinas.
%
Las figuras azules representan máquinas.
%
Las líneas punteadas representan la comunicación entre máquinas para llevar a cabo el protocolo de consenso para ordernar
transacciones.

\begin{figure}
  \centering
  \includegraphics[scale=0.3]{figures/state-machine-replication.png}
  \caption{Esquema simplificado de la replicación de máquinas de estado.}
  \label{fig:replication}
\end{figure}

\subsubsection{Arquitectura de capas de Tendermint}\label{subsec:layers}

La Figura~\ref{fig:tendermint-architecture} presenta la estructura básica de Tendermint como un sistema de capas.
La subcapa inferior se encarga de la comunicación entre pares, y provee comunicación para los principales
módulos de la blockchain. Éstos son los módulos que se presentan en la capa inmediata superior: mempool, consenso,
evidencia, sincronización rápida, y sincronización de estado. Para el presente trabajo, solo serán pertinentes los
módulos de mempool y de consenso.

Un cliente interactúa con el sistema mediante RPC\footnote{\textit{Remote Procedure Call} o llamada a procedimiento
remoto en español.} al enviar transacciones
que (en caso de ser válidas) son añadidas al módulo de mempool. El cliente en general
recibe respuestas generadas por el módulo de consenso.
El módulo de consenso se encarga de ordenar e intermediar la ejecución de las transacciones, por medio de la
interfaz de aplicación.

\begin{figure}
  \centering
  \includegraphics[scale=0.2]{figures/tendermint-layers.png}
  \caption{Arquitectura de capas de Tendermint.}
  \label{fig:tendermint-architecture}
\end{figure}

% %
Tendermint consiste de dos componentes técnicos principales: un motor de consenso de blockchain, y una interfaz
de aplicación genérica.
%
El motor de consenso, llamado \textit{Tendermint Core}, asegura que las mismas transacciones sean registradas en cada
máquinas en el mismo orden.
%
La interfaz de aplicación, llamada \textit{interfaz de aplicación de blockchain} (ABCI)\footnote{Proveniente de \textit{Application
BlockChain Interface} (ABCI) en inglés.}, habilita que las transacciones
sean procesadas en cualquier lenguaje de programación.

\subsubsection{Application BlockChain Interface}\label{subsec:abci}
La interfaz de aplicación de blockchain es la interfaz entre el Tendermint Core y la aplicación replicada.
%
Un nodo de Tendermint mantiene tres conexiones ABCI con la aplicación replicada.
%

La \textit{conexión de consenso} se utiliza solo cuando se hace \textit{commit} sobre un nuevo bloque,
y comunica toda la información del bloque mediante una serie de peticiones: 
\BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit.
%
Esto significa que, cuando un bloque es acordado mediante consenso, Tendermint envía una petición \BeginBlock
seguida por una lista de peticiones \DeliverTx (una por cada transacción en el bloque), que finalizan con las
peticiones \EndBlock y \Commit, en ese orden.

%

La \textit{conexión de mempool} es usada por el protocolo de reserva de transacciones \footnote{\textit{Transaction pool protocol}
en inglés.} para validar las transacciones enviadas por los clientes en relación al estado de la aplicación.
%
Esta conexión solo admite peticiones \CheckTx. Las transacciones se chequean (mediante \CheckTx) en el mismo orden
en que fueron recibidas por el nodo validador\footnote{Los nodos validadores son responsables de hacer commit sobre nuevos
bloques en la blockchain. Estos validadores participan en el protocolo de consenso mediante la difusión de votos, los
cuales contienen firmas criptográficas generadas por las claves privadas de cada validador.}.
%
Si \CheckTx retorna \textit{OK}, la transacción se mantiene en memoria y se retransmite a otros pares en el mismo orden
en que fue recibida.
%
En caso contrario, se descarta.
%
Es parte de la lógica de la aplicación definir cuándo una transacción es válida o no, e incluso la validación es opcional.
%
De esta manera, queda claro que Tendermint es agnóstico de la semántica de las transacciones.

%

La \textit{conexión de consulta} permite recuperar información de la instancia local de la aplicación, usada
por distintos módulos de Tendermint (tales como el módulo de filtrado de pares).
%
Se utiliza para consultar la aplicación sin forzar consenso.
%
Se expone mediante el servidor RPC del Tendermint Core, de modo que los clientes pueden
consultar el estado de la aplicación sin exponer un servidor de la aplicación en sí mismo. 

La Figura~\ref{fig:abci_flow} muestra el flujo de mensajes mediante las conexiones de consenso y de mempool.

\begin{figure}
  \centering
  \includegraphics[scale=0.35]{figures/abci_msg_flow.png}
  \caption{Flujo de mensajes mediante la ABCI.}
  \label{fig:abci_flow}
\end{figure}

%%% Local Variables:
%%% TeX-master: "article.tex"
%%% TeX-PDF-mode: t
%%% End:
