\section{Implementaciones}\label{sec:impl}

En esta sección se presenta una familia de implementaciones de \setchain de mundo
real construídas sobre Tendermint.
%
En particular, se exponen tres alternativas diferentes, comenzando con una
solución inocente pero trivialmente correcta, y finalizando con un algoritmo
complejo que implementa \setchain utilizando funciones hash.
%
Para evitar repeticiones, las definciones de funciones que permanezcan sin cambios
de una versión a la siguiente, no serán re-escritas.
Solo se volverán a presentar aquellas funciones para las cuales la definición se
vea modificada.
%
A su vez, con la intención de mantener consistencia en la nomenclatura,
el término \textit{transacción} se utiliza siempre para referirse a las
\textit{transacciones de Tendermint}, mientras
que \textit{elemento} queda reservado para elementos a agregarse a la \setchain.
%
Dependiendo de la alternativa sobre la que se esté trabajando, una transacción de
Tendermint puede contener uno o más elementos a ser agregados.
%
% \subsection{General Considerations about Implementation}\label{subsec:general}
Las implementaciones correctas de \setchain implementan dos métodos~(ver sección
~\ref{sec:prelim}): \Add y \Get, y por lo tanto, cada solución provee definiciones
para ambas.
%
Por su parte, Tendermint provee dos \textit{endpoints} RPC principales.
Nótese que el cliente siempre se comunica con un nodo particular de la red.
\begin{itemize}
  \item \texttt{Tendermint.Broadcast} se utiliza para enviar transacciones.
  Cuando una transacción es enviada, se chequea si dicha transacción
  es válida contra la aplicación (mediante la llamada a \<CheckTx>), y en caso
  afirmativo, se añade
  a la mempool, se difunde a los otros nodos, y eventualmente se incluye en
  un bloque.
  \item \<abciquery> se utiliza para consultar el estado de la
  aplicación.
\end{itemize}
%

% Important: Note the mempool does not provide strong guarantees - just because a tx
% passed CheckTx (ie. was accepted into the mempool), doesn't mean it will be committed,
% as nodes with the tx in their mempool may crash before they get to propose.

Por lo tanto, desde el punto de vista del cliente de la \setchain, solo existen dos
métodos (\Add y \Get).
%
Sin embargo, hay dos métodos adicionales que se utilizan para comunicarse con la
red de Tendermint subyacente (los ya mencionados \texttt{Tendermint.Broadcast} y
\texttt{Tendermint.Query}).
%

Finalmente, \setchain asume que hay un predicado definido por el usuario que define
cuándo un elemento es válido para ser admitido en el conjunto.
%
En esta sección, dicho predicado se referencia con la función \isValidElement.

%
A continuación se presentan diferentes definiciones de métodos y funciones
necesarias para que la aplicación corriendo sobre Tendermint implemente \setchain.
Esto involucra, por un lado, los métodos presentados como parte de la API de
\setchain y, por el otro, los perteniences a la interfaz de aplicación de
blockchain ~(ver sección ~\ref{sec:prelim}).

\section{Primera implementación: Vainilla}\label{sec:vanilla}

Vainilla se presenta como la solución más sencilla a la API de \setchain
utilizando Tendermint.
%
La característica principal que le otorga sencillez a esta solución es que
un cliente invocando \Add(e) se traduce en una nueva transacción de Tendermint en la red,
que representa a ese y solo a ese elemento a añadir a la \setchain.
%
Que $e$ sea finalmente añadido a la \setchain dependerá de si la transacción asociada
al mismo se incluye en un bloque que, a su vez, eventualmente se agrega a la blockchain
subyacente de Tendermint. 

\subsection{Flujo de mensajes}
En la Figura~\ref{fig:vanilla-flow} se muestra el flujo usual de mensajes que se inicia
cuando un cliente invoca \Add(e).
%

El proceso comienza con el sistema en su estado inicial (Figura (a)), a la espera de que algún cliente
se conecte con esa instancia particular (una máquina conectada a la red) para agregar un elemento.
El Tendermint Core expone sus puntos de entrada RPC, que serán utilizados por parte de la API de
\setchain. Por su parte, la aplicación mantiene una instancia de la \setchain.
%

En la Figura (b) se observa el resultado de un cliente invocando \Add(e): el cliente, mediante
la API de \setchain, envía un elemento $e$, y la API de \setchain, a su vez, se comunica con el
punto de entrada del Tendermint Core para enviar una transacción $t_e$ que representa a $e$.
Es importante notar que el cliente envía \textit{elementos}, pero en la red de Tendermint
lo que circulan son \textit{transacciones}.
%

Para determinar si la nueva transacción debe ser difundida en la red, Tendermint chequea que
sea válida por medio de \CheckTx, y si lo es, entonces inserta la transacción en la mempool.
En caso contrario, la descartará, el flujo de dicha transacción terminará, y el elemento $e$
asociado a ella no será agregado a la \setchain.
La petición \CheckTx se muestra en la Figura (c).

%
Si la transacción $t_e$ llega a la mempool, luego de un tiempo, es esperable que sea añadida a un
bloque de Tendermint, propuesto como siguiente bloque en la cadena, como parte del algoritmo de
consenso.
Una vez que dicho bloque obtiene todos los votos necesarios para ser considerado
\textit{commited by the network}, comenzará una nueva instancia de consenso. En la Figura (d)
se representa que el siguiente bloque fue consensuado por parte del Tendermint Core.

%
El siguiente paso será que el Tendermint Core envíe
la secuencia correspondiente de pedidos a la aplicación: \BeginBlock para indicar el inicio de
un nuevo bloque,
una lista de llamadas a \DeliverTx por cada transacción agregada (en el orden en que fueron
consensuadas dentro del bloque)\footnote{En esta implementación
una \textit{transacción} agregada coincide con un \textit{elemento} agregado.},
\EndBlock para indicar la finalización del bloque, y \Commit para señalizar que el nuevo estado
puede ser persistido.
%
Si la transacción $t_e$ de Tendermint asociada a $e$ es parte de dicho bloque,
entonces con seguridad, una de las llamadas a \DeliverTx tendrá como argumento a $t_e$.
Esto se visualiza en la Figura (e).

%
El último paso en este flujo (Figura (f)) muestra que una nueva época se agregó a la \setchain,
en donde uno de sus elementos es $e$.

\begin{figure}
  \subfloat[Estado inicial]{\includegraphics[width = 3.5in]{figures/vanilla-flow-0.png}} 
  \subfloat[El cliente invoca \Add(e)]{\includegraphics[width = 3.5in]{figures/vanilla-flow-2.png}}\\
  \subfloat[$t_e$ se chequea contra \CheckTx]{\includegraphics[width = 3.5in]{figures/vanilla-flow-3.png}}
  \subfloat[Se consensúa el próximo bloque]{\includegraphics[width = 3.5in]{figures/vanilla-flow-4.png}}\\
  \subfloat[Se envían los pedidos de la ABCI a la aplicación]{\includegraphics[width = 3.5in]{figures/vanilla-flow-5.png}}
  \subfloat[Se agrega la época $n$ a la \setchain]{\includegraphics[width = 3.5in]{figures/vanilla-flow-6.png}} 
  \caption{Flujo usual de mensajes para vainilla}
  \label{fig:vanilla-flow}
\end{figure}

% \begin{figure}
%   \begin{subfigure}{.7\textwidth}
%     \centering
%     \includegraphics[width=.8\linewidth]{figures/vanilla-flow-0.png}
%     \caption{1a}
%     \label{fig:sfig1}
%   \end{subfigure}%
%   \begin{subfigure}{.7\textwidth}
%     \centering
%     \includegraphics[width=.8\linewidth]{figures/vanilla-flow-1.png}
%     \caption{1b}
%     \label{fig:sfig2}
%   \end{subfigure}
%   \begin{subfigure}{.7\textwidth}
%     \centering
%     \includegraphics[width=.8\linewidth]{figures/vanilla-flow-2.png}
%     \caption{1a}
%     \label{fig:sfig1}
%   \end{subfigure}%
%   \begin{subfigure}{.7\textwidth}
%     \centering
%     \includegraphics[width=.8\linewidth]{figures/vanilla-flow-3.png}
%     \caption{1b}
%     \label{fig:sfig2}
%   \end{subfigure}
%   \caption{plots of....}
%   \label{fig:fig}
%   \end{figure}

\subsection{Prueba de membrecía de elementos}\label{subsubsec:membership}
%
Como se mencionó antes, cuando un proceso cliente utiliza la API de \setchain
para añadir un elemento, o para recuperar el estado actual de la \setchain,
se comunica con un nodo parituclar de la red. Es importante notar que, en este
sentido, un proceso cliente no puede saber si se está contactando con un nodo
correcto o con un nodo bizantino.
%Client processes do not know if they are contacting a Byzantine or correct
%process.
%
Para asegurar que un elemento será añadido a la \setchain, el cliente neecesita
interactuar con suficientes servidores, de modo de garantizar que al menos uno de ellos
es correcto~\cite{Capretto.2022.Setchain}.
%
% An extension to Setchain presented an optimistic client with the following
% approach.
%
Los nodos correctos firman criptográficamente un hash del conjunto de elementos
pertenecientes a una época, e insertan este hash como un elemento en la \setchain.
%
A esos hashes los llamamos \textit{elementos de prueba de época}.
%
Estas pruebas de época pueden implementarse utilizando \textit{Ed25519}~\cite{ed25519}
como sistema de firmas.
%
Las pruebas de época en principio contienen: el número de época al cual pertenece
la prueba, la clave pública del validador que firma, y la firma de los elementos 
de la época dada (ordenados de una forma específica y conocida).
%
De esta manera, los clientes solo ejecutan una única petición $\<add>(e)$ a un
determinado servidor, esperando que sea correcto. 
%
Luego de esperar cierto tiempo, los clientes pueden invocar  \<get> (también a un
único nodo) y chequear si el elemento $e$ pertenece a alguna época y existen suficientes
pruebas para dicha época\footnote{Se asume que una cota superior $f$ de número de servidores
biantinos es conocida y, por lo tanto, se requieren $f+1$ firmas.}. De este modo, se garantiza
que al menos un servidor corrector la firmó.
%
Los clientes pueden verificar si las pruebas de época son válidas generando el hash de elementos
en la época dada, y verificando (a través de la clave pública) si la firma de la prueba es válida
para el hash obtenido.
%
Las claves públicas de los validadores necesitan ser públicamente conocidas para los usuarios.
%
Si un elemento $e$ pertenece a una época que tiene suficientes prueas, los clientes pueden
concluír que la época es correcta y que $e$ fue éxitosamente insertado en la \setchain.
%
Nótese que esto solo requiere una llaada a \<add> y una llamada a \<get>.
%
Este mecanismo de membrecías de elementos a épocas está implementado en la definición de
\<EndBlock>.
%
Otra opción para implementar los elementos de prueba de época es a través de la librería
criptográfica de \textit{ethereum}.
%
Esta librería provee una función \texttt{Sign} que cacula una firma ECDSA.
%
La firma producida se encuentra en el formato $[R || S || V]$, donde $V$ es 0 o 1.
%
El valor de $V$ es usualmente llamado \textit{bit de recuperación}, y permite utilizar
la función \texttt{Ecrecover}, la cua dado un hash y una firma, retorna la clave pública
(en formato descomprimido) que creó dicha firma.
%
De esta forma, los elementos de prueba de época pueden contener el número de época y la firma
en el formato mencionado arriba, y los clientes pueden usar la función \texttt{Ecrecover} para
verificar que la firma dada fue de hecho generada por un validador conocido.
%
Nótese que las épocas ahora contienen dos tipos de elementos: elementos regulares enviados por
un cliente, y elementos de prueba de época; significando que cada elemento de prueba de época
pertenece a su vez a una época. Sin embargo, los elementos de pruea de época no necesitan ser
incluídos como elementos en el hash firmado que es parte de la prueba de época para una época
dada.
%
Consecuentemente, es necesario diferenciar entre elementos regular, y elementos de prueba de época.
%
La validez de los elementos regulares se chequea a través de la ya mencionada función
\texttt{isValidElement}.
%
Sin enmbargo, un elemento de prueba de época necesita ser validado de otra manera: verificando la firma.
%

\subsection{Algoritmos}

\input{algorithms/alg-api-vanilla}
%
En el Algoritmo~\ref{alg:api-vanilla} se muestra la solución más sencilla a la API
de \setchain.
%

Los clientes agregan elementos invocando (indirectamente) a la función
\texttt{Tendermint.Broadcast}, mientras que pueden consultar el estado actual de
la \setchain invocando (también de forma indirecta) a \texttt{Tendermint.Query}.
%

Para dar una implementación completa de \setchain utilizando Tendermint, además se
deben dar las definiciones de los métodos pertenecientes a la interfaz ABCI
(ver sección~\ref{subsec:abci}). 
%

\input{algorithms/alg-abci-vanilla}
El Algoritmo~\ref{alg:abci-vanilla} muestra la definición de la ABCI para la versión
Vainilla.
%
Solo se definen \CheckTx, \DeliverTx, y \EndBlock; el resto tiene implementaciones
triviales.

En esta versión, chequear si una transacción es válida consiste en simplemente chequear
la validez del elemento, dado que las transacciones contienen un único elemento.
%
Puede parecer absurdo definir la función \texttt{getElementFromTransaction()}
en este caso (dado que es la función identidad). Sin embargo, la decisión de dar
la definición explícita se basa en enfatizar la diferencia conceptual entre una
transacción de Tendermint, y los elementos a añadir en la \setchain.
%

El Tendermint core envía peticiones \DeliverTx asíncronamente (pero en orden)
una vez por cada transacción en el bloque.
%
Nótese que las transacciones ya fueron ordenadas en el consenso global por el protocolo
de Temndermint cuando \DeliverTx se ejecuta.
%
Para este algoritmo, la única acción a realizar por parte de la ABCI cuando se recibe una
transacción es añadir el elemento subyacente a la \setchain siempre y cuando el mismo
sea válido.
%
Siempre es necesario chequear del lado de la ABCI si una transacción es válida.
%
Nótese que un nodo correcto podría chequear la transacción antes de agregarla a la
mempool,
y que el resultado de esa validación cambie para el momento en que ésta arriva a la
ABCI.
%
Por otro lado, un nodo bizantino podría añadir transacciones sin chequear
su validez previamente.
%

Tendermint envía peticiones \EndBlock una única vez por bloque, luego de haber
enviado todas las transacciones dentro del mismo.
%
En este algoritmo, la finalización de un bloque desencadena un incremento de época
y, por lo tanto, cada bloque de Tendermint define una época distitna de \setchain.
%

Finalmente, cuando los clientes invocan \Get, indirectamente inician una llamada
a la función \<abciquery>, que retorna la \setchain hasta la época \texttt{epoch - 1}.
Nótese que la época actual (\texttt{epoch}) puede estar siendo modificada en el momento
en que \<abciquery> se invoca, por lo que no sería correcto que \Get la retorne, puesto que
podría ser una visión parcial de la misma. 

EXPLICITAR QUÉ PINTA TIENE ESTO.

\subsection{Conclusión}
Si bien la implementación descripta en esta sección implementa \setchain, no está explotando su idea
principal: relajar el orden total entre los elementos.
%
Aunque diversos elementos pueden pertenecer a una misma época, significando que no hay orden total
entre ellos, por detrás, el protocolo de consenso de Tendermint sí está decidiendo un orden total
entre elementos.
%
% and take advantage of the
% performance improvements that implies.
%

% that then is broken
% when adding the elements from the same block to a specific epoch.


\section{Segunda implementación: Compresschain}\label{subsec:compresschain}

Para acercanos a la especificación de \setchain, en esta sección proponemos
empaquetar elementos en un lote y comprimir dicho lote
previo a su difusión.
%

Se propone una implementación nueva, llamada \compresschain, que explora
la relajación de orden propuesta por \setchain, aún ejecutando el algoritmo de
consenso de Tendermint por detrás.
%

En lugar de difundir inmediatamente cada elemento añadido por un cliente como una
transacción de Tendermint, una nueva pieza intermedia de software llamada \textit{collector}
es responsable de recolectar elementos hasta llegar a un lote lo suficientemente grande,
que es difundido como una única transacción.
%

\subsection{Flujo de mensajes}
Al igual que como se hizo para la versión \vanilla, se presentará el flujo de mensajes usual
que se inicia cuando un cliente invoca \Add(e).
En la Figura~\ref{fig:compresschain-flow} se muestras figuras detalladas de los distintos pasos de
este flujo en el contexto de \compresschain.
%

El proceso comienzo con el sistema en su estado inicial. Ahora, detrás de la API de \setchain
se encuentra la nueva pieza intermedia \collector. Esto se muestra en la Figura (a).

%

El primer paso se da cuando el ciente envía un elemento $e$, mediante la invocación a \Add(e) (ver
Figura (b)).
Desde el punto de vista del cliente, no hay diferencias en relación a la versión \vanilla, ya que
la existencia del \collector es transparente para él.

%

En la Figura (c) se muestra que el \collector recolecta elementos que envían los distintos clientes y los agrupa
en un lote.
Un lote contiene potencialmente varios elementos envíados por uno o más clientes a una misma instancia
corriendo el Tendermint Core, la aplicación, y el \collector.
Una vez que el lote se encuentra listo, el \collector tiene una nueva transacción para inyectar en la red de Tendermint.
Esta transacción se presenta en las figuras con un \textit{símbolo de carpeta} gris.

%

A partir de acá el proceso es el mismo que el explicado en la sección anterior para \vanilla: la transacción
que representa al elemento $e$ (y a otros) se chequea contra \CheckTx para determinar si debe ser insertada
en la mempool o descartada.
%
Si llega a la mempool, se espera que luego de un tiempo sea añadida a un bloque de Tendermint, y que eventualmente,
mediante el algoritmo de consenso, este bloque se considere \textit{commited by the network}.
%
Una vez que el bloque fue decidido en el consenso, entonces el Tendermint Core enviará
la secuencia correspondiente de pedidos a la aplicación.
%
Una de las peticiones será \DeliverTx, entregando la transacción correspondiente al lote que contiene a $e$.

Esto se observa en las Figuras (d), (e) y (f).

%
En el último paso de este flujo se agregan las nuevas épocas a la \setchain.
En contraposición con los visto en \vanilla, acá se agrega una nueva época por cada transacción (cada petición \DeliverTx).
Las épocas contienen potencialmente más de un elemento porque, de hecho, las transacciones en este contexto representan a más de un elemento
envíado por los clientes.
Estas transacciones sí tienen orden entre ellas, por lo que el número de época asociada a cada una está determinado por el mismo.
En la Figura (f) se muestra que la época $n$ se agregó a la \setchain y uno de sus elementos es $e$. Esta es, justamente, la época asociada
a la transacción que contiene al elemento $e$.


\begin{figure}
  \subfloat[Estado inicial]{\includegraphics[width = 3.5in]{figures/compresschain-flow-0.png}}
  \subfloat[El cliente invoca \Add(e)]{\includegraphics[width = 3.5in]{figures/compresschain-flow-1.png}}\\
  \subfloat[El lote está listo y es difundido]{\includegraphics[width = 3.5in]{figures/compresschain-flow-2.png}}
  \subfloat[$t_e$ se chequea contra \CheckTx]{\includegraphics[width = 3.5in]{figures/compresschain-flow-3.png}}\\
  \subfloat[Se consensúa el próximo bloque]{\includegraphics[width = 3.5in]{figures/compresschain-flow-4.png}}
  \subfloat[Se envían los pedidos de la ABCI a la aplicación]{\includegraphics[width = 3.5in]{figures/compresschain-flow-5.png}}\\
  \subfloat[Se agrega la nuevas épocas a la \setchain]{\includegraphics[width = 3.5in]{figures/compresschain-flow-6.png}} 
  \caption{Flujo usual de mensajes para compresschain}
  \label{fig:compresschain-flow}
\end{figure}

\subsection{Algoritmos}


%
% This means that a new
% \setchain API version is defined, which uses the new collector component.
%
% We define a collector in Algorithm.

% To achieve a better throughput in
% terms of size per element broadcasted,  is used.
%

Como ya se mencionó, en lugar de agregar directamente elementos enviados por los usuarios a la red de Tendermint,
primero se recolectan y se comprimen para ser enviados como una única transacción.
Siguiendo la práctica actual de Ethereum, se utiliza el algoritmo
\textit{Recursive Length Prefix} (RLP)~\cite{ethereum} para codificar los elementos individualmente
y el algoritmo de compresión Brotli~\cite{brotli.compressor} para comprimir el lote.
~\footnote{ Otros algoritmos de codificación y de compresión podrían utilizarse de ser necesario.}

%
Un lote se considera \textit{listo} para ser enviado una vez que o bien alcanza un tamaño máximo,
o bien una cantidad razonable de tiempo transacurrió desde que el primer elemento llegó. 
%
En el Algoritmo ~\ref{alg:collector-brotli} se muestra una implementación posible para un \textit{collector}.
El Algoritmo~\ref{alg:api-brotli} presenta una nueva definición para la API de \setchain.

\input{algorithms/alg-collector-brotli}

\input{algorithms/alg-api-brotli}

%
En esta implementación, un cliente que ejecuta \<add> invoca indirectamente el método \texttt{AddElement}
del \textit{collector}.
%
Se realizaron algunas simplificaciones en los algoritmos presentados. Por ejemplo, una condición de carrera
podría ocurrir si varias rutinas agregan elementos a la misma instancia del \textit{collector} concurrentemente.
Sin embargo, esto puede resolverse sencillamente gracias al uso de candados.



% After the meeting we decided to call isValidElement() locally in the collector, so the following is not true:
% It is worth mentioning that, as the algorithm shows, the collector adds every element that receives to the batch
% without running any validation on it. While this clearly allows the batch to contain garbage,
% making a \textit{CheckTx()} request to the ABCI app for each new element would mean a decrease in
% performance, as the number of requests would keep constant in the number of elements sent by clients,
% instead of being constant in the number of batches, as it is desired.

%
Para completar nuestra definición, se provee la definición del ABCI de Compresschain en el
Algoritmo~\ref{alg:abci-brotli}.
%
Existen varias diferencias con respecto a la implementación previa de \setchain.
%
\input{algorithms/alg-abci-brotli}

La diferencia principal con la implementación Vainilla radica en que las transacciones contienen
potencialmente más de un elemento de usuario. Esto se da porque las transacciones en este contexto
son lotes comprimidos de elementos.
%
Más aún, para recuperar elementos dentro de las transacciones, se necesita primero descomprimir
el lote y, una vez que se tiene el lote original, debe RLP-decodificarse para así obtener los elementos
originales enviados por los clientes.

Aquellos elementos son los que deben ser agregados a la \setchain. La función \textit{getElementsFromTransaction()}
muestra este comportamiento.

En la definición de Compresschain, las transacciones de Tendermint pueden contener tanto elementos válidos
como inválidos.
%

Se necesita definir un nuevo criterio para determinar cuándo una transacción (es decir, un lote de elementos
comprimido) se considera válida.

%
La función \<isValidBatch>~(en el Algoritmo~\ref{alg:abci-brotli}) implementa este nuevo criterio, permitiendo
a las transacciones ser consideradas válidas si al menos uno de sus elementos es válido.
%
La elección de este criterio está relacionado con el hecho de que alguien enviando elementos inválidos~\footnote{
Los elementos pueden ser válidos al momento en que los clientes los envían, pero ser inválidos una vez que
los bloques fueron consensados.} a un nodo no debería privar a los elementos válidos envíados al mismo nodo de
ser añadidos a la \setchain.

%
Sin embargo, como se ilustra en la función \<DeliverTx>, solo elementos válidos se agregan a la \setchain,
mientras que los inválidos simplemente se descartan.
%
Finalmente, en Compresschain, los bloques no delimitan épocas por lo que no se peresenta una definición para
la función \<EndBlock>.

%
En este caso, las épocas se definen como transacciones: cada lote de elementos define una época.

% %
% definition was given in this case, as the block does not
% delimit the epoch anymore, but the epoch is defined by all the elements
% belonging to the same Tendermint transaction.
% \textit{DeliverTx()} function
% shows the epoch number increase.

% To dicuss: if epochs are defined by batches, then epochs are generated by the same node.
% This is a new setchain property and may be undesirable. 
\section{Tercera implementación: Hashchain}\label{subsec:hashchain}
%
Hashchain se alínea con el concepto introducido en Compresschain; sin embargo, usa
funciones hash en lugar de compresión en Brotli.

%Hashchain follows a similar idea introduced in Compresschain but employing hash
%functions instead of Brotli compression.
%
Mientras que el poder de compresión de las funciones hash puede ser enorme, dado que las funciones
mapean datos de longitud arbitraria a valores de tamaño fijo, los hashes son irreversibles. Esto
significa que un método no trivial para recuperar el lote original de elementos debe proveerse.

%
La implementación de Hashcain involucra dos aspectos: una blockchain de Tendermint compuesta por hashes,
y una estrategia distribuída para invertir hashes y obtener los lotes originales.
%
% We shouldn't mention "consolidated hashes" before explaining it:
%Therefore, we now have to maintain an inverse function for the consolidated
%hashes.

A menudo en esta sección nos tomaremos la libertad de utilizar la expresión \textit{elementos en un hash H}
para referirnos a aquellos elementos pertenecientes al lote $B$, tal que $Hash(B) = H$.

En lugar de usar el \textit{collector} de Compresschain (ver Algoritmo ~\ref{alg:collector-brotli}),
ahora utilizamos un \textit{hash collector}, que construye un lote de elementos para luego hashearlo
antes de introducirlo a la red de Tendermint.
%
Los lotes hasheados son difundidos como transacciones y compartidos a través de toda la red, de forma
análoga al enfoque empleado para los lotes comprimidos en Compresschain.

\subsection{Algoritmo distribuído para la inversión de hashes}

Como ya se mencionón, el \textit{hash collector} adopta un concepto similar al \textit{compression collector}
de Compresschain. Sin embargo, la definición de la ABCI para Hashchain es considerablemente más compleja.
%
En este escenario, tanto \<CheckTx> como \<DeliverTx> reciben hashes como transacciones.
%
Una máquina corriendo la \setchain no puede traducir inmediatamente hashes para obtener su lote de elementos
original, debido a la naturaleza irreversible de un hash.
%
La ausencia del lote original de elementos hace que \<CheckTx> sea incapaz de verificar los elementos
en la transacción, y que \<DeliverTx> no pueda añadir elementos a la \setchain.
%

En este punto, nuestro algoritmo distribuído para la inversión de hashes entra en juego.
%

La idea principal es comunicarnos con un nodo de Tendermint que conoce el hash (inicialmente, solo su creador).
%
Para distribuír la información sobre quiénes conocen los datos de un hash, las transacciones contienen
no solo el hash del lote, pero además una firma.
%
Las firmas que acompañan los hashes indican que un validador específico de Tendermint
(quien firma el hash) afirma conocer el hash y, por lo tanto, si es un nodo correcto,
tiene el lote original de elmentos.
%
De esta forma, las transacciones se representan con una tupla $(h, s)$, donde $h$ denota
el valor del hash y $s$ representa la firma obtenida al firmar $h$ con la clave privada
del nodo que conoce el hash.
%
Gracias a la firma es posible comunicarse con el nodo que afirma conocer los datos, y obtener
el lote original (si el nodo se comporto apropiadamente).
%
El proceso de petición de hashes se corre de forma asíncrona para evitar potenciales
retrasos.

%
Después de dejar el colector, se espera que los hashes sean chequeados contra \<CheckTx>
para o bien ser añadidos a la mempool o bien ser descartados.

%
Para determinar la validez de un hash se necesita chequear los elementos en él.

%
Similar a Compresschai, los hashes son considerados válidos si al menos un elemento
en el hash es válido.
%
Para un nodo dado, en el punto en que \<CheckTx> corre, no podemos asegurar que el
lote original de elementos sea conocido.

%
Hashchain es optimista en el sentido de que, ante la imposibilidad de correr el chequeo
de las transacciones, debido a la ausencia del lote original, \<CheckTx> considera a los
hashes como transacciones válidas con la esperanza de que sus lotes originales sean enviados
y conocidos más tarde. 

%
La naturaleza optimista de Hashchain tiene consecuencia notables.
%
Como el comportamiento por defecto de  \<CheckTx> es retornar \texttt{True},
se pueden tener transacciones en la blockchain sin conocer los elementos de éstas
(solo conociendo los hashes).

%
Aun más, una transacción puede terminar siendo parte de la blockchain sin que nadie
la haya chequeado previamente, pero pasando el chequeo por el comportamiento optimista.

%
De hecho, este es probablemente el caso para la primera vez que un nuevo hash aparece
en la blockchain (fue consensuado sin que los nodos hayan chequeado realmente los elementos
del lote.)

%

%Therefore, we need a way to extract the elements inside the transactions and
%provide the user a uniform view, that of a Setchain.
Por lo tanto, necesitamos definir un criterio para determinar cuándo es seguro
que los elementos en un hash que está en la blockchain sean parte de la \setchain.

% the HashChain living in
% Tendermint, and the \setchain we want to build.
%
Para lograr eso, se define un número natural \texttt{SIGNATURES\_PER\_HASH} que establece
el número de firmas que un hash tiene que tener para que los elementos del lote asociado a él
sean considerados elementos a añadir a la \setchain.

%
Estamos únicamente interesados en hashes firmados por al menos \texttt{SIGNATURES\_PER\_HASH}
nodos, y los llamamos \textit{hashes consolidados}.

\texttt{SIGNATURES\_PER\_HASH} es definido de una manera tal que se garantiza que si un hash
consolidó entonces al menos un nodo correcto conoce el lote original del cual proviene.

%
Los elementos de hashes consolidados son los candidatos a pertenecer a la \setchain.

%Following the same criteria as in Compresschain, we consider a transaction to
%be valid if we can get the data and validate at least one of its elements.
%
% With this in mind, whenever the ABCI gets the revert of a hash, it runs the
% validation against it, and
%Moreover, if at least one element in the batch is valid, the node verifying the
Cuando un nodo pregunta por la inversión de un hash, si al menos un elemento en el lote
es válido, el nodo firma el hash (con sus propia clave privada), y difunde el hash junto
con su propia firma.

%
Al difundir el hash y su firma, el nodo anuncia a la red que conoce el lote detrás de ese hash.
%
De esta forma, los lotes válidos eventualmente consolidarán, significando que sus elementos
serán añadidos a la \setchain.

Para que esto funcione, se necesita mantener un registro de cuántas firmas tiene un hash,
así como también un mapeo de hashes a lotes.
%
Durante la ejecución de \<DeliverTx> se chequea la validez de la firma.
%
Si la firma es válida y nueva para el hash en cuestión, se incrementa el contador de
\texttt{firmas por hash}.
%
Además, cada vez que un hash es invertido, se chequea la correctitud del lote original
(es decir, $hash = Hash(originalBatch)$). En caso de éxito, el mapeo de hash a lotes
es actualiado con el nuevo descubrimiento.

%The first time a hash is passed around, other nodes would see the new hash and
%try to get the data from other servers.
%
%The first one claiming to have the data is the creator of the transaction.


%When a \<get> arrives, we need to get the elements out of the consolidated
%hashes.
% it is necessary to ask for the batch
% corresponding to the hash in the transaction.
%



% Something we discussed with Marga: when the collector creates a hash h and signs it, and broadcast (h, s) every call to CheckTx(h, s) will be true, as no one is expected to have the reverse of h the first time they see it. Because of that, (h, s) in the hashchain doesn't mean that there is at least one good valid element in the h. h could be full of garbage
% A client could contact every collector node with the same elements, and every collector would broadcast (h, sn), with n being the n-collector. This could cause that hash h consolidates, without anyone really having checking elements in h. Is that bad? not too bad, only an empty epoch would occur. Possible fixes: collector hashes elements + pubkey, chain of signatures

\subsection{Consolidación de épocas}\label{subsubsec:consolidation}

En esta implementación, las épocas se definen por todos los elementos en un hash, similar
a la implementación de Compresschain.

%
En otras palabras, los elementos que provienen del mismo hash consolidado pertenecen a la
misma época.

%
%Now we have to be more careful when adding elements to the setchain, elements
%may appear several times depending on how nodes form batches and
%hashes. \marga{esto no puede pasar tambien en compresschain? un
%  elemento no puede aparecer en varios batches?}
%
% However, what epoch number is that? We need to be more specific
% to define this.

%

En este trabajo se presentan dos alternativas para asignar una época a un hash consolidado.

%
La primera se llama \textit{Consolidación de época actual} (CEC), que significa que 
una vez que un hash consolida, todos sus elementos subyacentes son añadidos a la época actual
(es decir, a la época en el cual la firma número \texttt{SIGNATURES\_PER\_HASH} es vista).
%
La segunda estrategia, \textit{Consolidación de época de primera vista} (FSEC) asigna la época
de acuerdo a cuándo el hash fue visto por privera vez. La asignación de época se lleva
a cabo una vez que el hash consolidó. 

%
Las transacciones (hashes en este caso) en los bloques de Tendermint están totalmente ordenadas,
por lo tanto ambas estrategias pueden determinar cuál hash ocurrió o consolidó primero, y
todos los nodos correctos estarán de acuerdo en eso.

%

En la Figura~\ref{fig:consolidation_epoch} se muestra un ejemplo de estas dos estrategias para asignar
un número de época a un hash que consolidó cuando \texttt{SIGNATURES\_PER\_HASH} es 3.

%
El hash $j$ es el primer hash en el bloque $m$, y el hash $k$ es el hash que primero consolida
(es decir, el primero en obtener su tercera firma).

%
Por un lado, la estrategia de consolidación de época actual asigna la época tan pronto como
el hash consolida, estampando los elementos en el hash $k$ con época $a$ primero, y luego
a los elementos en el hash $j$ con la época $a+1$.

%
Por el otro lado, la consolidación de época de primera vista no asigna la época al hash $k$
apenas éste consolida, porque el hash $j$ fue visto por primera vez antes que $k$.
%
Dado que el hash $j$ consolida justo después que el hash $k$, los elementos del hash $j$ son
estampados
con la época $a$, y los elementos del hash $k$ son estampados con la época $a+1$. 


\begin{figure}
  \centering
  \includegraphics[scale=0.5]{figures/consolidation_epoch.pdf}
  \caption{Consolidation epoch strategies}
  \label{fig:consolidation_epoch}
\end{figure}

La variante de consolidación de época de primera vista le otorga a los hashes un período
de gracia en el cual pueden o bien consolidarse o bien ser descartados.
%
Dicho período de gracia es necesario, examinemos por qué.
% The grace period is necessary, let
% us briefly examine why.
Suponiendo que no existe período de gracia tal, si un hash $j$ apareciera por primera vez
antes que el hash $k$, una vez que consolidados, los elementos provenientes del hash $j$
serían estampados con la época $E$, mientras que los elementos del hash $k$ serían estampados
con una época $F$ \textgreater \ $E$.
%
Sea $j$ un hash que fue visto por primera vez en un momento tal que, una vez consolidado,
se le asignaría la época $E$.
%
Si el hash $j$ nunca logra obtener las \texttt{SIGNATURES\_PER\_HASH} firmas para
consolidar, un hash $k$ más nuevo (es decir, un hash que fue visto por primera vez
después de $j$) no podría consolidad, dado que sus elementos subyacentes no podrían ser
estampados con una época $F$ \textgreater \ $E$, si la época $E$ no fue definida aún.
%
En la Figura~\ref{fig:grace_period} se muestra un ejemplo de esto.
%
Se concluye entonces que un período de gracia es necesario para garantizar la evolución
éxitosa de la \hashchain. De este modo, los hashes $k$ y $l$ (e incluso $o$ y $q$) no
pueden consolidarse hasta que $j$ consolide o sea rechazada.
%
Vale la pena notar que el aspecto crucial en la consolidación de FSEC radica en la ocurrencia
de las \texttt{SIGNATURES\_PER\_HASH} firmas dentro de una ventana equivalente a la duración
del período de gracia.
%
Los hashes que son inicialmente rechazados pueden consolidar en el futuro siempre y cuando
consigan las \texttt{SIGNATURES\_PER\_HASH} firmas dentro del período de gracia.
%
Los hashes que logran las \texttt{SIGNATURES\_PER\_HASH} firmas terminado el período de gracia
no consolidarán en la ronda actual; sin embargo, pueden hacerlo en el futuro.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{figures/grace_period.pdf}
  \caption{Scenario requiring grace period under FSEC.}
  \label{fig:grace_period}
\end{figure}

%\subsubsection{Elements Membership Proof}
% Do not use this because we want a proof that specific elements belong to a specific epoch.
%Client processes do not know if they are contacting a Byzantine or correct process. The general idea of a client protocol that wants to ensure that an element is going to be added to the \setchain is to interact with enough servers to guarantee that some are correct. To guarantee contacting at least one correct server, the client needs to send f + 1 messages. However, each element added to the \setchain comes from a consolidated hash. That means that we already have \textbf{SIGNATURES\_PER\_HASH} validator's signatures for that hash. Those signatures may act as a proof for the batch of elements that really belongs to the \setchain. If that proof is added to the epoch as an extra element, a client sending an element, waiting for a while, and then requesting a Get to only one server (hoping it is correct server) may be sure that its element belongs to the \setchain because the epoch comes along a proof of their elements. 

\subsection{Ataques front-running}
En el contexto de las blockchains, un ataque de front-running refiere a una situación en donde
un actor malicioso explota conocimiento sobre transacciones pendientes para obtener una ventaja
desleal. Debido a que las transacciones pendientes son públicas, un usuario malicioso puede
observar las transacciones que le llegan a una víctima, construír una nueva transacción y luego
encontrar una forma de ubicarla antes que la transacción de la víctima. En la red Ethereum, esta
\textquotedblleft forma \textquotedblright de colocar una transacción antes de otra es usualmente
llevada a cabo mediante pagos: o bien pagando impuestos de transacción (transacction fees) más altos
que la víctima, o haciendo pagos directos a ciertos validadores.
%
Qué clase de ataque de front-running puede suceder al nivel de abstracción de \hashchain?
Supongamos que un validador $v$ recibe una transacción $(h_0, s_0)$, donde $h_0$ es un hash,
y $s_0$ una firma de aquel hash (la primera). Un validador especulador puede firmar él mismo la
transacción y difundirla (el comportamiento esperando), o puede ignorarla (un posible comportamiento
malicioso). Si el validador la firma y la difunde, entonces está colaborando para que el hash
consolide (y, por lo tanto, los elementos provenientes de él se agreguen a la  \hashchain).
En caso contrario, no contribuirá a que el hash consolide, potencialmente causando retrasos
o incluso evitando la consolidación.
%

Cuál es la diferencia entre ambas estrategias de consolidación presentadas?
%
En la estrategia FSEC, si una transacción no obtiene las \texttt{SIGNATURES\_PER\_HASH} firmas
dentro del período de gracia, el hash no consolidará en aquella ronda (pero podría hacerlo
en el futuro).
%
En la estrategia CEC, el hash no consolidará hasta obtener las \texttt{SIGNATURES\_PER\_HASH} firmas,
sin tener ningún período de gracia para ello.
%
En este punto, las estrategias no parecen tener diferencias fundamentales. Sin embargo, el aspecto
interesante se da en el escenario alternativo: cuando las transacciones finalmente son añadidas a la
\setchain.
%

Supongamos que $v$ vee una transacción $t_0 = (h_0, s_0)$ y quiere ejecutar un ataque de front-running.
Para lograrlo, ignora la transacción, pero difunde su propia transacción firmada $t_1 = (h_1, s_0)$,
esperando que $t_1$ finalmente sea estampada con una época menor que $t_0$.
%
Bajo el comportamiento FSEC, $h_0$ fue vista por primera vez antes, por lo que si logra las
\texttt{SIGNATURES\_PER\_HASH} firmas dentro del período de gracia, consolidará, y los elementos
en el hash serán estampados con una época menor a la de $t_1$.
%
Notemos que esto es completamente independiente del número de firmas que $h_1$ logre, y la velocidad
a la cual lo haga. $h_1$ podría incluso consolidar (llegar a su firma \texttt{SIGNATURES\_PER\_HASH})
antes que $h_0$.
%
Por el otro lado, bajo el comportamiento CEC la situación es básicamente una carrera entre $h_0$ y
$h_1$: el primero en obtener las \texttt{SIGNATURES\_PER\_HASH} firmas será el primero en consolidar y,
por lo tanto, sus elementos serán estamapdos con una época más temprana.
%
Como ya se mencionó, 
la estrategia FSEC toma en consideración no solo el momento en el cual los hashes consolidan, sino
también el momento en que las transacciones fueron vistas por primera vez.
%
En principio, esta característica se puede considerar un aspeco valioso en la mitigación de ataques
de front-running, dado que las transacciones observadas primero son probablmente las legítimas y
originales.
%At girst glance, we could think that this property is an interesting point to go against
%front-running attacks, as first-seen transactions are probably the legit original transactions.
Sin embargo, la estrategia FSEC viene con algunos apesctos negativos no triviales.
%
Como la época es determinada por el momento en el cual el hash fue visto por primera vez, 
la estrategia de alguna manera \textit{reserva} el número de época para la transacción específica.
Si $v$ quiere que un hash $h_0$ consolide únicamente is puede hacerlo antes que otro hash
$h_1$ (y no necesita conocer los elementos de $h_1$ desde antes), $v$ podría hacer lo siguiente.
%
Primero, difunde la transacción de modo que todos los validadores reservan el número de época para ella.
%
Luego, $v$ no revierte el hash $h_0$ a nadie, porque quiere esperar hasta que el hash $h_1$ aparezca
y obtenga suficientes firmas.
%
Una vez que esto sucede, y es seguro que el hash $h_1$ consolidará, $v$ comienza a revertir su hash
$h_0$ a todos sus pares, esperando que el hash logre las \texttt{SIGNATURES\_PER\_HASH} firmas
dentro del período de gracia.
Si es exitoso, luego $v$ habría cumplido su objetivo: los elementos del hash $h_0$ serían estampados
con una época menor que los elementos provenientes del hash $h_1$.
%

Esta situación es particularmente interesante porque el validador $v$ puede hacer algo
suceder en el pasado (elemento del hash $h_0$ se estampan con época $e$) teniendo información
del futuro (elementos del hash $h_1$ se estampan con época $e+n$). 
%

Es interesante notar que intentar hacer algo similar bajo el esquema CEC sería imopsible, dado
que una vez que el hash $h_1$ consolidó, sus elementos son estampados con un número de época menor
a cualquier hash que aún no consolidó.
%

Volvamos a este ataque con un ejemplo. Supongamos que hay un juego de apuesta simple en donde
las apuestas y el resultado final se publican en la \hashchain. El juego es sencillo: los usuarios
pueden votar por A o por B. Se sabe que el resultado ganador (A o B) se publica en determinado momento,
y todo aquel que haya votado por el resutlado ganador recibirá el premio.
%
Si $v$ es un validador que quiere ganar este juego haciendo trampa, podría votar tanto por A
como por B justo antes del momento en el que se sabe que la compañía publicará el resultado ganador.
%
Dado que $v$ difundió dos transacciones (una votando por A, y otra votando por B) antes de que la
transacción con el resultado ganador aparezca, todos los validadores reserverán un número de época
anterior al del resultado. Después de esto, $v$ no revertirá el hash asociado con estas transacciones
hasta que esté seguro de cuál es el resultado ganador (que efectivamente será añadido a la \hashchain).
%
Una vez que se asegura el resultado ganador, solo dará a conocer la inversa del hash que contiene la apuesta
por el resultado ganador. Si obtiene las firmas necesarias durante el período de gracia,
sus transacciones serían estampadas con un número de época anterior que la transacción de los resultados,
y por lo tanto, $v$ ganaría el juego haciendo trampa.


\input{algorithms/alg-api-hash}

\subsection{Algoritmos}\label{subsubsec:details}

No definimos un nuevo \texttt{collector} para \hashchain dado que es similar al definido
para Compresschain, con la única diferencia del uso de funciones hash.

% No collector piece for Hashchain appears as it is similar to the already
% presented collector for Brotli, employing hash functions instead of Brotli
% compression.
Se define la API de \setchain en el Algoritmo ~\ref{alg:api-hashchain}.

% shows how a new collector is
% used now in order to add elements to the \setchain.

Finalmente, en relación a la definición de la ABCI, se muestra una posible implementación para
\hashchain utilizando la estrategia de consolidación de época actual en el Algoritmo ~\ref{alg:abci-hash1}
y ~\ref{alg:abci-hash2}.

Es nootorio que en el algoritmo la función \<Query> inicia la construcción de \<history>, además de
la difusión de pruebas de época. Aunque este enfoque es empleado para claridad, a nodo que recive consultas
no muy frecuentemente podría experimentar retrazos en la generación de pruebas de época.
Como resultado, el proceso de contrucción de \<history> y las pruebas de época podrían ser ejecutadas
periódicamente mediante planificación, independientemente de la petición de consultas.

\input{algorithms/alg-abci-hash}
%As mentioned above, Hashchain First Seen Consolidation version uses an idea of grace period in which the hashes are either consolidated or discarded. In this case, we will define the grace period in terms of number of blocks, meaning that if a hash has been seen for the first time in block $B$, and the grace period is $P$ blocks, then on block $B$ + $P$ we will determine if the hash is consolidated (hence, their elements are added to the \setchain), or is discarded. To implement this, we will keep a fixed capacity queue (with capacity $P + 1$), in which the \textit{i}-th element has a list of hashes seen for first time in block $current block - (P - i)$. Notice that the first element of the queue has the list of hashes that were seen for first time in block $current block - P$, meaning that those hashes will be decided in the current block. The last element of the queue has the list of hashes first seen at the current block. Algorithm ~\ref{alg:abci-hash-first-seen} illustrates this behavior.

%\input{algorithms/alg-abci-hash-first-seen}

%%% Local Variables:
%%% TeX-master: "article.tex"
%%% TeX-PDF-mode: t
%%% End:
