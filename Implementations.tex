\section{Implementaciones}\label{sec:impl}

En esta sección se presenta una familia de implementaciones de \setchain de mundo
real construídas sobre Tendermint.
%
En particular, se exponen tres alternativas diferentes, comenzando con una
solución inocente pero trivialmente correcta, y finalizando con un algoritmo
complejo que implementa \setchain utilizando funciones hash.
%
Para evitar repeticiones, las definciones de funciones que permanezcan sin cambios
de una versión a la siguiente, no serán re-escritas.
Solo se volverán a presentar aquellas funciones para las cuales la definición se
vea modificada.
%
A su vez, con la intención de mantener consistencia en la nomenclatura,
el término \textit{transacción} se utiliza siempre para referirse a las
\textit{transacciones de Tendermint}, mientras
que \textit{elemento} queda reservado para elementos a agregarse a la \setchain.
%
Dependiendo de la alternativa sobre la que se esté trabajando, una transacción de
Tendermint puede contener uno o más elementos a ser agregados.
%
% \subsection{General Considerations about Implementation}\label{subsec:general}
Las implementaciones correctas de \setchain implementan dos métodos~(ver sección
~\ref{sec:prelim}): \Add y \Get, y por lo tanto, cada solución provee definiciones
para ambas.
%
Por su parte, Tendermint provee dos \textit{endpoints} RPC principales.
Nótese que el cliente siempre se comunica con un nodo particular de la red.
\begin{itemize}
  \item \texttt{Tendermint.Broadcast} se utiliza para enviar transacciones.
  Cuando una transacción es enviada, se chequea si dicha transacción
  es válida contra la aplicación (mediante la llamada a \<CheckTx>), y en caso
  afirmativo, se añade
  a la mempool, se difunde a los otros nodos, y eventualmente se incluye en
  un bloque.
  \item \<abciquery> se utiliza para consultar el estado de la
  aplicación.
\end{itemize}
%

% Important: Note the mempool does not provide strong guarantees - just because a tx
% passed CheckTx (ie. was accepted into the mempool), doesn't mean it will be committed,
% as nodes with the tx in their mempool may crash before they get to propose.

Por lo tanto, desde el punto de vista del cliente de la \setchain, solo existen dos
métodos (\Add y \Get).
%
Sin embargo, hay dos métodos adicionales que se utilizan para comunicarse con la
red de Tendermint subyacente (los ya mencionados \texttt{Tendermint.Broadcast} y
\texttt{Tendermint.Query}).
%

Finalmente, \setchain asume que hay un predicado definido por el usuario que define
cuándo un elemento es válido para ser admitido en el conjunto.
%
En esta sección, dicho predicado se referencia con la función \isValidElement.

%
A continuación se presentan diferentes definiciones de métodos y funciones
necesarias para que la aplicación corriendo sobre Tendermint implemente \setchain.
Esto involucra, por un lado, los métodos presentados como parte de la API de
\setchain y, por el otro, los perteniences a la interfaz de aplicación de
blockchain ~(ver sección ~\ref{sec:prelim}).

\section{Primera implementación: vainilla}\label{sec:vanilla}

\input{algorithms/alg-api-vanilla}
%
En el Algoritmo~\ref{alg:api-vanilla} se muestra la solución más sencilla a la API
de \setchain utilizando Tendermint.
%

Los clientes agregan elementos invocando (indirectamente) a la función
\texttt{Tendermint.Broadcast}, mientras que pueden consultar el estado actual de
la \setchain invocando (también de forma indirecta) a \texttt{Tendermint.Query}.
%

Para dar una implementación completa de \setchain utilizando Tendermint, además se
deben dar las definiciones de los métodos pertenecientes a la interfaz ABCI
(ver sección~\ref{subsec:abci}). 
%

El Algoritmo~\ref{alg:abci-vanilla} muestra la definición de la ABCI para la versión
Vainilla.
%
Solo se definen \CheckTx, \DeliverTx, y \EndBlock; el resto tiene implementaciones
triviales.

%
El flujo usual de elementos agregados al invocar \Add(e) en esta implementación es el siguiente.
%
Comp primer paso, Tendermint chequea que el elemento $e$ a agregar sea válido a través de
\CheckTx, y si lo es, entonces insertará el elemento en la mempool. En caso contrario,
lo descartará y el flujo de dicho elemento terminará.
%
Si el elemento $e$ llega a la mempool, luego de un tiempo, es esperable que sea añadido a un
bloque de Tendermint, propuesto como siguiente bloque en la cadena como parte del algoritmo de
consenso. Una vez que dicho bloque obtiene todos los votos necesarios para ser considerado
\textit{commited by the network}, Tendermint enviará
la secuencia correspondiente de pedidos a la aplicación: \BeginBlock para indicar el inicio de
un nuevo bloque,
una lista de llamadas a \DeliverTx por cada transacción agregada (en el orden en que fueron
consensuadas dentro del bloque)\footnote{En esta implementación
una \textit{transacción} agregada coincide con un \textit{elemento} agregado.},
\EndBlock para indicar la finalización del bloque, y \Commit para señalizar que el nuevo estado
puede ser persistido.

%\input{algorithms/alg-abci-vanilla}

En esta versión, chequear si una transacción es válida consiste en simplemente chequear
la validez del elemento, dado que las transacciones contienen un único elemento.
%
Puede parecer absurdo definir la función \texttt{getElementFromTransaction()}
en este caso (dado que es la función identidad). Sin embargo, la decisión de dar
la definición explícita se basa en enfatizar la diferencia conceptual entre una
transacción de Tendermint, y los elementos a añadir en la \setchain.
%

El Tendermint core envía peticiones \DeliverTx asíncronamente (pero en orden)
una vez por cada transacción en el bloque.
%
Nótese que las transacciones ya fueron ordenadas en el consenso global por el protocolo
de Temndermint cuando \DeliverTx se ejecuta.
%
Para este algoritmo, la única acción a realizar por parte de la ABCI cuando se recibe una
transacción es añadir el elemento subyacente a la \setchain siempre y cuando el mismo
sea válido.
%
Siempre es necesario chequear del lado de la ABCI si una transacción es válida.
%
Nótese que un nodo correcto podría chequear la transacción antes de agregarla a la
mempool,
y que el resultado de esa validación cambie para el momento en que ésta arriva a la
ABCI.
%
Por otro lado, un nodo bizantino podría añadir transacciones sin chequear
su validez previamente.
%
Tendermint envía peticiones \EndBlock una única vez por bloque, luego de haber
enviado todas las transacciones dentro del mismo.
%
En este algoritmo, la finalización de un bloque desencadena un incremento de época
y, por lo tanto, cada bloque de Tendermint define una época distitna de \setchain.
%
Finalmente, cuando los clientes invocan \Get, indirectamente inician una llamada
a la función \<abciquery>, que retorna la \setchain. EXPLICITAR QUÉ PINTA TIENE ESTO.

\subsubsection{Prueba de membrecía de elementos}\label{subsubsec:membership}
%
Como se mencionó antes, cuando un proceso cliente utiliza la API de \setchain
para añadir un elemento, o para recuperar el estado actual de la \setchain,
se comunica con un nodo parituclar de la red. Es importante notar que, en este
sentido, un proceso cliente no puede saber si se está contactando con un nodo
correcto o con un nodo bizantino.
%Client processes do not know if they are contacting a Byzantine or correct
%process.
%
Para asegurar que un elemento será añadido a la \setchain, el cliente neecesita
interactuar con suficientes servidores, de modo de garantizar que al menos uno de ellos
es correcto~\cite{Capretto.2022.Setchain}.
%
% An extension to Setchain presented an optimistic client with the following
% approach.
%
Los nodos correctos firman criptográficamente un hash del conjunto de elementos
pertenecientes a una época, e insertan este hash como un elemento en la \setchain.
%
A esos hashes los llamamos \textit{elementos de prueba de época}.
%
Estas pruebas de época pueden implementarse utilizando \textit{Ed25519}~\cite{ed25519}
como sistema de firmas.
%
Las pruebas de época en principio contienen: el número de época al cual pertenece
la prueba, la clave pública del validador que firma, y la firma de los elementos 
de la época dada (ordenados de una forma específica y conocida).
%
De esta manera, los clientes solo ejecutan una única petición $\<add>(e)$ a un
determinado servidor, esperando que sea correcto. 
%
Luego de esperar cierto tiempo, los clientes pueden invocar  \<get> (también a un
único nodo) y chequear si el elemento $e$ pertenece a alguna época y existen suficientes
pruebas para dicha época\footnote{Se asume que una cota superior $f$ de número de servidores
biantinos es conocida y, por lo tanto, se requieren $f+1$ firmas.}. De este modo, se garantiza
que al menos un servidor corrector la firmó.
%
Los clientes pueden verificar si las pruebas de época son válidas generando el hash de elementos
en la época dada, y verificando (a través de la clave pública) si la firma de la prueba es válida
para el hash obtenido.
%
Las claves públicas de los validadores necesitan ser públicamente conocidas para los usuarios.
%
Si un elemento $e$ pertenece a una época que tiene suficientes prueas, los clientes pueden
concluír que la época es correcta y que $e$ fue éxitosamente insertado en la \setchain.
%
Nótese que esto solo requiere una llaada a \<add> y una llamada a \<get>.
%
Este mecanismo de membrecías de elementos a épocas está implementado en la definición de
\<EndBlock>.
%
Otra opción para implementar los elementos de prueba de época es a través de la librería
criptográfica de \textit{ethereum}.
%
Esta librería provee una función \texttt{Sign} que cacula una firma ECDSA.
%
La firma producida se encuentra en el formato $[R || S || V]$, donde $V$ es 0 o 1.
%
El valor de $V$ es usualmente llamado \textit{bit de recuperación}, y permite utilizar
la función \texttt{Ecrecover}, la cua dado un hash y una firma, retorna la clave pública
(en formato descomprimido) que creó dicha firma.
%
De esta forma, los elementos de prueba de época pueden contener el número de época y la firma
en el formato mencionado arriba, y los clientes pueden usar la función \texttt{Ecrecover} para
verificar que la firma dada fue de hecho generada por un validador conocido.
%
Nótese que las épocas ahora contienen dos tipos de elementos: elementos regulares enviados por
un cliente, y elementos de prueba de época; significando que cada elemento de prueba de época
pertenece a su vez a una época. Sin embargo, los elementos de pruea de época no necesitan ser
incluídos como elementos en el hash firmado que es parte de la prueba de época para una época
dada.
%
Consecuentemente, es necesario diferenciar entre elementos regular, y elementos de prueba de época.
%
La validez de los elementos regulares se chequea a través de la ya mencionada función
\texttt{isValidElement}.
%
Sin enmbargo, un elemento de prueba de época necesita ser validado de otra manera: verificando la firma.
%

\subsubsection{Conclusión}
Si bien la implementación descripta en esta sección implementa \setchain, no está explotando su idea
principal: relajar el orden total entre los elementos.
%
Aunque diversos elementos pueden pertenecer a una misma época, significando que no hay orden total
entre ellos, por detrás, el protocolo de consenso de Tendermint sí está decidiendo un orden total
entre elementos.
%
% and take advantage of the
% performance improvements that implies.
%

% that then is broken
% when adding the elements from the same block to a specific epoch.


\subsection{Segunda implementación: Compresschain}\label{subsec:compresschain}

Para acercanos a la especificación de \setchain, en esta sección proponemos
empaquetar elementos en un bache, formando un conjunto y comprimiéndolo
previamente a su difusión.
%
Se propone una implementación nueva, llamada \emph{Compresschain}, que explora
la relajación de orden propuesta por \setchian, aún corriendo el algoritmo de
consenso de Tendermint por detrás.
%
En lugar de difundir inmediatamente cada elemento añadido por un cliente como una
transacción de Tendermint, una nueva pieza intermedia de software llamada \textit{collector}
es responsable de recolectar elementos hasta llegar a un bache suficientemente grande,
que es difundido como una única transacción.
%
Siguiendo la práctica actual de Ethereum, se utiliza el algoritmo de codificación RLP de
Ethereum~\cite{ethereum} y el algoritmo de compresión Brotli~\cite{brotli.compressor}
~\footnote{ Otros algoritmos de codificación y de compresión podrían utilizarse de ser necesario.}
%
% This means that a new
% \setchain API version is defined, which uses the new collector component.
%
% We define a collector in Algorithm.

% To achieve a better throughput in
% terms of size per element broadcasted,  is used.
%

En lugar de agregar directamente elementos enviados por los usuarios a la red de Tendermint,
primero se recolectan y se codifican utilizando RLP y, una vez que el bache está listo,
se comprime el bache con el agoritmo de compresión Brotli.
%
Un bache se considera \textit{listo} para ser enviado una vez que o bien alcanza un tamaño máximo,
o bien una cantidad razonable de tiempo transacurrió desde que el primer elemento llegó. 
%
En el Algoritmo ~\ref{alg:collector-brotli} se muestra una implementación posible para un \textit{collector}.
El Algoritmo~\ref{alg:api-brotli} prsenta una nueva definición para la API de \setchain.

%
En esta implementación, un cliente que ejecuta \<add> invoca indirectamente el método \texttt{AddElement}
del \textit{collector}.
%
Se realizaron algunas simplificaciones en los algoritmos presentados. Por ejemplo, una condición de carrera
podría ocurrir si varias rutinas agregan elementos a la misma instancia del \textit{collector} concurrentemente.
Sin embargo, esto puede resolverse sencillamente gracias al uso de candados.


\input{algorithms/alg-api-brotli}

\input{algorithms/alg-collector-brotli}

%

% After the meeting we decided to call isValidElement() locally in the collector, so the following is not true:
% It is worth mentioning that, as the algorithm shows, the collector adds every element that receives to the batch
% without running any validation on it. While this clearly allows the batch to contain garbage,
% making a \textit{CheckTx()} request to the ABCI app for each new element would mean a decrease in
% performance, as the number of requests would keep constant in the number of elements sent by clients,
% instead of being constant in the number of batches, as it is desired.

%
Para completar nuestra definición, se provee la definición del ABCI de Compresschain en el
Algoritmo~\ref{alg:abci-brotli}.
%
Existen varias diferencias con respecto a la implementación previa de \setchain.
%
\input{algorithms/alg-abci-brotli}

La diferencia principal con la implementación Vainilla radica en que las transacciones contienen
potencialmente más de un elemento de usuario. Esto se da porque las transacciones en este contexto
son baches comprimidos de elementos.
%
Más aún, para recuperar elementos dentro de las transacciones, se necesita primero descomprimir
el bache y, una vez que se tiene el bache original, debe RLP-decodificarse para así obtener los elementos
originales enviados por los clientes.

Aquellos elementos son los que deben ser agregados a la \setchain. La función \textit{getElementsFromTransaction()}
muestra este comportamiento.

En la definición de Compresschain, las transacciones de Tendermint pueden contener tanto elementos válidos
como inválidos.
%

Se necesita definir un nuevo criterio para determinar cuándo una transacción (es decir, un bache de elementos
comprimido) se considera válida.

%
La función <isValidBatch>~(en el Algoritmo~\ref{alg:abci-brotli}) implementa este nuevo criterio, permitiendo
a las transacciones ser consideradas válidas si al menos uno de sus elementos es válido.
%
La elección de este criterio está relacionado con el hecho de que alguien enviando elementos inválidos~\footnote{
Los elementos pueden ser válidos al momento en que los clientes los envían, pero ser inválidos una vez que
los bloques fueron consensados.} a un nodo no debería privar a los elementos válidos envíados al mismo nodo de
ser añadidos a la \setchain.

%
Sin embargo, como se ilustra en la función \<DeliverTx>, solo elementos válidos se agregan a la \setchain,
mientras que los inválidos simplemente se descartan.
%
Finalmente, en Compresschain, los bloques no delimitan épocas por lo que no se peresenta una definición para
la función \<EndBlock>.

%
En este caso, las épocas se definen como transacciones: cada bache de elementos define una época.

% %
% definition was given in this case, as the block does not
% delimit the epoch anymore, but the epoch is defined by all the elements
% belonging to the same Tendermint transaction.
% \textit{DeliverTx()} function
% shows the epoch number increase.

% To dicuss: if epochs are defined by batches, then epochs are generated by the same node.
% This is a new setchain property and may be undesirable. 
\subsection{Tercera implementación: HashChain}\label{subsec:hashchain}
%
Hashchain se alínea con el concepto introducido en Compresschain; sin embargo, usa
funciones hash en lugar de compresión en Brotli.

%Hashchain follows a similar idea introduced in Compresschain but employing hash
%functions instead of Brotli compression.
%
Mientras que el poder de compresión de funciones hash puede ser enorme, dado que las funciones
mapean datos de longitud arbitraria a valores de tamaño fijo, los hashes son irreversibles. Esto
significa que un método no trivial para recuperar el bache original de elementos debe proveerse.

%
La implementación de Hashcain involucra dos aspectos: una blockchain de Tendermint compuesta por hashes,
y una estrategia distribuída para invertir hashes y obtener los baches originales.
%
% We shouldn't mention "consolidated hashes" before explaining it:
%Therefore, we now have to maintain an inverse function for the consolidated
%hashes.

A menudo en esta sección nos tomaremos la libertad de utilizar la expresión \textit{elementos en un hash H}
para referirnos a aquellos elementos pertenecientes al bache $B$, tal que $Hash(B) = H$.

En lugar de usar el \textit{collector} de Compresschain (ver Algoritmo ~\ref{alg:collector-brotli}),
ahora utilizamos un \textit{hash collector}, que construye un bache de elementos para luego hashearlo
antes de introducirlo a la red de Tendermint.
%
Los baches hasheados son difundidos como transacciones y compartidos a través de toda la red, de forma
análoga al enfoque empleado para los baches comprimidos en Compresschain.

\subsubsection{Algoritmo distribuído para la inversión de hashes}

Como ya se mencionón, el \textit{hash collector} adopta un concepto similar al \textit{compression collector}
de Compresschain. Sin embargo, la definición de la ABCI para Hashchain es considerablemente más compleja.
%
En este escenario, tanto \<CheckTx> como \<DeliverTx> reciben hashes como transacciones.
%
Una máquina corriendo la \setchain no puede traducir inmediatamente hashes para obtener su bache de elementos
original, debido a la naturaleza irreversible de un hash.
%
La ausencia del bache original de elementos hace que \<CheckTx> sea incapaz de verificar los elementos
en la transacción, y que \<DeliverTx> no pueda añadir elementos a la \setchain.
%

En este punto, nuestro algoritmo distribuído para la inversión de hashes entra en juego.
%

La idea principal es comunicarnos con un nodo de Tendermint que conoce el hash (inicialmente, solo su creador).
%
Para distribuír la información sobre quiénes conocen los datos de un hash, las transacciones contienen
no solo el hash del bache, pero además una firma.
%
Las firmas que acompañan los hashes indican que un validador específico de Tendermint
(quien firma el hash) afirma conocer el hash y, por lo tanto, si es un nodo correcto,
tiene el bache original de elmentos.
%
De esta forma, las transacciones se representan con una tupla $(h, s)$, donde $h$ denota
el valor del hash y $s$ representa la firma obtenida al firmar $h$ con la clave privada
del nodo que conoce el hash.
%
Gracias a la firma es posible comunicarse con el nodo que afirma conocer los datos, y obtener
el bache original (si el nodo se comporto apropiadamente).
%
El proceso de petición de hashes se corre de forma asíncrona para evitar potenciales
retrasos.

%
Después de dejar el colector, se espera que los hashes sean chequeados contra \<CheckTx>
para o bien ser añadidos a la mempool o bien ser descartados.

%
Para determinar la validez de un hash se necesita chequear los elementos en él.

%
Similar a Compresschai, los hashes son considerados válidos si al menos un elemento
en el hash es válido.
%
Para un nodo dado, en el punto en que \<CheckTx> corre, no podemos asegurar que el
bache original de elementos sea conocido.

%
Hashchain es optimista en el sentido de que, ante la imposibilidad de correr el chequeo
de las transacciones, debido a la ausencia del bache original, \<CheckTx> considera a los
hashes como transacciones válidas con la esperanza de que sus baches originales sean enviados
y conocidos más tarde. 

%
La naturaleza optimista de Hashchain tiene consecuencia notables.
%
Como el comportamiento por defecto de  \<CheckTx> es retornar \texttt{True},
se pueden tener transacciones en la blockchain sin conocer los elementos de éstas
(solo conociendo los hashes).

%
Aun más, una transacción puede terminar siendo parte de la blockchain sin que nadie
la haya chequeado previamente, pero pasando el chequeo por el comportamiento optimista.

%
De hecho, este es probablemente el caso para la primera vez que un nuevo hash aparece
en la blockchain (fue consensuado sin que los nodos hayan chequeado realmente los elementos
del bache.)

%

%Therefore, we need a way to extract the elements inside the transactions and
%provide the user a uniform view, that of a Setchain.
Por lo tanto, necesitamos definir un criterio para determinar cuándo es seguro
que los elementos en un hash que está en la blockchain sean parte de la \setchain.

% the HashChain living in
% Tendermint, and the \setchain we want to build.
%
Para lograr eso, se define un número natural \texttt{SIGNATURES\_PER\_HASH} que establece
el número de firmas que un hash tiene que tener para que los elementos del bache asociado a él
sean considerados elementos a añadir a la \setchain.

%
Estamos únicamente interesados en hashes firmados por al menos \texttt{SIGNATURES\_PER\_HASH}
nodos, y los llamamos \textit{hashes consolidados}.

\texttt{SIGNATURES\_PER\_HASH} es definido de una manera tal que se garantiza que si un hash
consolidó entonces al menos un nodo correcto conoce el bache original del cual proviene.

%
Los elementos de hashes consolidados son los candidatos a pertenecer a la \setchain.

%Following the same criteria as in Compresschain, we consider a transaction to
%be valid if we can get the data and validate at least one of its elements.
%
% With this in mind, whenever the ABCI gets the revert of a hash, it runs the
% validation against it, and
%Moreover, if at least one element in the batch is valid, the node verifying the
Cuando un nodo pregunta por la inversión de un hash, si al menos un elemento en el bache
es válido, el nodo firma el hash (con sus propia clave privada), y difunde el hash junto
con su propia firma.

%
Al difundir el hash y su firma, el nodo anuncia a la red que conoce el bache detrás de ese hash.
%
De esta forma, los baches válidos eventualmente consolidarán, significando que sus elementos
serán añadidos a la \setchain.

Para que esto funcione, se necesita mantener un registro de cuántas firmas tiene un hash,
así como también un mapeo de hashes a baches.
%
Durante la ejecución de \<DeliverTx> se chequea la validez de la firma.
%
Si la firma es válida y nueva para el hash en cuestión, se incrementa el contador de
\texttt{firmas por hash}.
%
Además, cada vez que un hash es invertido, se chequea la correctitud del bache original
(es decir, $hash = Hash(originalBatch)$). En caso de éxito, el mapeo de hash a baches
es actualiado con el nuevo descubrimiento.

%The first time a hash is passed around, other nodes would see the new hash and
%try to get the data from other servers.
%
%The first one claiming to have the data is the creator of the transaction.


%When a \<get> arrives, we need to get the elements out of the consolidated
%hashes.
% it is necessary to ask for the batch
% corresponding to the hash in the transaction.
%



% Something we discussed with Marga: when the collector creates a hash h and signs it, and broadcast (h, s) every call to CheckTx(h, s) will be true, as no one is expected to have the reverse of h the first time they see it. Because of that, (h, s) in the hashchain doesn't mean that there is at least one good valid element in the h. h could be full of garbage
% A client could contact every collector node with the same elements, and every collector would broadcast (h, sn), with n being the n-collector. This could cause that hash h consolidates, without anyone really having checking elements in h. Is that bad? not too bad, only an empty epoch would occur. Possible fixes: collector hashes elements + pubkey, chain of signatures

\subsubsection{Consolidación de épocas}\label{subsubsec:consolidation}

En esta implementación, las épocas se definen por todos los elementos en un hash, similar
a la implementación de Compresschain.

%
En otras palabras, los elementos que provienen del mismo hash consolidado pertenecen a la
misma época.

%
%Now we have to be more careful when adding elements to the setchain, elements
%may appear several times depending on how nodes form batches and
%hashes. \marga{esto no puede pasar tambien en compresschain? un
%  elemento no puede aparecer en varios batches?}
%
% However, what epoch number is that? We need to be more specific
% to define this.

%

En este trabajo se presentan dos alternativas para asignar una época a un hash consolidado.

%
La primera se llama \textit{Consolidación de época actual} (CEC), que significa que 
una vez que un hash consolida, todos sus elementos subyacentes son añadidos a la época actual
(es decir, a la época en el cual la firma número \texttt{SIGNATURES\_PER\_HASH} es vista).
%
La segunda estrategia, \textit{Consolidación de época de primera vista} (FSEC) asigna la época
de acuerdo a cuándo el hash fue visto por privera vez. La asignación de época se lleva
a cabo una vez que el hash consolidó. 

%
Las transacciones (hashes en este caso) en los bloques de Tendermint están totalmente ordenadas,
por lo tanto ambas estrategias pueden determinar cuál hash ocurrió o consolidó primero, y
todos los nodos correctos estarán de acuerdo en eso.

%

En la Figura~\ref{fig:consolidation_epoch} se muestra un ejemplo de estas dos estrategias para asignar
un número de época a un hash que consolidó cuando \texttt{SIGNATURES\_PER\_HASH} es 3.

%
El hash $j$ es el primer hash en el bloque $m$, y el hash $k$ es el hash que primero consolida
(es decir, el primero en obtener su tercera firma).

%
Por un lado, la estrategia de consolidación de época actual asigna la época tan pronto como
el hash consolida, estampando los elementos en el hash $k$ con época $a$ primero, y luego
a los elementos en el hash $j$ con la época $a+1$.

%
Por el otro lado, la consolidación de época de primera vista no asigna la época al hash $k$
apenas éste consolida, porque el hash $j$ fue visto por primera vez antes que $k$.
%
Dado que el hash $j$ consolida justo después que el hash $k$, los elementos del hash $j$ son
estampados
con la época $a$, y los elementos del hash $k$ son estampados con la época $a+1$. 


\begin{figure}
  \centering
  \includegraphics[scale=0.5]{figures/consolidation_epoch.pdf}
  \caption{Consolidation epoch strategies}
  \label{fig:consolidation_epoch}
\end{figure}

First Seen Epoch Consolidation variant grants hashes a grace period in which
they can be either consolidated or rejected.
%
% The grace period is necessary, let
% us briefly examine why.
Assuming no grace period at all, if a hash $j$ occurs for
first time before hash $k$, once consolidated, elements from hash $j$ would be
stamped with epoch $E$, while elements from hash $k$ would be stamped with epoch
$F$ \textgreater \ $E$.
%
Hence, let $j$ be a hash first seen at a given moment such
that, once consolidated, it would be assigned the epoch $E$.
%
If hash $j$ never achieves the \texttt{SIGNATURES\_PER\_HASH} signatures to
consolidate, a newer hash $k$ (a hash first seen after $j$) would not be able to
consolidate, as its underlying elements could not be stamped with an epoch $F$
\textgreater \ $E$, if epoch $E$ was not defined yet.
%
In Figure~\ref{fig:grace_period}, we show an example of this.
%
We conclude that a grace period is necessary to guarantee the successful evolution of
the hashchain, as hashes $k$ and $l$ (and even $o$ and $q$) are not able to
consolidate until $j$ consolidates or gets rejected.


It is worth noting that the crucial aspect to consolidation in FSEC lies in the
occurrence of all \texttt{SIGNATURES\_PER\_HASH} signatures within a window
equivalent to the duration of the grace period.
%
Hashes that are initially rejected can consolidate in the future as long as
they reach the \texttt{SIGNATURES\_PER\_HASH} signatures within the grace period.
%
Hashes achieving the \texttt{SIGNATURES\_PER\_HASH}-th signature after
the grace period will not undergo consolidation in the current round;
however, they can do it in the future.

\begin{figure}
  \centering
  \includegraphics[scale=0.5]{figures/grace_period.pdf}
  \caption{Scenario requiring grace period under FSEC.}
  \label{fig:grace_period}
\end{figure}

%\subsubsection{Elements Membership Proof}
% Do not use this because we want a proof that specific elements belong to a specific epoch.
%Client processes do not know if they are contacting a Byzantine or correct process. The general idea of a client protocol that wants to ensure that an element is going to be added to the \setchain is to interact with enough servers to guarantee that some are correct. To guarantee contacting at least one correct server, the client needs to send f + 1 messages. However, each element added to the \setchain comes from a consolidated hash. That means that we already have \textbf{SIGNATURES\_PER\_HASH} validator's signatures for that hash. Those signatures may act as a proof for the batch of elements that really belongs to the \setchain. If that proof is added to the epoch as an extra element, a client sending an element, waiting for a while, and then requesting a Get to only one server (hoping it is correct server) may be sure that its element belongs to the \setchain because the epoch comes along a proof of their elements. 

\subsubsection{Front-running attacks}
In the context of blockchains, a front-running attack refers to a situation where
a malicious actor exploits advanced knowledge of pending transactions to gain an
unfair advantage. Because pending transactions are public, a malicious user can
observe a victim's incoming transaction, craft a new transaction and then find a way
to place it before that of the victim. On the Ethereum network, this \textquotedblleft
way\textquotedblright to place a transaction before another, is usually related
to payments: either by paying higher transaction fees or by making side payments
directly to validators.

What kind of front-running attacks can happen in the abastraction level of Hashchain?
Let's suppose a validator $v$ receives a transaction $(h_0, s_0)$, where $h_0$ is a hash,
and $s_0$ a signaure for that hash (the first one). A \textit{speculative} validator can
sign itself the
transaction and broadcast it (the expected behaviour), or
ignore it (a missbehaviour). If the validator signs and broadcasts the transaction,
then it is collaborating for the hash to be consolidated (and therefore for the elements
from the hash to be added).
Otherwise, it won't contribute, potentially causing a delay or even preventing the
consolidation of the hash.

What is the difference between both epoch consolidation strategies?
In FSEC strategy, if the transaction does not get the \texttt{SIGNATURES\_PER\_HASH}
signatures within the grace period, the hash won't consolidate on that round (but it could
do it in the future).
In CEC strategy, the hash won't be consoildated until getting
\texttt{SIGNATURES\_PER\_HASH} signatures, without having any grace period for it.

At this juncture, strategies appear to lack fundamental differences. However, the
intriguing aspect becomes apparent in the alternative scenario: when transactions are
ultimately committed.

Let's suppose that $v$ sees transaction $t_0 = (h_0, s_0)$ and wants to perform a front-running
attack. In order to do that, it ignores the transaction, but broadcasts its own signed
transaction $t_1 = (h_1, s_0)$, hoping that $t_1$ ends up stamped with an earilier epoch than $t_0$.

Under FSEC behaviour, $h_0$ was first seen, so if it gets the \texttt{SIGNATURES\_PER\_HASH}
signatures within the grace period, it will consolidate, and elements will be stamped surely with an earlier
epoch than $t_1$.
Note that this is entirely independent of the number of signatures that $h_1$ achieves, and the
speed at which it does so. $h_1$ could even consolidate (reach the \texttt{SIGNATURES\_PER\_HASH}-th
siganture) before than $h_0$.

On the other hand, under CEC behaviour the situation is basically a race between
$h_0$ and $h_1$: the one that gets the \texttt{SIGNATURES\_PER\_HASH} signatures first will
be the first one to consolidate, and therefore elements will be stamped with an eairlier epoch.

It is noted that FSEC strategy takes into account
not only the
moment in which hashes get consolidated, but also \textit{when} transactions were first seen.
This property gives an inherent advantage to the transactions that were first seen.
Upon initial examination, we might consider this characteristic as a valuable aspect in
mitigating front-running attacks, as transactions observed first are likely the legit
and original ones.
%At girst glance, we could think that this property is an interesting point to go against
%front-running attacks, as first-seen transactions are probably the legit original transactions.

However, FSEC strategy comes with some non-trivial downsides.
As the epoch is determined by the moment in which the hash was seen for the first time,
the strategy somehow \textit{books} the epoch number for that specific transaction.
If $v$ wants one hash $h_0$ to be consolidated only if can do it before some other 
hash $h_1$ (and does not need to know elements from $h_1$ in advance),
$v$ could do the following. First, it broadcasts the transaction so
everyone \textit{books}
the epoch number for it.
Then, $v$ should not reverse the hash $h_0$ to anyone, because it has to wait until hash
$h_1$ shows up and gets enough signatures.
Once that happens, and it is sure that hash
$h_1$ will get consolidated, $v$ start reversing the hash $h_0$ to all its pairs, hoping the
hash to achieve \texttt{SIGNATURES\_PER\_HASH} signatures in the grace period.
If it is successful, then $v$ would accomplish its goal:
elements from hash $h_0$ are stamped with an earlier epoch than elements from
hash $h_1$.

This situation is paticular interesting because validator $v$ is able to make something
happen in the past (elementrs from hash $h_0$ stamped with epoch $e$) having information
from the future (elements from hash $h_1$ stamped with epoch $e+n$).

Notice that trying to do something similar under CEC strategy would be impossible, as once
hash $h_1$ is consolidated for sure, then its elements are assigned an earlier epoch than any
other hash not-consolidated yet.

Let's go back to this downside with an example. Suppose there is a simple betting game where bets and
final results are recorded using Hashchain. The game is straightforward: users can
bet on A or B. Around a specific time, it is known that the winning result (either A or B)
will be publicly disclosed, and everyone who bet on the winner will be paid.

If $v$ is a validator who wants to win this bet by cheating, they could bet on both
A and B just before the time they know the company will publish the winning result.
As $v$ submits both transactions (betting on A and betting on B) before the transaction
with the result appears, all validators will reserve an epoch number lower than that
of the result. After this, $v$ does not reverse the hash associated with these transactions
until they are sure of the winning result and know that this result will be posted on
the Hashchain (the respective hash reachs enough signatures).
Once they are certain, they only reverse the hash containing the bet for
the winning value. If they obtain the necessary signatures during the grace period,
their transaction would be stamped with an epoch number lower than that of the result,
and thus, $v$ would win the bet by cheating.

\input{algorithms/alg-api-hash}

\subsubsection{Implementation details}\label{subsubsec:details}

We do not define a new collector for Hashcahin since it is similar to the one
define for Compresschain where the only difference is the use of hash functions.
%
% No collector piece for Hashchain appears as it is similar to the already
% presented collector for Brotli, employing hash functions instead of Brotli
% compression.
We define the Setchain API in Algorithm ~\ref{alg:api-hashchain}.
% shows how a new collector is
% used now in order to add elements to the \setchain.

Finally, as regards the ABCI, we show a possible implementation for Hashchain
with Current Epoch Consolidation strategy in Algorithm~\ref{alg:abci-hash1} and ~\ref{alg:abci-hash2}. It is
noteworthy that within the algorithm, the function \<Query> initiates the construction
of \<history>, in addition to broadcasting epoch proofs. Although this approach is employed
for clarity, a node that receives infrequent query requests may experiment delays in
generating the epoch proofs. As a result, the process of constructing \<history> and
epoch proofs can be scheduled periodically, independent of query requests.

\input{algorithms/alg-abci-hash}
%As mentioned above, Hashchain First Seen Consolidation version uses an idea of grace period in which the hashes are either consolidated or discarded. In this case, we will define the grace period in terms of number of blocks, meaning that if a hash has been seen for the first time in block $B$, and the grace period is $P$ blocks, then on block $B$ + $P$ we will determine if the hash is consolidated (hence, their elements are added to the \setchain), or is discarded. To implement this, we will keep a fixed capacity queue (with capacity $P + 1$), in which the \textit{i}-th element has a list of hashes seen for first time in block $current block - (P - i)$. Notice that the first element of the queue has the list of hashes that were seen for first time in block $current block - P$, meaning that those hashes will be decided in the current block. The last element of the queue has the list of hashes first seen at the current block. Algorithm ~\ref{alg:abci-hash-first-seen} illustrates this behavior.

%\input{algorithms/alg-abci-hash-first-seen}

%%% Local Variables:
%%% TeX-master: "article.tex"
%%% TeX-PDF-mode: t
%%% End:
