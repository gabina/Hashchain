% % Alg 2
% \begin{figure}[h]
% 	\label{DPO-alg-basb}
% 	\begin{algorithm}[H]
% 		\caption{\small Server $i$ implementation with Byzantine Atomic Set Broadcast (Red Belly primitives). Assuming non Byzantine client.}
% 		\begin{algorithmic}[1]
% 			\State  \textbf{Init:} $epoch \leftarrow 0$
% 			\State  \textbf{Init:} $history \leftarrow \emptyset$
% 			\State  \textbf{Init:} $current \leftarrow DSO(\emptyset)$
% 			\Function{DPO.Get}{~}
% 			\State \textbf{return} $current.Get() \cup history $
% 			\EndFunction
% 			\Function{DPO.Add}{$e$}
%                         \State \textbf{return} $current.Add(e)$
% 			\EndFunction
% 			\Function{DPO.GetEpoch}{~} \Commetn{Client needs to know the current epoch}
%                         \State \textbf{return} $\textit{epoch}$
% 			\EndFunction
% 			\Function{DPO.EpochInc}{$h$} \Comment{Client request is assumed valid}
% 			\State \textbf{assert} $h == epoch + 1$
% 			\State BRB.Broadcast($h$)
% 			\EndFunction
% 			\Upon{BRB.Deliver($h$) \text{ and } $h==epoch + 1$}
% 			\State $proposal \leftarrow current.Get() \setminus history$
% 			\State BSC.Propose($h, proposal, i$)
% 			\EndUpon
% 			\Upon{BSC.SetDeliver($h, proposals$)} \label{DPO-alg-delivery}
% 			\State \textbf{assert} $h == epoch + 1$
% 			%\State \textbf{wait} $2f+1$ BAB.Deliver of the same epoch $h$
% 			\State $P \leftarrow \{e:e \in $ at least $f+1$ different $proposal_j$ for the same $h\}$
% 			\ForAll{e in P}
% 			\State $history \leftarrow history \cup \{\langle h, e \rangle\}$
% 			\EndFor
% 			\State $epoch \leftarrow epoch + 1$
% 			\EndUpon
% 		\end{algorithmic}
% 	\end{algorithm}\vspace{-2em}
% \end{figure}




% Alg 2
% \begin{figure}[h]\label{DPO-alg-basb}
%   \begin{algorithm}[H]
%     \caption{\small Server $i$ implementation with Byzantine Atomic Set Broadcast (Red Belly primitives). Assuming non Byzantine client.}
%     \begin{algorithmic}[1]
%       \setcounter{ALG@line}{10} % hardcoded :(
%       % \State  \textbf{Init:} $\EPOCH \leftarrow 0$
%       % \State  \textbf{Init:} $\HISTORY \leftarrow \emptyset$
%       % \State  \textbf{Init:} $\THESET \leftarrow DSO(\emptyset)$
%       % \Function{DPO.\(\<Get>\)}{~}
%       % \State \textbf{return} $(\THESET.Get(), \HISTORY)$
%       % \EndFunction
%       % \Function{DPO.Add}{$e$}
%       % \State \textbf{assert} $valid(e)$
%       % \State \textbf{return} $\THESET.Add(e)$
%       % \EndFunction
%       % \Function{DPO.GetEpoch}{~} \Comment{Client needs to know the current epoch}
%       % \State \textbf{return} $\EPOCH$
%       % \EndFunction
%       \Function{DPO.EpochInc}{$h$}\label{alg2:epochinc}
%         \State \textbf{assert} $h==\EPOCH +1$
%         \State BRB.Broadcast($h$)
%         \State \Return \(ack\) % \textbf{return}
%       \EndFunction
%       \Upon{BRB.Deliver($h$) \text{ and } $h<\EPOCH+1$}
%         \State \textbf{drop}
%       \EndUpon
%       \Upon{BRB.Deliver($h$) \text{ and } $h==\EPOCH+1$}
%         \State \textbf{assert} $prop[h]==null$
%         \State $prop[h] \leftarrow \THESET.Get() \setminus \bigcup_{\langle h,E \rangle \in \HISTORY}{E}$
%         % \{ e : e \in E \wedge \langle h,E \rangle \in \HISTORY \}$
%         \State SBC[$h$].Propose($prop[h]$)
%       \EndUpon
%       %
%       % alternatitve: upon(BSC[epoch+1].SetDeliver(propset)
%       %
%       \Upon{SBC[h].SetDeliver($propset$) \text{ and } $h==\EPOCH+1$} %\Comment{Guaranteed to be called in increasing $h$}
%         \State $E \leftarrow \{e:e \in $ at least $f+1$ different $propset[j]\}$
%         % \ForAll{$e \in P$ \text{ and } $e\notin{}\HISTORY$}
%         % \Comment{claim: $e\notin{}\HISTORY$ is guaranteed}
%         \State $\HISTORY \leftarrow \HISTORY \cup \{\langle h, E \rangle\}$
%         % \EndFor
%         % \State{$\EPOCH \leftarrow h$} \Comment{same as $\EPOCH \leftarrow{}\EPOCH+1}$
%         \State{$\EPOCH \leftarrow \EPOCH+1$} % \Comment{same as $\EPOCH \leftarrow{}\EPOCH+1}$
%         \EndUpon
%       \end{algorithmic}
%     \end{algorithm}\vspace{-2em}
% \end{figure}

%%% Boxes
\begin{figure}[t!]
%  \begin{tikzpicture}
%    \node (tmp) at (0,0){%
      \begin{adjustbox}{minipage=[t]{\columnwidth}}
  \begin{algorithm}[H]
    \caption{\small Server $i$ implementation using DSO, and reliably
      broadcast (BRB) and set Byzantine consensus (SBC).
       %(Red Belly primitives). 
       }
    \label{DPO-alg-basb}
    \small
    \begin{algorithmic}[1]
      \setcounter{ALG@line}{10} % hardcoded :(
      % \State  \textbf{Init:} $\EPOCH \leftarrow 0$
      % \State  \textbf{Init:} $\HISTORY \leftarrow \emptyset$
      % \State  \textbf{Init:} $\THESET \leftarrow DSO(\emptyset)$
      % \Function{DPO.\(\<Get>\)}{~}
      % \State \textbf{return} $(\THESET.Get(), \HISTORY)$
      % \EndFunction
      % \Function{DPO.Add}{$e$}
      % \State \textbf{assert} $valid(e)$
      % \State \textbf{return} $\THESET.Add(e)$
      % \EndFunction
      % \Function{DPO.GetEpoch}{~} \Comment{Client needs to know the current epoch}
      % \State \textbf{return} $\EPOCH$
      % \EndFunction
      \State \ldots     \Comment{$\<Get>$ and $\<Add>$ as in Alg.~\ref{DPO-alg1}}

      \Function{\<EpochInc>}{$h$}\label{alg2:epochinc}
%        \tikz{\node(tmp1){};}
        \State \<assert> $h==\EPOCH +1$
        \State \<BRB>.\<Broadcast>(\<mepochinc>($h$))\label{alg2:brb-epochinc}
%        \State \<return> \<ack>
      \EndFunction
      \Upon{\<BRB>.\<Deliver>(\<mepochinc>($h$)) and $h<\EPOCH+1$}
        \State \<drop>
      \EndUpon
      \Upon{\<BRB>.\<Deliver>($h$) and $h==\EPOCH+1$}
        \State \<assert> $prop[h]==null$
        \State $prop[h] \leftarrow \THESET.\text{\<Get>}() \setminus 
        \bigcup_{k=1}^{\<epoch>} \<history>(k)$\label{DPO-alg2-dsoget}
        %\bigcup_{\langle h,E \rangle \in \HISTORY}{E}$\label{DPO-alg2-dsoget}
        % \{ e : e \in E \wedge \langle h,E \rangle \in \HISTORY \}$
        \State \<SBC>[$h$].\<Propose>($prop[h]$)
      \EndUpon
      %
      % alternatitve: upon(BSC[epoch+1].SetDeliver(propset)
      %
      \Upon{\<SBC>[$h$].\<SetDeliver>($propset$)  and  $h==\EPOCH+1$} %\Comment{Guaranteed to be called in increasing $h$}
        \State $E \leftarrow \{e:e \in $ at least $f+1$ different $propset[j]\}$
        % \ForAll{$e \in P$ \text{ and } $e\notin{}\HISTORY$}
        % \Comment{claim: $e\notin{}\HISTORY$ is guaranteed}
        \State $\HISTORY \leftarrow \HISTORY \cup \{\langle h, E \rangle\}$
        % \EndFor
        % \State{$\EPOCH \leftarrow h$} \Comment{same as $\EPOCH \leftarrow{}\EPOCH+1}$
        \State{$\EPOCH \leftarrow \EPOCH+1$} % \Comment{same as $\EPOCH \leftarrow{}\EPOCH+1}$
        \tikz{\node(tmp2){};}
        \EndUpon
      \end{algorithmic}
    \end{algorithm}
        \end{adjustbox}
%    };
    %Boxes
%    \path(tmp1-|tmp.west) -- +(1.2ex,0.5em)node(tmpa){};
%    \path(tmp2-|tmp.east) -- +(-0.75ex,-1.75em)node(tmpb){};
%    \draw[red, thick](tmpa) rectangle (tmpb);
%  \end{tikzpicture}
\end{figure}
