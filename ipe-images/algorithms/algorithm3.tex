%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Alg 3
\begin{figure}[t!]
	\begin{algorithm}[H]
          \caption{\small Server implementation using a local set,
            Byzantine reliable broadcast (BRB) and set Byzantine
            consensus (SBC).
            %(Red Belly primitives).
            }~\label{DPO-alg-basb3}
          \small
		\begin{algorithmic}[1]
			\State  \textbf{Init:} $\EPOCH \leftarrow 0,$
			\hspace{2em} $\HISTORY \leftarrow \emptyset$
			% \State  \textbf{Init:} $\HISTORY \leftarrow \emptyset$
			\State  \textbf{Init:} $\THESET \leftarrow \emptyset$\label{alg3:theset}
			\Function{\<Get>}{~}
			        \State \<return> $(\THESET, \HISTORY,\<epoch>)$\label{alg3:get}
			\EndFunction
			\Function{\<Add>}{$e$}
                                \State \<assert> $valid(e)$ and $e \notin \THESET$
                                \State \<BRB>.\<Broadcast>(\<madd>(e)) \label{alg3:brb-broadcast}
%				\State \<return> \<ack> %\textbf{return ACK}
                                \EndFunction
			\Upon{\<BRB>.\<Deliver>(\<madd>\((e)\))}
                                \State \<assert> $valid(e)$
			        \State $\THESET \leftarrow \THESET \cup \{e\}$ \label{add_theset_BRBDeliver}
			\EndUpon
%			\Function{\<GetEpoch>}{~}%\Comment{Client needs to know the current epoch}
%                                \State \<return> $\EPOCH$
%			\EndFunction
			\Function{\<EpochInc>}{$h$}
                                \State \<assert> $h==\EPOCH +1$
			        \State \<BRB>.\<Broadcast>(\<mepochinc>($h$))
%				\State \<return> \<ack> % \textbf{return ACK}
                        \EndFunction
			\Upon{\<BRB>.\<Deliver>(\<mepochinc>($h$)) and $h<\EPOCH+1$}
                                \State \<drop>
                        \EndUpon
			\Upon{\<BRB>.\<Deliver>(\<mepochinc>($h$)) and $h==\EPOCH+1$}
                                \State \<assert> \(prop[h] == \emptyset\)
                                % \State $prop[h] \leftarrow \THESET \setminus \{ e : e \in E \wedge \langle h,E \rangle \in \HISTORY \}$
                                \State $prop[h] \leftarrow \THESET \setminus 
                                \bigcup_{k=1}^{\<epoch>} \<history>(k)$
                                %\bigcup_{\langle h,E \rangle \in \HISTORY}{E}$
                                % \{ e : e \in E \wedge \langle h,E \rangle \in \HISTORY \}$
                                \State \<SBC>[$h$].\<Propose>($prop[h]$)
			\EndUpon
			\Upon{\<SBC>[\(h\)].\<SetDeliver>($propset$) and  $h==\EPOCH+1$}
			        \State $E \leftarrow \{e : e \in propset[j], valid(e) \wedge e\notin \HISTORY\}$~\label{forall_e_SBCDeliver}
				    \State $\HISTORY \leftarrow \HISTORY \cup \{\langle h, E \rangle\}$~\label{add_history_SBCSetDeliver}
				    \State $\THESET \leftarrow \THESET \cup E$~\label{add_theset_SBCSetDeliver}
				    \State $\EPOCH \leftarrow \EPOCH+1$\label{set_epoch_SBCSetDeliver} %\Comment{same as $epoch\leftarrow{}\EPOCH+1$}
				    % \State{$\EPOCH \leftarrow h$} \label{set_epoch_SBCSetDeliver} \Comment{same as $epoch\leftarrow{}\EPOCH+1$}
			\EndUpon
		\end{algorithmic}
	\end{algorithm}\vspace{-2em}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Original algorithm
% Alg 3
% \begin{figure}[h]\label{DPO-alg-basb3}
% 	\begin{algorithm}[H]
% 		\caption{\small Server $i$ implementation with Byzantine Atomic Set Broadcast (Red Belly primitives). Assuming non Byzantine client.}
% 		\begin{algorithmic}[1]
% 			\State  \textbf{Init:} $\EPOCH \leftarrow 0$
% 			\State  \textbf{Init:} $\HISTORY \leftarrow \emptyset$
% 			\State  \textbf{Init:} $\THESET \leftarrow \emptyset$\label{alg3:theset}
% 			\Function{DPO.Get}{~}
% 			        \State \textbf{return} $(\THESET, \HISTORY)$
% 			\EndFunction
% 			\Function{DPO.Add}{$e$}
%                                 \State \textbf{assert} $e \notin \THESET$
%                                 \State \<BRB>.Broadcast(ADD(e))
% 				\State \Return \(ack\) %\textbf{return ACK}
%                         \EndFunction
% 			\Function{DPO.GetEpoch}{~}%\Comment{Client needs to know the current epoch}
%                                 \State \Return $\EPOCH$
% 			\EndFunction
% 			\Function{DPO.EpochInc}{$h$}
%                                 \State \textbf{assert} $h==\EPOCH +1$
% 			        \State \<BRB>.Broadcast($h$)
% 				\State \Return \(ack\) % \textbf{return ACK}
%                         \EndFunction
% 			\Upon{\<BRB>.Deliver(ADD(e))}
%                                 \State \textbf{assert} $valid(e)$
% 			        \State $\THESET \leftarrow \THESET \cup \{e\}$ \label{add_theset_BRBDeliver}
% 			\EndUpon
% 			\Upon{BRB.Deliver($h$) \text{ and } $h<\EPOCH+1$}
%                                 \State \text{drop}
%                         \EndUpon
% 			\Upon{BRB.Deliver($h$) \text{ and } $h==\EPOCH+1$}
%                                 \State \textbf{assert} $prop[h]==null$
%                                 % \State $prop[h] \leftarrow \THESET \setminus \{ e : e \in E \wedge \langle h,E \rangle \in \HISTORY \}$
%                                 \State $prop[h] \leftarrow \THESET \setminus \bigcup_{\langle h,E \rangle \in \HISTORY}{E}$
%                                 % \{ e : e \in E \wedge \langle h,E \rangle \in \HISTORY \}$
%                                 \State SBC[$h$].Propose($prop[h]$)
% 			\EndUpon
% 			\Upon{SBC[h].SetDeliver($propset$) \text{ and } $h==\EPOCH+1$}
% 			        \State $E \leftarrow \{e : e \in propset[j], valid(e) \wedge e\notin \HISTORY\}$ \label{forall_e_SBCDeliver}
% 				    \State $\HISTORY \leftarrow \HISTORY \cup \{\langle h, E \rangle\}$ \label{add_history_SBCSetDeliver}
% 				    \State $\THESET \leftarrow \THESET \cup E$ \label{add_theset_SBCSetDeliver}
% 				    \State $\EPOCH \leftarrow \EPOCH+1$\label{set_epoch_SBCSetDeliver} %\Comment{same as $epoch\leftarrow{}\EPOCH+1$}
% 				    % \State{$\EPOCH \leftarrow h$} \label{set_epoch_SBCSetDeliver} \Comment{same as $epoch\leftarrow{}\EPOCH+1$}
% 			\EndUpon
% 		\end{algorithmic}
% 	\end{algorithm}\vspace{-2em}
% \end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


% \begin{figure}[h]
% 	\label{DPO-wget1}
% 	\begin{algorithm}[H]
%                 \caption{\small Wrapper for function DPO.GET(). Elements are added to epochs individually.}
% 		\begin{algorithmic}[1]
% 			\Function{WGet}{~}
% 			\State \textbf{call } DPO.GET() in 3f+1 different servers. \Comment{add identifier.}
% 			\State \textbf{wait } responses $(\THESET_i, \HISTORY_i)$ from 2f+1 different servers.
% 			\State $stamped \leftarrow \{ \langle h,e \rangle : \langle h,e \rangle \text{ in at least f+1 different sets } \HISTORY_i\}$
% 			\State \textbf{return } $ (\{ e : e \text{ in at least f+1 different sets } \THESET_i\}, stamped)$ \Comment{remove elements from the\_set that are already stamped? We dont do it in alg3}
% 			\EndFunction
% 		\end{algorithmic}
% 	\end{algorithm}\vspace{-2em}
% \end{figure}


% \begin{figure}[h]
% 	\label{DPO-wget2}
% 	\begin{algorithm}[H]
%           \caption{\small Wrapper for function DPO.GET(). Epochs are added completely.}
%           \begin{algorithmic}[1]
% 			\Function{WGet}{~}
% 			\State \textbf{call } DPO.GET() in 3f+1 different servers. \Comment{add identifier.}
% 			\State \textbf{wait } responses $(\THESET_i, \HISTORY_i)$ from 2f+1 different servers.
% 			\State $\HISTORY^h_i \leftarrow \{ \langle h,e \rangle : \langle h,e\rangle \in history_i \}$
% 			\State $stamped_h \leftarrow$ \textbf{if} exists $s =  history^h_i$  for at least f+1 different servers \textbf{then} s \textbf{else} $\emptyset$
% 			\State $stamped \leftarrow \bigcup_h stamped_h$
% 			\State \textbf{return } $(\{ e : e \text{ in at least f+1 different sets } \THESET_i\}, stamped)$ \Comment{remove elements from the\_set that are already stamped? We dont do it in alg3}
% 			\EndFunction
% 		\end{algorithmic}
% 	\end{algorithm}\vspace{-2em}
% \end{figure}
