\section{Resumen y conclusión final}\label{sec:conclusion}
%
Las tecnologías blockchain están atravesando un problema de escalabilidad.
%
Comparado a otros sistemas basasdos en transacciones, las blockchains son simplemente
demasiado lentas.
%
Existen, por lo menos, dos formas posibles de resolver este problema: o bien
diseñando algoritmos de consenso más rápidos, o bien colocando soluciones por
encima de la blockchain.

%
Un ejemplo de lo primero es lo que se conoce como soluciones de \emph{Layer-2}
(capa 2),
donde se tiene una máquina de computación sobre la blockchain que consume menos
recursos que si se actuara directamente sobre ella.
%
Un ejemplo de lo segundo es \setchain.

\setchain presenta un algoritmo de consenso más rápido, basado en
\textit{set-consensus}\cite{redbelly},
que abandona el clásico orden total de las transacciones en las blockchains.
%
El orden parcial de \setchain establece que no es posible comparar los elementos
en una misma época.
%
Sin embargo, se puede decir que los elementos de una época ocurrieron antes o después
que los elementos de otra.
%
Esto es, \setchain propone un orden relativo, en donde los elementos
de distintas épocas se pueden relacionar, pero no es posible relacionar elementos
en la misma época.

Aunque \setchain es una idea inteligente, carecía al momento de una implementación
de mundo real.
%
Los autores de \setchain dieron una implementación a modo de prueba de concepto,
que les permitió observar que, en condiciones de laboratorio,
era más rápido que otros algoritmos de consenso.
%

% Implementing and verifying such claims are the goals of this work in progress.
La implementación de sistemas distribuídos es difícil, por lo que en este trabajo
se decidió utilizar una solución prefabricada: Tendermint.
Tendermint ofrece una implementación
de mundo real de una estructura basada en blockchain, presentando una separación clara
entre las primitivas de la blockchain y la interfaz definida por el usuario.


Se presentaron tres alternativas posibles para la implementación
de \setchain construidas sobre Tendermint. Dado que los algoritmos de \setchain
presentados en \cite{Capretto.2022.Setchain} emplean un algoritmo de
\textit{set-consensus}, 
no es posible replicar los mismos comportamientos.
Sin embargo, tomamos un enfoque ligeramente diferente,
intentando obtener tanto como se pueda de lo que Tendermint es capaz de ofrecer.
Cada alternativa presentada trata de acercarse a la implementación ideal de \setchain,
explotando la idea de que cada época es un conjunto de elementos.

%
La primera solución (ver Sección~\ref{sec:vanilla}) presenta una simple y
correcta pero ineficiente implementación de \setchain donde Tendermint solo mantiene
un conjunto de solo crecimiento.

%
La segunda solución (ver Sección~\ref{sec:compresschain}) mejora la alternativa anterior
usando un algoritmo de compresión: las transacciones de Tendermint ahora son conjuntos
de elementos (comprimidos).

%
Finalmente, la tercera solución (ver Sección~\ref{sec:hashchain}) va más allá de la
segunda alternativa y usa funciones hash para reducir la sobrecarga en la red.
Aunque reduzca el tráfico (haciendo consenso sobre transacciones pequeñas
y de tamaño fijo), el uso de funciones hash requiere una forma de
invertirlos para así obtener los elementos originales.
Para resovler esto, se diseñó
un algoritmo distribuído, tolerante a fallas bizantinas, que trabaja como un objeto
distribuído de resolución de hashes.
Estos dos aspectos funcionando juntos conforman una implementación de \setchain
de mundo real.

%
\hashchain es la solución más cercana a \setchain sin usar un algoritmo de set-consensus.
Dado que los nodos no conocen los elementos dentro de un hash \emph{a priori}, el
consenso consiste en elegir cuál época irá próxima.
%

% No entiendo a qué va esta idea:
%However, since in Tendermint we have a mempool and a gossip network, elements
%are gossiped around, and hashes have the biggest set of elements known to the
%node proposing the next epoch.

Los números provistos por la evaluación empírica son emocionantes, indicando que,
efectivamente, \hashchain permite un rendimiento de X veces lo que \vanilla, e Y veces
lo que \compresschain.
Estos resultados se presentan a favor de la hipótesis de que hacer consenso sobre
elementos agrupados de forma eficiente interpretados como unidad representa una
mejora en comparación con el consenso usual, hecho sobre elementos individuales. 

%%% Local Variables:
%%% TeX-master: "article.tex"
%%% TeX-PDF-mode: t
%%% End:
