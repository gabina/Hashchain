\section{Objetivo del capítulo}
En este capítulo se presentan las pruebas de correctitud de los algoritmos presentados para
\vanilla, \compresschain, y \hashchain en el capítulo~\ref{chapter:sol}.
Es decir, se prueba que dichos algoritmos satisfacen las propiedades deseadas para una
implementación de \setchain introducidas en~\ref{subsubsec:setchain-properties}.

\section{Propiedades de Tendermint}\label{sec:properties}
Dado que todas las soluciones presentadas en este trabajo son construidas sobre Tendermint,
para probar la correctitud de ellas, será necesario recapitular las propiedades que la
plataforma Tendermint garantiza.

El modelo de Tendermint considera un sistema de procesos que se comunican mediante el intercambio de
mensajes.
Los procesos pueden ser correctos o defectuosos, donde un proceso defectuoso se comporta de maneras
arbitrarias. Es decir, se consideran procesos bizantinos.

Se asume que cada proceso tiene una cantidad determinada de \textit{poder de voto} (el poder de
voto de un proceso puede ser 0).
%
En el contexto de Tendermint, denotamos con \textit{n} el poder de voto total de los procesos
en el sistema, y asumimos una cota superior \textit{f} en el poder de voto total proveniente de
los procesos bizantinos.
%
El algoritmo de consenso de Tendermint asume que $n > 3f$, es decir, requiere que el poder de voto
en manos de procesos bizantinos sea menor a 1/3 del poder de voto total.
Por simplicidad, en ocasiones se considera $n = 3f + 1$.
% We consider a system of processes that communicate by exchanging messages. Processes can be correct or
% faulty, where a faulty process can behave in an arbitrary way, i.e., we consider Byzantine faults. We assume
% that each process has some amount of voting power (voting power of a process can be 0). Processes in our
% model are not part of a single administrative domain; therefore we cannot enforce a direct network connectivity
% between all processes. Instead, we assume that each process is connected to a subset of processes called peers,
% such that there is an indirect communication channel between all correct processes. Communication between
% processes is established using a gossip protocol

\newcounter{prop:tendermint}
\setcounter{prop:tendermint}{\value{property}}

\begin{property}[Tendermint-Agreement]\label{tendermint:agreement}
  Dos procesos correctos nunca deciden valores distintos.
\end{property}

\begin{property}[Tendermint-Termination]\label{tendermint:termination}
    Todos los procesos correctos deciden eventualmente un valor.
\end{property}

Las propiedades ~\ref{tendermint:agreement} y ~\ref{tendermint:termination}
son demostradas en ~\cite{Buchman.2018.Tendermint}.
\section{Prueba de correctitud para \vanilla}\label{sec:proof-vanilla}
\begin{itemize}
  \item La \textit{Propiedad 1 (Consistent Sets)} de \setchain establece que las épocas solo contienen
  elementos que provienen del conjunto de solo crecimiento. Esto es trivialmente correcto debido a que la
  construcción de $\THESET$ y de $\HISTORY$ se hacen a partir de los mismos elementos (ver definición de
  \<DeliverTx> en el Algoritmo~\ref{alg:abci-vanilla}).
  \item La \textit{Propiedad 2 (Add-Get-Local)} declara que todo elemento añadido a un
  servidor correcto $v$ es eventualmente retornado en todas las llamadas futuras a $v$.\<get>.
  \item La \textit{Propiedad 3 (Get-Global)} establece que los elementos presentes en un servidor correcto
  son propagados a todos los servidores correctos. Esto se puede probar mediante la propiedad de Tendermint \ref{tendermint:agreement},
  ya que si un servidor correcto devuelve un elemento $e$ como parte the $\THESET$, entonces necesariamente en algún
  momento recibió una petición \<DeliverTx> para la transacción asociada a dicho elemento $e$.
  Luego por la propiedad de \textit{Tendermint-Agreement},
  todos los nodos correctos decidirán el mismo elemento $e$ (como una transacción), y recibirán la petición \<DeliverTx> para el mismo,
  añadiéndolo a su conjunto $\THESET$.

\end{itemize}

\section{Prueba de correctitud para \compresschain}\label{sec:proof-compresschain}
\begin{itemize}
  \item La \textit{Propiedad 1 (Consistent Sets)} de \setchain establece que las épocas solo contienen
  elementos que provienen del conjunto de solo crecimiento. Esto es trivialmente correcto debido a que la
  construcción de $\THESET$ y de $\HISTORY$ se hacen a partir de los mismos elementos (ver definición de
  \<newEpoch> y \<DeliverTx> en el Algoritmo~\ref{alg:abci-brotli}).
\end{itemize}
\section{Prueba de correctitud para \hashchain}\label{sec:proof-hashchain}
\begin{itemize}
  \item La \textit{Propiedad 1 (Consistent Sets)} de \setchain establece que las épocas solo contienen
  elementos que provienen del conjunto de solo crecimiento. Esto es trivialmente correcto debido a que la
  construcción de $\THESET$ y de $\HISTORY$ se hacen a partir de los mismos elementos (ver definición de
  \<reverse> y \<Query> en el Algoritmo~\ref{alg:abci-hash1} y ~\ref{alg:abci-hash2}).
\end{itemize}

\subsection{Otras cosas}
\begin{property}[Safety]\label{tendermint:safety}
  Si hay menos de 1/3 del poder de voto en manos bizantinas y al menos un validador correcto
  decide el bloque $B$, entonces ningún validador correcto decidirá un bloque distinto a $B$.
\end{property}

\begin{property}[Liveness]\label{tendermint:liveness}
  Si hay menos de 1/3 de poder de voto en manos bizantinas, luego el procolo de Tendermint
  no se bloquea (es decir, no hay \textit{deadlock}).
\end{property}

En el contexto de Tendermint, denotamos con \textit{n} el poder de voto total de los procesos
en el sistema, y asumimos una cota superior \textit{f} en el poder de voto total proveniente de
los procesos bizantinos.
%
El algoritmo de consenso de Tendermint asume que $n > 3f$, es decir, requiere que el poder de voto
en manos de procesos bizantinos sea menor a 1/3 del poder de voto total.
Por simplicidad, en ocasiones se considera $n = 3f + 1$.

Tendermint resuelve el problema de la replicación de máquinas de estados ejecutando instancias de
consenso secuencialmente para acordar cada bloque de transacciones que serán luego ejecutadas por el
servicio siendo replicado.
Se considera una variante del problema de consenso bizantino llamado \textit{Validity Predicate-based Byzantine consensus}
que es motivado por los sistemas de blockchain~\cite{Crain2017LeaderRandomizationSignaturefreeBC}.
El problema es definido por propiedades de acuerdo, terminación, y validés.

Esta variante del problema de consenso bizantino tiene un predicado específico a la aplicación
denotado \textit{valid()} que indica si un valor es válido. En el contexto de sistemas de blockchain, por ejemplo,
un valor no es válido si no contiene un hash apropiado del último bloque añadido a la blockchain.

\begin{property}[Agreement]\label{tendermint:agreement1}
  Dos procesos correctos nunca deciden valores distintos.
\end{property}

\begin{property}[Termination]\label{tendermint:termination1}
    Todos los procesos correctos deciden eventualmente un valor.
\end{property}

\begin{property}[Validity]\label{tendermint:validity}
    Un valor decidido es válido. Es decir, satisface el predicado predefinido
    denotado con \textit{valid}.
\end{property}
%

Las propiedades ~\ref{tendermint:safety} y ~\ref{tendermint:liveness} son demostradas en ~\cite{Kwon2014TendermintC}.
Las propiedades ~\ref{tendermint:agreement1}, ~\ref{tendermint:termination1} y ~\ref{tendermint:validity}
son demostradas en ~\cite{Buchman.2018.Tendermint}.

% En esta sección se introducen las propiedades que deben cumplir las implementaciones
% correctas de \setchain.
% La especificación dada asume que los clientes interactúan con servidores correctos,
% aunque en realidad los clientes no pueden estar seguros de que el servidor que están
% contactando no sea bizantino.
% Como ya fue mencionado anteriormente, las propiedades siempren razonan sobre los servidores
% correctos, dado que los servidores bizantinos no proveen ninguna garantía.
% %

% Empezamos requiriendo que en \setchain toda operación \<add> y \<get> ejecutada sobre un servidor
% correcto eventualmente termine.
% Se dice que un elemento $e$ está en la época $i$ en el historial $H$ (retornado por una invocación
% a \<get>) si $e \in H(i)$.
% Se dice que un elemento $i$ está en $H$ is existe una época $i$ tal que $e \in H(i)$.

% % ? Esta es la property que Marga indicó que falta en el preliminar de Setchain
% La primera propiedad establece que las épocas solo contienen elementos que provienen del conjunto
% de solo crecimiento.

% % 1. Cada elemento válido agregado en un servidor correcto eventualmente es retor-
% % nado en todas las futuras invocaciones a get hechas sobre servidores correctos.
% La segunda propiedad declara que todo elemento añadido a un servidor correcto es eventualmente
% retornado en todas las llamadas a \<get> futuras.

% % ?
% La siguiente propiedad establece que los elementos presentes es un servidor correcto son propagados
% a todos los servidores correctos.

% Se asume en el resto de este trabajo que en cualquier punto de tiempo hay un instante futuro en el
% cual una nueva época será generada. Esto es un supuesto razonable en cual escenario práctico.

% % 2. Todos los elementos válidos agregados en un servidor correcto deben eventual-
% % mente ser estampados con un número de época en todos los servidores correctos.
% La siguiente propiedad establece que todos los elementos añadidos son eventualmente estampados
% con un número de época.

% % ?
% La siguiente propiedad establece que un elemento puede estar en a lo sumo una época,
% y que ningún elemento puede estar en dos épocas diferentes incluso si los conjuntos historiales se
% obtienen de invocaciones \<get> a distintos servidores (ambos correctos).

% % 4. Dos servidores correctos cualesquieras están de acuerdo en el contenido de todas
% % las épocas que hayan sido computadas
% La siguiente propiedad establece que los servidores están de acuerdo en el contenido
% de las épocas.

% % 5. Cada elemento que se estampa con una época proviene del resultado de un cliente
% % añadiendo el elemento.
% Finalmente, se requiere que todo elemento in el historia provenga del resultado de un cliente
% añadiendo un elemento.


% Faltarían las siguientes propiedades
