\section{Objetivo del capítulo}
En este capítulo se presentan las pruebas de correctitud de los algoritmos presentados para
\vanilla, \compresschain, y \hashchain en el capítulo~\ref{chapter:sol}.
Es decir, se prueba que dichos algoritmos satisfacen las propiedades deseadas para una
implementación de \setchain introducidas en~\ref{subsubsec:setchain-properties}.

\section{Propiedades de Tendermint}\label{sec:properties}
Dado que todas las soluciones presentadas en este trabajo son construidas sobre Tendermint,
para probar la correctitud de ellas, será necesario recapitular las propiedades que la
plataforma Tendermint garantiza.

El modelo de Tendermint considera un sistema de procesos que se comunican mediante el intercambio de
mensajes.
Los procesos pueden ser correctos o defectuosos, donde un proceso defectuoso se comporta de maneras
arbitrarias. Es decir, se consideran procesos bizantinos.

Se asume que cada proceso tiene una cantidad determinada de \textit{poder de voto} (el poder de
voto de un proceso puede ser 0).
%
En el contexto de Tendermint, denotamos con \textit{n} el poder de voto total de los procesos
en el sistema, y asumimos una cota superior \textit{f} en el poder de voto total proveniente de
los procesos bizantinos.
%
El algoritmo de consenso de Tendermint asume que $n > 3f$, es decir, requiere que el poder de voto
en manos de procesos bizantinos sea menor a 1/3 del poder de voto total.
Por simplicidad, en ocasiones se considera $n = 3f + 1$.
% We consider a system of processes that communicate by exchanging messages. Processes can be correct or
% faulty, where a faulty process can behave in an arbitrary way, i.e., we consider Byzantine faults. We assume
% that each process has some amount of voting power (voting power of a process can be 0). Processes in our
% model are not part of a single administrative domain; therefore we cannot enforce a direct network connectivity
% between all processes. Instead, we assume that each process is connected to a subset of processes called peers,
% such that there is an indirect communication channel between all correct processes. Communication between
% processes is established using a gossip protocol

\newcounter{prop:tendermint}
\setcounter{prop:tendermint}{\value{property}}

\begin{property}[Tendermint-Agreement]\label{tendermint:agreement}
  Dos procesos correctos nunca deciden valores distintos.
\end{property}

\begin{property}[Tendermint-Termination]\label{tendermint:termination}
    Todos los procesos correctos deciden eventualmente un valor.
\end{property}

Las propiedades ~\ref{tendermint:agreement} y ~\ref{tendermint:termination}
son demostradas en ~\cite{Buchman.2018.Tendermint}.

En el contexto de estas demostraciones
se asume una mempool de tamaño tal que nunca se satura.
Es decir, el ratio de invocaciones \<add> por parte de los clientes nunca
llena la capacidad de la mempool, de modo que los elementos enviados por clientes
nunca son descartados por mempool llena.
De aquí se desprende la siguientes propiedades correspondientes a la distintas implementaciones
propuestas.
\begin{property}[Tendermint-Vanilla-Delivery]\label{tendermint:vanilla-delivery}
  Sea $e$ un elemento válido y $v$ un servidor correcto. Luego de cada invocación
  $v.\<add>(e)$ por parte de un cliente, eventualmente se produce
  una petición $\<DeliverTx>(t)$ a la ABCI correspondiente de $v$, en donde
  $t$ es la transacción que representa a $e$.
\end{property}

\begin{property}[Tendermint-Compresschain-Delivery]\label{tendermint:delivery-compreschain}
  Sea $e$ un elemento válido y $v$ un servidor correcto. Luego de cada invocación
  $v.\<add>(e)$ por parte de un cliente, eventualmente se produce
  una petición $\<DeliverTx>(t)$ a la ABCI correspondiente de $v$, en donde
  $t$ es un lote comprimido de elementos, y uno de esos elementos
  es $e$.
\end{property}

\begin{property}[Tendermint-Haschain-Delivery]\label{tendermint:delivery-hashchain}
  Sea $e$ un elemento válido y $v$ un servidor correcto. Luego de cada invocación
  $v.\<add>(e)$ por parte de un cliente, eventualmente se produce
  una petición $\<DeliverTx>(t)$ a la ABCI correspondiente de $v$, en donde
  $t$ es un lote hasheado de elementos, y uno de esos elementos
  es $e$.
\end{property}



\section{Prueba de correctitud para \vanilla}\label{sec:proof-vanilla}

\newcounter{lemma:vanilla}
\setcounter{lemma:vanilla}{\value{lemma}}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Consistent Sets}~\ref{api:consistent-set} de \setchain,
  que establece que las épocas solo contienen elementos que provienen del conjunto de solo crecimiento.
\end{lemma}

\begin{proof}
  Esto es trivialmente correcto debido a que la
  construcción de $\THESET$ y de $\HISTORY$ se hace a partir de los mismos elementos, como se puede ver en las líneas
  \ref{line:abci-vanilla-set} y \ref{line:abci-vanilla-history} en el Algoritmo~\ref{alg:abci-vanilla}.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Add-Get-Local}~\ref{api:history->theset-local} de \setchain,
  que declara que todo elemento válido añadido a un
  servidor correcto $v$ es eventualmente retornado en todas las llamadas futuras a $v$.\<get>.
\end{lemma}

\begin{proof}
  Sea $e$ un elemento válido y $v$ un servidor correcto, para los cuales un cliente invoca $v.\<add>(e)$.
  Por la propiedad \textit{Tendermint-Vanilla-Delivery}~\ref{tendermint:vanilla-delivery} sabemos que
  eventualmente $v$ recibirá una petición $\<DeliverTx>(t)$, en donde $t = e$.
  Como se puede observar
  en la condición \texttt{if} de la línea ~\ref{line:abci-vanilla-if} en el Algoritmo~\ref{alg:abci-vanilla},
  se analizan dos aspectos: que $e$ sea válido (lo cual se cumple por hipótesis)
  y que $e$ no forme parte de $\HISTORY$.
  Si el elemento a añadir ya es
  parte de $\HISTORY$ entonces necesariamente $e$ pertenece a $\THESET$ (ver propiedad anterior)
  y, por lo tanto, es retornado en todas la llamadas a $v$.\<get>.
  Por el contrario, si el elemento $e$ es nuevo, entonces será añadido a $\THESET$ como se indica en la
  línea ~\ref{line:abci-vanilla-set}, y retornado como parte de él en todas las futuras invocaciones a
  $v$.\<get>.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Get-Global}~\ref{api:history->theset} de \setchain,
  que establece que los elementos presentes en un servidor correcto
  son propagados a todos los servidores correctos.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e$ un elemento válido, tal que  $e \in v.\THESET$.
  Entonces, por construcción de $\THESET$, necesariamente $v$ en algún momento recibió una
  petición \<DeliverTx> para la transacción asociada al elemento $e$.
  Esto implica que el servidor decidió dicha transacción, puesto que la petición \<DeliverTx> se
  envía una vez que las transacciones fueron decididas y ordenadas.
  Luego, por la propiedad de \textit{Tendermint-Agreement}, todos los nodos correctos decidirán
  la misma transacción asociada al elemento $e$, y por tanto recibirán la petición \<DeliverTx>
  para ella, añadiéndo a $e$ a su conjunto $\THESET$, como se muestra en la línea
  \ref{line:abci-vanilla-set} en el Algoritmo~\ref{alg:abci-vanilla}.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Eventual-Get}~\ref{api:theset->history}
  de \setchain, que establece que todos los elementos añadidos son eventualmente estampados
  con un número de época.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e \in U$. Si $e \in v.\THESET$, entonces por construcción de
  $\THESET$, necesariamente $v$ en algún momento recibió una
  petición \<DeliverTx> para la transacción asociada al elemento $e$.
  Como se puede ver en las líneas \ref{line:abci-vanilla-set} y \ref{line:abci-vanilla-history} en
  el Algoritmo~\ref{alg:abci-vanilla}, inmediatamente después de agregar un elemento a $\THESET$,
  el elemento se agrega a $\HISTORY$. Por lo tanto, con seguridad, el elemento $e$ será eventualmente
  agregado a $\HISTORY$ y, por lo tanto, estampado con un número de época.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Unique Epoch}~\ref{api:local_unique_stamp} de \setchain,
  que establece que un elemento puede estar en a lo sumo una época.
\end{lemma}

\begin{proof}
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Consistent Gets}~\ref{api:consistent-gets} de \setchain,
  que establece que los servidores están de acuerdo en el contenido
  de las épocas.
\end{lemma}

\begin{proof}
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Add-before-Get}~\ref{api:get->add} de \setchain,
  que determina que todo elemento en $\HISTORY$ provenga del resultado de un cliente
  añadiendo un elemento.
\end{lemma}

\begin{proof}
\end{proof}

\section{Prueba de correctitud para \compresschain}\label{sec:proof-compresschain}
\begin{itemize}
  \item La \textit{Propiedad 1 (Consistent Sets)} de \setchain establece que las épocas solo contienen
  elementos que provienen del conjunto de solo crecimiento. Esto es trivialmente correcto debido a que la
  construcción de $\THESET$ y de $\HISTORY$ se hacen a partir de los mismos elementos (ver definición de
  \<newEpoch> y \<DeliverTx> en el Algoritmo~\ref{alg:abci-brotli}).
\end{itemize}
\section{Prueba de correctitud para \hashchain}\label{sec:proof-hashchain}
\begin{itemize}
  \item La \textit{Propiedad 1 (Consistent Sets)} de \setchain establece que las épocas solo contienen
  elementos que provienen del conjunto de solo crecimiento. Esto es trivialmente correcto debido a que la
  construcción de $\THESET$ y de $\HISTORY$ se hacen a partir de los mismos elementos (ver definición de
  \<reverse> y \<Query> en el Algoritmo~\ref{alg:abci-hash1} y ~\ref{alg:abci-hash2}).
\end{itemize}

\subsection{Otras cosas}
\begin{property}[Safety]\label{tendermint:safety}
  Si hay menos de 1/3 del poder de voto en manos bizantinas y al menos un validador correcto
  decide el bloque $B$, entonces ningún validador correcto decidirá un bloque distinto a $B$.
\end{property}

\begin{property}[Liveness]\label{tendermint:liveness}
  Si hay menos de 1/3 de poder de voto en manos bizantinas, luego el procolo de Tendermint
  no se bloquea (es decir, no hay \textit{deadlock}).
\end{property}

En el contexto de Tendermint, denotamos con \textit{n} el poder de voto total de los procesos
en el sistema, y asumimos una cota superior \textit{f} en el poder de voto total proveniente de
los procesos bizantinos.
%
El algoritmo de consenso de Tendermint asume que $n > 3f$, es decir, requiere que el poder de voto
en manos de procesos bizantinos sea menor a 1/3 del poder de voto total.
Por simplicidad, en ocasiones se considera $n = 3f + 1$.

Tendermint resuelve el problema de la replicación de máquinas de estados ejecutando instancias de
consenso secuencialmente para acordar cada bloque de transacciones que serán luego ejecutadas por el
servicio siendo replicado.
Se considera una variante del problema de consenso bizantino llamado \textit{Validity Predicate-based Byzantine consensus}
que es motivado por los sistemas de blockchain~\cite{Crain2017LeaderRandomizationSignaturefreeBC}.
El problema es definido por propiedades de acuerdo, terminación, y validés.

Esta variante del problema de consenso bizantino tiene un predicado específico a la aplicación
denotado \textit{valid()} que indica si un valor es válido. En el contexto de sistemas de blockchain, por ejemplo,
un valor no es válido si no contiene un hash apropiado del último bloque añadido a la blockchain.

\begin{property}[Agreement]\label{tendermint:agreement1}
  Dos procesos correctos nunca deciden valores distintos.
\end{property}

\begin{property}[Termination]\label{tendermint:termination1}
    Todos los procesos correctos deciden eventualmente un valor.
\end{property}

\begin{property}[Validity]\label{tendermint:validity}
    Un valor decidido es válido. Es decir, satisface el predicado predefinido
    denotado con \textit{valid}.
\end{property}
%

Las propiedades ~\ref{tendermint:safety} y ~\ref{tendermint:liveness} son demostradas en ~\cite{Kwon2014TendermintC}.
Las propiedades ~\ref{tendermint:agreement1}, ~\ref{tendermint:termination1} y ~\ref{tendermint:validity}
son demostradas en ~\cite{Buchman.2018.Tendermint}.

% En esta sección se introducen las propiedades que deben cumplir las implementaciones
% correctas de \setchain.
% La especificación dada asume que los clientes interactúan con servidores correctos,
% aunque en realidad los clientes no pueden estar seguros de que el servidor que están
% contactando no sea bizantino.
% Como ya fue mencionado anteriormente, las propiedades siempren razonan sobre los servidores
% correctos, dado que los servidores bizantinos no proveen ninguna garantía.
% %

% Empezamos requiriendo que en \setchain toda operación \<add> y \<get> ejecutada sobre un servidor
% correcto eventualmente termine.
% Se dice que un elemento $e$ está en la época $i$ en el historial $H$ (retornado por una invocación
% a \<get>) si $e \in H(i)$.
% Se dice que un elemento $i$ está en $H$ is existe una época $i$ tal que $e \in H(i)$.

% % ? Esta es la property que Marga indicó que falta en el preliminar de Setchain
% La primera propiedad establece que las épocas solo contienen elementos que provienen del conjunto
% de solo crecimiento.

% % 1. Cada elemento válido agregado en un servidor correcto eventualmente es retor-
% % nado en todas las futuras invocaciones a get hechas sobre servidores correctos.
% La segunda propiedad declara que todo elemento añadido a un servidor correcto es eventualmente
% retornado en todas las llamadas a \<get> futuras.

% % ?
% La siguiente propiedad establece que los elementos presentes es un servidor correcto son propagados
% a todos los servidores correctos.

% Se asume en el resto de este trabajo que en cualquier punto de tiempo hay un instante futuro en el
% cual una nueva época será generada. Esto es un supuesto razonable en cual escenario práctico.

% % 2. Todos los elementos válidos agregados en un servidor correcto deben eventual-
% % mente ser estampados con un número de época en todos los servidores correctos.
% La siguiente propiedad establece que todos los elementos añadidos son eventualmente estampados
% con un número de época.

% % ?
% La siguiente propiedad establece que un elemento puede estar en a lo sumo una época,
% y que ningún elemento puede estar en dos épocas diferentes incluso si los conjuntos historiales se
% obtienen de invocaciones \<get> a distintos servidores (ambos correctos).

% % 4. Dos servidores correctos cualesquieras están de acuerdo en el contenido de todas
% % las épocas que hayan sido computadas
% La siguiente propiedad establece que los servidores están de acuerdo en el contenido
% de las épocas.

% % 5. Cada elemento que se estampa con una época proviene del resultado de un cliente
% % añadiendo el elemento.
% Finalmente, se requiere que todo elemento in el historia provenga del resultado de un cliente
% añadiendo un elemento.


% Faltarían las siguientes propiedades
