\section{Objetivo del capítulo}
En este capítulo se presentan las pruebas de correctitud de los algoritmos presentados para
\vanilla, \compresschain, y \hashchain en el capítulo~\ref{chapter:sol}.
Es decir, se prueba que dichos algoritmos satisfacen las propiedades deseadas para una
implementación de \setchain introducidas en~\ref{subsubsec:setchain-properties}.

\section{Propiedades de Tendermint}\label{sec:properties}
Dado que todas las soluciones presentadas en este trabajo son construidas sobre Tendermint,
para probar la correctitud de ellas, será necesario recapitular las propiedades que la
plataforma Tendermint garantiza.

El modelo de Tendermint considera un sistema de procesos que se comunican mediante el intercambio de
mensajes.
Los procesos pueden ser correctos o defectuosos, donde un proceso defectuoso se comporta de maneras
arbitrarias. Es decir, se consideran procesos bizantinos.

Se asume que cada proceso tiene una cantidad determinada de \textit{poder de voto} (el poder de
voto de un proceso puede ser 0).
%
En el contexto de Tendermint, denotamos con \textit{n} el poder de voto total de los procesos
en el sistema, y asumimos una cota superior \textit{f} en el poder de voto total proveniente de
los procesos bizantinos.
%
El algoritmo de consenso de Tendermint asume que $n > 3f$, es decir, requiere que el poder de voto
en manos de procesos bizantinos sea menor a 1/3 del poder de voto total.
Por simplicidad, en ocasiones se considera $n = 3f + 1$.
% We consider a system of processes that communicate by exchanging messages. Processes can be correct or
% faulty, where a faulty process can behave in an arbitrary way, i.e., we consider Byzantine faults. We assume
% that each process has some amount of voting power (voting power of a process can be 0). Processes in our
% model are not part of a single administrative domain; therefore we cannot enforce a direct network connectivity
% between all processes. Instead, we assume that each process is connected to a subset of processes called peers,
% such that there is an indirect communication channel between all correct processes. Communication between
% processes is established using a gossip protocol

\newcounter{prop:tendermint}
\setcounter{prop:tendermint}{\value{property}}

\begin{property}[Tendermint-Agreement]\label{tendermint:agreement}
  Dos procesos correctos nunca deciden valores distintos.
\end{property}

\begin{property}[Tendermint-Termination]\label{tendermint:termination}
    Todos los procesos correctos deciden eventualmente un valor.
\end{property}

Las propiedades ~\ref{tendermint:agreement} y ~\ref{tendermint:termination}
son demostradas en ~\cite{Buchman.2018.Tendermint}.

En el contexto de estas demostraciones
se asume una mempool de tamaño tal que nunca se satura.
Es decir, el ratio de invocaciones \<add> por parte de los clientes nunca
llena la capacidad de la mempool, de modo que los elementos enviados por clientes
nunca son descartados por mempool llena.
De aquí se desprenden las siguientes propiedades.

\begin{property}[Tendermint-Eventual-CheckTx]\label{tendermint:eventual-checktx}
  Sea $t$ una transacción.
  Si se invoca \<broadcastTx>($t$) sobre un servidor correcto $v$, luego
  $v$ recibirá la petición \<CheckTx>($t$).
\end{property}

\begin{property}[Tendermint-Eventual-Injection]\label{tendermint:eventual-injection}
  Sea $t$ una transacción en la mempool de un servidor correcto.
  Eventualmente, $t$ formará parte de un bloque.
\end{property}

\begin{property}[Tendermint-DeliverTx-BroadcastTx]\label{tendermint:delivery-broadcast}
  Sea $v$ un servidor correcto.
  Si $v$ recibe una petición $\<DeliverTx>(t)$,
  entonces necesariamente $t$ es una transacción válida y, en el pasado, 
  \<broadcastTx>($t$) fue invocado en algún servidor. NOTA: acá no se puede asegurar
  que fue invocado en un servidor correcto.
\end{property}

A continuación se presenta una propiedad que desprende de la concepción de Tendermint
como máquina de replicación de estados.

\begin{property}[Tendermint-Global-DeliverTx]\label{tendermint:global-delivery}
  Si un servidor correcto $v$ recibe una petición $\<DeliverTx>(t)$, entonces todos
  los servidores correctos reciben la misma petición $\<DeliverTx>(t)$ eventualmente.
  Aún más, esta petición se hace en el mismo orden con respecto a otras
  peticiones $\<DeliverTx>$ en todos los servidores correctos.
\end{property}

\begin{proof}
  Si un servidor correcto $v$ recibe una petición $\<DeliverTx>(t)$ entonces, por definición
  de \<DeliverTx>, $t$ fue decidida como una transacción parte de un bloque.
  Por las propiedades \textbf{Tendermint-Agreement} y \textbf{Tendermint-Termination},
  podemos asegurar que todos los servidores correctos deciden a $t$ como
  parte del mismo bloque y, por lo tanto, todos recibirán la petición \<DeliverTx>($t$),
  incluso 
  en el mismo orden respecto a las otras peticiones \<DeliverTx> para el mismo bloque
  - ya que estas peticiones se
  realizan de forma asíncrona pero en orden, una vez que las transacciones dentro del bloque
  ya fueron decididas y ordenadas.
\end{proof}

% \begin{property}[Tendermint-Delivery-Mempool]\label{tendermint:delivery-mempool}
%   Sea $v$ un servidor correcto.
%   Si $v$ recibe una petición $\<DeliverTx>(t)$,
%   entonces necesariamente, en el pasado, $t$ formó parte de la mempool de un
%   servidor correcto y fue propuesto para formar parte de un bloque.
% \end{property}

% \begin{property}[Tendermint-Mempool-Broadcast]\label{tendermint:mempool-broadcast}
%   Sea $v$ un servidor correcto.
%   Si $t$ forma parte de la mempool de $v$, entonces necesariamente, en el pasado,
%   \<broadcastTx>($t$) fue invocado en algún servidor correcto y la petición
%   $\<CheckTx>(t)$ en $v$ retornó \texttt{true}.
% \end{property}

\subsection{Propiedades derivadas}

Con el objetivo de hacer las demostraciones más sencillas, se definen y demuestran las siguientes
propiedades derivadas para cada implementación realizada de \setchain.

\begin{property}[Tendermint-Vanilla-Delivery]\label{tendermint:vanilla-delivery}
  Sea $e$ un elemento válido y $v$ un servidor correcto.
  Luego de cada invocación
  $v.\<add>(e)$ por parte de un cliente, eventualmente se produce
  una petición $v.\<DeliverTx>(t)$, donde $t = e$.
  % Luego de cada invocación
  % $v.\<add>(e)$ por parte de un cliente, eventualmente se produce
  % una petición $\<DeliverTx>(t)$ en todos los servidores correctos, donde
  % $t = e$. Aún más, esta petición se hace en el mismo orden con respecto a otras
  % peticiones $\<DeliverTx>$ en todos los servidores correctos.
\end{property}

\begin{proof}
  Sea $e$ un elemento válido y $v$ un servidor correcto.
  Por definción de \<add> en el algoritmo \ref{alg:api-vanilla}, la invocación
  $v.\<add>(e)$ se traduce en la llamada \<broadcastTx>($t$) sobre el servidor $v$,
  donde $t = e$. Por la propiedad \textbf{Tendermint-Eventual-CheckTx}, $v$
  recibirá eventualmente la petición \<CheckTx>($t$).
  Por hipótesis se tiene que $e$ es un elemento válido, por lo cual, siendo $t = e$
  y considerando la definición de \<CheckTx> en la línea \ref{alg:van_check_tx} del algoritmo
  \ref{alg:abci-vanilla}, se deduce que la llamada a \<CheckTx>($t$) retornará \texttt{true}
  en $v$, por lo cual $t$ pasará a formar parte de la mempool de $v$.
  Luego, por la propiedad \textbf{Tendermint-Eventual-Injection} sabemos que la
  transacción $t$ formará parte de un bloque.
  Por definición de \<DeliverTx>, dado que $t$ es una transacción parte de un bloque,
  el seridor $v$ eventualmente recibirá una petición \<DeliverTx>($t$).
  % Por las propiedades \textbf{Tendermint-Agreement} y \textbf{Tendermint-Termination},
  % todos los servidores correctos estarán de acuerdo en que $t$ forma
  % parte de un bloque y, por lo tanto, todos recibirán la petición \<DeliverTx>($t$)
  % en el mismo orden respecto a las otras peticiones \<DeliverTx> - ya que estas peticiones se
  % realizan de forma asíncrona pero en orden, puesto que las transacciones dentro del bloque
  % ya fueron decididas y ordenadas al momento de hacerse.
\end{proof}

\begin{property}[Tendermint-Vanilla-Deliver-Add]\label{tendermint:vanilla-deliver-add}
  Sea $v$ un servidor correcto.
  Si $v$ recibe una petición $\<DeliverTx>(t)$,
  entonces necesariamente, en el pasado, un cliente invocó $\<add>(e)$ sobre un servidor,
  donde $e=t$. NOTA: acá no se puede asegurar que fue invocado en un servidor correcto.
\end{property}

\begin{proof}
  Sea $v$ un servidor correcto que recibe una petición $\<DeliverTx>(t)$.
  Por la propiedad \textbf{Tendermint-DeliverTx-BroadcastTx} sabemos que
  necesariamente $t$ es una transacción válida y, en el pasado, 
  \<broadcastTx>($t$) fue invocado en algún servidor (NOTA: no necesariamente correcto).
  Si \<broadcastTx>($t$) fue invocado, entonces con certeza un cliente invocó
  $\<add>(e)$ en un servidor, donde $e = t$ - puesto que \<broadcastTx> solo
  se llama como parte de la definición de \<add>.

  NOTA: si el servidor no es correcto podría invocar \<broadcastTx>($t$) sin necesidad de
  un cliente invocando add?
\end{proof}

% \begin{property}[Tendermint-Eventual-Mempool]\label{tendermint:eventual-mempool}
%   Sea $t$ una transacción válida.
%   Si se invoca \<broadcastTx>($t$) sobre un servidor correcto, luego $t$ terminará
%   en la mempool de todos los servidores correctos.
% \end{property}

% \begin{proof}
%   Por la propiedad \textbf{Tendermint-Eventual-CheckTx} se tiene que todos los servidores
%   correctos reciben la petición \<CheckTx>($t$).
%   Dado que $t$ es una transacción válida, es decir, una transacción para la cual la evaluación
%   de \<CheckTx>($t$) es \texttt{true}, $t$ será añadida a la mempool de todos los servidores
%   correctos.
% \end{proof}


% \begin{property}[Tendermint-Eventual-DeliverTx]\label{tendermint:eventual-delivertx}
%   Sea $t$ una transacción en la mempool de un servidor correcto.
%   Eventualmente, todos los servidores correctos recibirán la petición \<DeliverTx>($t$)
%   (y en el mismo orden respecto a las otras peticiones \<DeliverTx>).
% \end{property}

% \begin{proof}
%   Por la propiedad \textbf{Tendermint-Eventual-Injection} se tiene que eventualmente
%   $t$ forma parte de un bloque.
%   Por las propiedades \textbf{Tendermint-Agreement} y \textbf{Tendermint-Termination},
%   todos los servidores correctos estarán de acuerdo en que $t$ forma
%   parte de un bloque y, por lo tanto, todos recibirán la petición \<DeliverTx>($t$)
%   en el mismo orden respecto a las otras peticiones \<DeliverTx> (ya que estas peticiones se
%   realizan de forma asíncrona pero en orden, puesto que las transacciones dentro del bloque
%   ya fueron decididas y ordenadas al momento de hacerse).
% \end{proof}



\begin{property}[Tendermint-Compresschain-Delivery]\label{tendermint:compresschain-delivery}
  Sea $e$ un elemento válido y $v$ un servidor correcto. Luego de cada invocación
  $v.\<add>(e)$ por parte de un cliente, eventualmente se produce
  una petición $\<DeliverTx>(t)$ a la ABCI correspondiente de $v$, en donde
  $t$ es un lote comprimido de elementos, y uno de esos elementos
  es $e$.
\end{property}

\begin{property}[Tendermint-Haschain-Delivery]\label{tendermint:hashchain-delivery}
  Sea $e$ un elemento válido y $v$ un servidor correcto. Luego de cada invocación
  $v.\<add>(e)$ por parte de un cliente, eventualmente se produce
  una petición $\<DeliverTx>(t)$ a la ABCI correspondiente de $v$, en donde
  $t$ es un lote hasheado de elementos, y uno de esos elementos
  es $e$.
\end{property}



\section{Prueba de correctitud para \vanilla}\label{sec:proof-vanilla}

\newcounter{lemma:vanilla}
\setcounter{lemma:vanilla}{\value{lemma}}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Consistent Sets}~\ref{api:consistent-set} de \setchain,
  que establece que las épocas solo contienen elementos que provienen del conjunto de solo crecimiento.
\end{lemma}

\begin{proof}
  Esto es trivialmente correcto debido a que la
  construcción de $\THESET$ y de $\HISTORY$ se hace a partir de los mismos elementos, como se puede ver en las líneas
  \ref{line:abci-vanilla-set} y \ref{line:abci-vanilla-history} en el Algoritmo~\ref{alg:abci-vanilla}.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Add-Get-Local}~\ref{api:history->theset-local} de \setchain,
  que declara que todo elemento válido añadido a un
  servidor correcto $v$ es eventualmente retornado en todas las llamadas futuras a $v$.\<get>.
\end{lemma}

\begin{proof}
  Sea $e$ un elemento válido y $v$ un servidor correcto, para los cuales un cliente invoca $v.\<add>(e)$.
  Por la propiedad \textit{Tendermint-Vanilla-Delivery}~\ref{tendermint:vanilla-delivery} sabemos que
  eventualmente $v$ recibirá una petición $\<DeliverTx>(t)$, en donde $t = e$.
  Como se puede observar
  en la condición \texttt{if} de la línea ~\ref{line:abci-vanilla-if} en el Algoritmo~\ref{alg:abci-vanilla},
  se analizan dos aspectos: que $e$ sea válido (lo cual se cumple por hipótesis)
  y que $e$ no forme parte de $\HISTORY$.
  Si el elemento a añadir ya es
  parte de $\HISTORY$ entonces necesariamente $e$ pertenece a $\THESET$ (ver propiedad anterior)
  y, por lo tanto, es retornado en todas la llamadas a $v$.\<get>.
  Por el contrario, si el elemento $e$ es nuevo, entonces será añadido a $\THESET$ como se indica en la
  línea ~\ref{line:abci-vanilla-set}, y retornado como parte de él en todas las futuras invocaciones a
  $v$.\<get>.
\end{proof}

\begin{lemma}\label{proof:get-global}
  La implementación \vanilla cumple la propiedad \textit{Get-Global}~\ref{api:history->theset} de \setchain,
  que establece que los elementos presentes en un servidor correcto
  son propagados a todos los servidores correctos.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e$ un elemento válido, tal que  $e \in v.\THESET$.
  Entonces, por construcción de $\THESET$, necesariamente $v$ en algún momento recibió una
  petición \<DeliverTx>($t$), donde $t = e$.
  Si un servidor correcto recibe una petición \<DeliverTx>($t$), por la propiedad
  \textbf{Tendermint-Global-DeliverTx}
  todos los
  servidores correctos reciben dicha petición \<DeliverTx>($t$), añadiéndo a $e$ a su conjunto
  $\THESET$, como se muestra en la línea
  \ref{line:abci-vanilla-set} en el Algoritmo~\ref{alg:abci-vanilla}.

  % Esto implica que el servidor decidió dicha transacción, puesto que la petición \<DeliverTx> se
  % envía una vez que las transacciones fueron decididas y ordenadas.
  % Luego, por la propiedad de \textit{Tendermint-Agreement}, todos los nodos correctos decidirán
  % la misma transacción asociada al elemento $e$, y por tanto recibirán la petición \<DeliverTx>
  % para ella, añadiéndo a $e$ a su conjunto $\THESET$, como se muestra en la línea
  % \ref{line:abci-vanilla-set} en el Algoritmo~\ref{alg:abci-vanilla}.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Eventual-Get}~\ref{api:theset->history}
  de \setchain, que establece que todos los elementos añadidos son eventualmente estampados
  con un número de época.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e \in U$. Si $e \in v.\THESET$, entonces por construcción de
  $\THESET$, necesariamente $v$ en algún momento recibió una
  petición \<DeliverTx>($t$), donde $t = e$.
  Como se puede ver en las líneas \ref{line:abci-vanilla-set} y \ref{line:abci-vanilla-history} en
  el Algoritmo~\ref{alg:abci-vanilla}, inmediatamente después de agregar un elemento a $\THESET$,
  el elemento se agrega a $\HISTORY$. Por lo tanto, con seguridad, el elemento $e$ será eventualmente
  agregado a $\HISTORY$ y, por lo tanto, estampado con un número de época.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Unique Epoch}~\ref{api:local_unique_stamp} de \setchain,
  que establece que un elemento puede estar en a lo sumo una época.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto e ${i,i'\leq v.\EPOCH}$ con ${i\neq i'}$.
  Queremos probar que $v.\HISTORY(i)\cap{}v.\HISTORY(i')=\emptyset$.
  %

  La demostración se hará por el absurdo.
  Sin pérdida de generalidad, suponemos que ${i < i'}$. Sea $e$ un elemento $\in \HISTORY(i)$ .
  Por lo tanto, $e$ fue estampado con el número de época $i$.
  %
  Suponemos ahora que también se cumple $e \in \HISTORY(i')$. Es decir, 
  $e$ fue estampado con el número de época $i'$.
  Para que $e$ también haya sido añadido a la época $i'$, necesariamente debe haber llegado
  una petición \<DeliverTx> para la transacción asociada al elemento $e$ que, al procesarse,
  incluyó a $e$ como parte de $\HISTORY(i')$.
  %
  Por construcción, esto necesariamente debe haber pasado en la línea
  \ref{line:abci-vanilla-history} en el Algoritmo~\ref{alg:abci-vanilla},
  con lo cual se concluye que la condición del \texttt{if} de
  la línea ~\ref{line:abci-vanilla-if} evaluó a \texttt{true} (*)
  (ya que de otro modo, el elemento no hubiese sido añadido).
  %

  Dado que ${i < i'}$, y las peticiones se hacen ordenadamente, al momento de la
  petición \<DeliverTx>, la época $i$ ya fue construida, y por lo tanto se tiene
  $e \in \HISTORY(i)$.
  Por este motivo, al procesar la petición \<DeliverTx>, la condición \texttt{if} de
  la línea ~\ref{line:abci-vanilla-if} evaluará a \texttt{false}, dado que 
  \texttt{not} $e$ \texttt{in} $\HISTORY$ es falso, puesto que $e \in \HISTORY(i)$ .
  Esto lleva a una contradicción por (*).
  La contradicción proviene de suponer que $e \in \HISTORY(i')$.
  Por lo tanto, se concluye que $e \not\in \HISTORY(i')$. Luego se tiene
  $\HISTORY(i)\cap{}\HISTORY(i')=\emptyset$.

  
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Consistent Gets}~\ref{api:consistent-gets} de \setchain,
  que establece que los servidores están de acuerdo en el contenido
  de las épocas.
\end{lemma}

\begin{proof}
  Sean $v$ y $w$ dos servidores correctos, e $i\leq \min(v.\EPOCH, w.\EPOCH)$.
  Queremos probar que $v.\HISTORY(i)=w.\HISTORY(i)$.

  Se seguirá un razonamiento similar al presentado en la demostración del
  \textbf{Lema ~\ref{proof:get-global}}.
  Sea $e$ un elemento $\in v.\HISTORY(i)$. 
  Por construcción de $\HISTORY$, necesariamente $v$ en un momento determinado recibió una
  petición \<DeliverTx>($t$), donde $t = e$, lo cual
  produjo que $e$ fuera estampado con el número de época $i$.
  % Esto implica que el servidor decidió dicha transacción, puesto que la petición \<DeliverTx> se
  % envía una vez que las transacciones fueron decididas y ordenadas.
  % Luego, por la propiedad de \textit{Tendermint-Agreement}, todos los nodos correctos y, en particular $w$,
  % deciden la misma transacción asociada al elemento $e$ (en el mismo orden que $v$).
  Por la propiedad \textbf{Tendermint-Global-DeliverTx} podemos asegurar que todos los servidores correctos,
  y en particular $w$, reciben la petición \<DeliverTx>($t$) en el mismo orden en que lo hace $v$, es decir,
  durante la construcción de la época $i$, añadiendo a $e$ a $w.\HISTORY(i)$, como se muestra en la línea
  \ref{line:abci-vanilla-history} en el Algoritmo~\ref{alg:abci-vanilla}.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Add-before-Get}~\ref{api:get->add} de \setchain,
  que determina que todo elemento en $\THESET$ proviene del resultado de un cliente
  añadiendo un elemento.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e \in \THESET$. Por construcción de $\THESET$,
  necesariamente $v$ en algún momento recibió una
  petición \<DeliverTx> para la transacción asociada al elemento $e$.
  Luego, por la propiedad \textit{Tendermint-Vanilla-Deliver-Add} en el pasado existitó una operación
  $w.\<add>(e)$ en algún servidor $w$.
\end{proof}

Notemos que el \textbf{Lema 7} considera de la misma manera a los elementos de cliente como a los elementos
de prueba de época. Es decir, incluso un elemento de época de prueba de época $e'$ fue añadido mediante una llamada
a $w.\<add>(e')$ en algún servidor correcto $w$, donde el \textit{cliente} que invocó tal llamada fue el mismo proceso
que corre la ABCI correspondiente al servidor $w$.


\section{Prueba de correctitud para \compresschain}\label{sec:proof-compresschain}

\begin{lemma}
  La implementación \compresschain cumple la propiedad \textit{Consistent Sets}~\ref{api:consistent-set} de \setchain.
  %que establece que las épocas solo contienen elementos que provienen del conjunto de solo crecimiento.
\end{lemma}

\begin{proof}
  Esto es trivialmente correcto debido a que la
  construcción de $\THESET$ y de $\HISTORY$ se hace a partir de los mismos elementos, como se puede ver en las líneas
  \ref{line:abci-compresschain-the-set} y \ref{line:abci-compresschain-history} en el Algoritmo~\ref{alg:abci-brotli}.
\end{proof}

\begin{lemma}
  La implementación \compresschain cumple la propiedad \textit{Add-Get-Local}~\ref{api:history->theset-local} de \setchain.
  %que declara que todo elemento válido añadido a un
  %servidor correcto $v$ es eventualmente retornado en todas las llamadas futuras a $v$.\<get>.
\end{lemma}

\begin{proof}
  Sea $e$ un elemento válido y $v$ un servidor correcto, para los cuales un cliente invoca $v.\<add>(e)$.
  Por la propiedad \textit{Tendermint-Compresschain-Delivery}~\ref{tendermint:compresschain-delivery} sabemos que
  eventualmente $v$ recibirá una petición $\<DeliverTx>(t)$, en donde $t$ en un lote de elementos comprimidos
  y uno de esos elementos es $e$.
  Como se puede observar
  en la condición \texttt{if} de la línea ~\ref{line:abci-compresschain-if} en el Algoritmo~\ref{alg:abci-brotli},
  se analizan dos aspectos: que $e$ sea válido (lo cual se cumple por hipótesis)
  y que $e$ no forme parte de $\HISTORY$.
  Si el elemento a añadir ya es
  parte de $\HISTORY$ entonces necesariamente $e$ pertenece a $\THESET$ (ver propiedad anterior)
  y, por lo tanto, es retornado en todas la llamadas a $v$.\<get>.
  Por el contrario, si el elemento $e$ es nuevo, entonces será añadido a $\THESET$ como se indica en la
  línea ~\ref{line:abci-compresschain-the-set}, y retornado como parte de él en todas las futuras invocaciones a
  $v$.\<get>.
\end{proof}

\begin{lemma}
  La implementación \compresschain cumple la propiedad \textit{Get-Global}~\ref{api:history->theset} de \setchain.
  %que establece que los elementos presentes en un servidor correcto
  %son propagados a todos los servidores correctos.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e$ un elemento válido, tal que  $e \in v.\THESET$.
  Entonces, por construcción de $\THESET$, necesariamente $v$ en algún momento recibió una
  petición \<DeliverTx> para la transacción asociada al elemento $e$.
  Esto implica que el servidor decidió dicha transacción, puesto que la petición \<DeliverTx> se
  envía una vez que las transacciones fueron decididas y ordenadas.
  Luego, por la propiedad de \textit{Tendermint-Agreement}, todos los nodos correctos decidirán
  la misma transacción asociada al elemento $e$, y por tanto recibirán la petición \<DeliverTx>
  para ella, añadiéndo a $e$ a su conjunto $\THESET$, como se muestra en la línea
  \ref{line:abci-vanilla-set} en el Algoritmo~\ref{alg:abci-vanilla}.
\end{proof}


\section{Prueba de correctitud para \hashchain}\label{sec:proof-hashchain}
\begin{itemize}
  \item La \textit{Propiedad 1 (Consistent Sets)} de \setchain establece que las épocas solo contienen
  elementos que provienen del conjunto de solo crecimiento. Esto es trivialmente correcto debido a que la
  construcción de $\THESET$ y de $\HISTORY$ se hacen a partir de los mismos elementos (ver definición de
  \<reverse> y \<Query> en el Algoritmo~\ref{alg:abci-hash1} y ~\ref{alg:abci-hash2}).
\end{itemize}

\subsection{Otras cosas}
\begin{property}[Safety]\label{tendermint:safety}
  Si hay menos de 1/3 del poder de voto en manos bizantinas y al menos un validador correcto
  decide el bloque $B$, entonces ningún validador correcto decidirá un bloque distinto a $B$.
\end{property}

\begin{property}[Liveness]\label{tendermint:liveness}
  Si hay menos de 1/3 de poder de voto en manos bizantinas, luego el procolo de Tendermint
  no se bloquea (es decir, no hay \textit{deadlock}).
\end{property}

En el contexto de Tendermint, denotamos con \textit{n} el poder de voto total de los procesos
en el sistema, y asumimos una cota superior \textit{f} en el poder de voto total proveniente de
los procesos bizantinos.
%
El algoritmo de consenso de Tendermint asume que $n > 3f$, es decir, requiere que el poder de voto
en manos de procesos bizantinos sea menor a 1/3 del poder de voto total.
Por simplicidad, en ocasiones se considera $n = 3f + 1$.

Tendermint resuelve el problema de la replicación de máquinas de estados ejecutando instancias de
consenso secuencialmente para acordar cada bloque de transacciones que serán luego ejecutadas por el
servicio siendo replicado.
Se considera una variante del problema de consenso bizantino llamado \textit{Validity Predicate-based Byzantine consensus}
que es motivado por los sistemas de blockchain~\cite{Crain2017LeaderRandomizationSignaturefreeBC}.
El problema es definido por propiedades de acuerdo, terminación, y validés.

Esta variante del problema de consenso bizantino tiene un predicado específico a la aplicación
denotado \textit{valid()} que indica si un valor es válido. En el contexto de sistemas de blockchain, por ejemplo,
un valor no es válido si no contiene un hash apropiado del último bloque añadido a la blockchain.

\begin{property}[Agreement]\label{tendermint:agreement1}
  Dos procesos correctos nunca deciden valores distintos.
\end{property}

\begin{property}[Termination]\label{tendermint:termination1}
    Todos los procesos correctos deciden eventualmente un valor.
\end{property}

\begin{property}[Validity]\label{tendermint:validity}
    Un valor decidido es válido. Es decir, satisface el predicado predefinido
    denotado con \textit{valid}.
\end{property}
%

Las propiedades ~\ref{tendermint:safety} y ~\ref{tendermint:liveness} son demostradas en ~\cite{Kwon2014TendermintC}.
Las propiedades ~\ref{tendermint:agreement1}, ~\ref{tendermint:termination1} y ~\ref{tendermint:validity}
son demostradas en ~\cite{Buchman.2018.Tendermint}.

% En esta sección se introducen las propiedades que deben cumplir las implementaciones
% correctas de \setchain.
% La especificación dada asume que los clientes interactúan con servidores correctos,
% aunque en realidad los clientes no pueden estar seguros de que el servidor que están
% contactando no sea bizantino.
% Como ya fue mencionado anteriormente, las propiedades siempren razonan sobre los servidores
% correctos, dado que los servidores bizantinos no proveen ninguna garantía.
% %

% Empezamos requiriendo que en \setchain toda operación \<add> y \<get> ejecutada sobre un servidor
% correcto eventualmente termine.
% Se dice que un elemento $e$ está en la época $i$ en el historial $H$ (retornado por una invocación
% a \<get>) si $e \in H(i)$.
% Se dice que un elemento $i$ está en $H$ is existe una época $i$ tal que $e \in H(i)$.

% % ? Esta es la property que Marga indicó que falta en el preliminar de Setchain
% La primera propiedad establece que las épocas solo contienen elementos que provienen del conjunto
% de solo crecimiento.

% % 1. Cada elemento válido agregado en un servidor correcto eventualmente es retor-
% % nado en todas las futuras invocaciones a get hechas sobre servidores correctos.
% La segunda propiedad declara que todo elemento añadido a un servidor correcto es eventualmente
% retornado en todas las llamadas a \<get> futuras.

% % ?
% La siguiente propiedad establece que los elementos presentes es un servidor correcto son propagados
% a todos los servidores correctos.

% Se asume en el resto de este trabajo que en cualquier punto de tiempo hay un instante futuro en el
% cual una nueva época será generada. Esto es un supuesto razonable en cual escenario práctico.

% % 2. Todos los elementos válidos agregados en un servidor correcto deben eventual-
% % mente ser estampados con un número de época en todos los servidores correctos.
% La siguiente propiedad establece que todos los elementos añadidos son eventualmente estampados
% con un número de época.

% % ?
% La siguiente propiedad establece que un elemento puede estar en a lo sumo una época,
% y que ningún elemento puede estar en dos épocas diferentes incluso si los conjuntos historiales se
% obtienen de invocaciones \<get> a distintos servidores (ambos correctos).

% % 4. Dos servidores correctos cualesquieras están de acuerdo en el contenido de todas
% % las épocas que hayan sido computadas
% La siguiente propiedad establece que los servidores están de acuerdo en el contenido
% de las épocas.

% % 5. Cada elemento que se estampa con una época proviene del resultado de un cliente
% % añadiendo el elemento.
% Finalmente, se requiere que todo elemento in el historia provenga del resultado de un cliente
% añadiendo un elemento.


% Faltarían las siguientes propiedades
