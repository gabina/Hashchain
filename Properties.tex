\section{Objetivo del capítulo}
En este capítulo se exponen las pruebas de correctitud de los algoritmos presentados para
\vanilla, \compresschain, y \hashchain en el capítulo~\ref{chapter:sol}.
Es decir, se prueba que dichos algoritmos satisfacen las propiedades deseadas para una
implementación de \setchain introducidas en~\ref{subsubsec:setchain-properties}.

\section{Propiedades de Tendermint}\label{sec:properties}
Dado que todas las soluciones presentadas en este trabajo son construidas sobre Tendermint,
para probar la correctitud de ellas, será necesario recapitular las propiedades que la
plataforma Tendermint garantiza.

El modelo de Tendermint considera un sistema de procesos que se comunican mediante el intercambio de
mensajes.
Los procesos pueden ser correctos o defectuosos, donde un proceso defectuoso se comporta de maneras
arbitrarias. Es decir, se consideran procesos bizantinos.

Se asume que cada proceso tiene una cantidad determinada de \textit{poder de voto} (el poder de
voto de un proceso puede ser 0).
%
En el contexto de Tendermint, denotamos con \textit{n} el poder de voto total de los validadores
en el sistema, y asumimos una cota superior \textit{f} en el poder de voto total proveniente de
los validadores bizantinos.
%
El algoritmo de consenso de Tendermint asume que $n > 3f$, es decir, requiere que el poder de voto
en manos de validadores bizantinos sea menor a 1/3 del poder de voto total.
% We consider a system of processes that communicate by exchanging messages. Processes can be correct or
% faulty, where a faulty process can behave in an arbitrary way, i.e., we consider Byzantine faults. We assume
% that each process has some amount of voting power (voting power of a process can be 0). Processes in our
% model are not part of a single administrative domain; therefore we cannot enforce a direct network connectivity
% between all processes. Instead, we assume that each process is connected to a subset of processes called peers,
% such that there is an indirect communication channel between all correct processes. Communication between
% processes is established using a gossip protocol

Para lograr homogeneidad con el modelo de computación presentado en ~\ref{sec:model_system},
consideramos que el poder de voto de cada validador es igual a 1, y por lo tanto existen exactamente
$n$ procesos en total y $f$ procesos bizantinos.
 
\newcounter{prop:tendermint}
\setcounter{prop:tendermint}{\value{property}}

\begin{property}[Tendermint-Agreement]\label{tendermint:agreement}
  Dos procesos correctos nunca deciden valores distintos.
\end{property}

\begin{property}[Tendermint-Termination]\label{tendermint:termination}
    Todos los procesos correctos deciden eventualmente un valor.
\end{property}

Las propiedades ~\ref{tendermint:agreement} y ~\ref{tendermint:termination}
son demostradas en \cite{Buchman.2018.Tendermint}.

En el contexto de estas demostraciones
se asume una mempool de tamaño tal que nunca se satura.
Es decir, el ratio de invocaciones \<add> por parte de los clientes nunca
llena la capacidad de la mempool, de modo que los elementos enviados por clientes
nunca son descartados por mempool llena.
De aquí se desprenden las siguientes propiedades.

\begin{property}[Tendermint-Eventual-CheckTx]\label{tendermint:eventual-checktx}
  Sea $t$ una transacción.
  Si se invoca \<broadcastTx>($t$) sobre un servidor correcto $v$, luego
  $v$ recibirá la petición \<CheckTx>($t$).
\end{property}

\begin{property}[Tendermint-Eventual-Injection]\label{tendermint:eventual-injection}
  Sea $t$ una transacción en la mempool de un servidor correcto.
  Eventualmente, $t$ formará parte de un bloque.
\end{property}

\begin{property}[Tendermint-DeliverTx-BroadcastTx]\label{tendermint:delivery-broadcast}
  Sea $v$ un servidor correcto.
  Si $v$ recibe una petición $\<DeliverTx>(t)$,
  entonces necesariamente, en el pasado, 
  \<broadcastTx>($t$) fue invocado en algún servidor.
  % NOTA: acá no se puede asegurar que fue invocado en un servidor correcto,
  % ni tampoco que la transacción es válida.
\end{property}

A continuación se presenta una propiedad que desprende de la concepción de Tendermint
como máquina de replicación de estados.

\begin{property}[Tendermint-Global-DeliverTx]\label{tendermint:global-delivery}
  Si un servidor correcto $v$ recibe una petición $\<DeliverTx>(t)$, entonces todos
  los servidores correctos reciben la misma petición $\<DeliverTx>(t)$ eventualmente.
  Aún más, esta petición se hace en el mismo orden con respecto a otras
  peticiones $\<DeliverTx>$ en todos los servidores correctos.
\end{property}

\begin{proof}
  Si un servidor correcto $v$ recibe una petición $\<DeliverTx>(t)$ entonces, por definición
  de \<DeliverTx>, $t$ fue decidida como una transacción parte de un bloque.
  Por las propiedades \textbf{Tendermint-Agreement} y \textbf{Tendermint-Termination},
  podemos asegurar que todos los servidores correctos deciden a $t$ como
  parte del mismo bloque y, por lo tanto, todos recibirán la petición \<DeliverTx>($t$),
  incluso 
  en el mismo orden respecto a las otras peticiones \<DeliverTx> para el mismo bloque
  - ya que estas peticiones se
  realizan de forma asíncrona pero en orden, una vez que las transacciones dentro del bloque
  ya fueron decididas y ordenadas.
\end{proof}

% \begin{property}[Tendermint-Delivery-Mempool]\label{tendermint:delivery-mempool}
%   Sea $v$ un servidor correcto.
%   Si $v$ recibe una petición $\<DeliverTx>(t)$,
%   entonces necesariamente, en el pasado, $t$ formó parte de la mempool de un
%   servidor correcto y fue propuesto para formar parte de un bloque.
% \end{property}

% \begin{property}[Tendermint-Mempool-Broadcast]\label{tendermint:mempool-broadcast}
%   Sea $v$ un servidor correcto.
%   Si $t$ forma parte de la mempool de $v$, entonces necesariamente, en el pasado,
%   \<broadcastTx>($t$) fue invocado en algún servidor correcto y la petición
%   $\<CheckTx>(t)$ en $v$ retornó \texttt{true}.
% \end{property}

\subsection{Propiedades derivadas}

Con el objetivo de hacer las demostraciones más sencillas, se definen y demuestran las siguientes
propiedades derivadas para cada implementación realizada de \setchain.

\begin{property}[Tendermint-Vanilla-Delivery]\label{tendermint:vanilla-delivery}
  Sea $e$ un elemento válido y nuevo, y $v$ un servidor correcto.
  Luego de cada invocación
  $v.\<add>(e)$ por parte de un cliente, eventualmente se produce
  una petición $v.\<DeliverTx>(t)$, donde $t = e$.
  % Luego de cada invocación
  % $v.\<add>(e)$ por parte de un cliente, eventualmente se produce
  % una petición $\<DeliverTx>(t)$ en todos los servidores correctos, donde
  % $t = e$. Aún más, esta petición se hace en el mismo orden con respecto a otras
  % peticiones $\<DeliverTx>$ en todos los servidores correctos.
\end{property}

\begin{proof}
  Sea $e$ un elemento válido y nuevo, y $v$ un servidor correcto.
  Por definción de \<add> en el algoritmo \ref{alg:api-vanilla}, la invocación
  $v.\<add>(e)$ se traduce en la llamada \<broadcastTx>($t$) sobre el servidor $v$,
  donde $t = e$. Por la propiedad \emph{Tendermint-Eventual-CheckTx}~\ref{tendermint:eventual-checktx}, $v$
  recibirá eventualmente la petición \<CheckTx>($t$).
  Por hipótesis se tiene que $e$ es un elemento válido y nuevo, por lo cual, siendo $t = e$
  y considerando la definición de \<CheckTx> en la línea \ref{alg:van_check_tx} del algoritmo
  \ref{alg:abci-vanilla}, se deduce que la llamada a \<CheckTx>($t$) retornará \texttt{true}
  en $v$, por lo cual $t$ pasará a formar parte de la mempool de $v$.
  Luego, por la propiedad \emph{Tendermint-Eventual-Injection}~\ref{tendermint:eventual-injection} sabemos
  que la transacción $t$ formará parte de un bloque.
  Por definición de \<DeliverTx>, dado que $t$ es una transacción parte de un bloque,
  el servidor $v$ eventualmente recibirá una petición \<DeliverTx>($t$).
  % Por las propiedades \textbf{Tendermint-Agreement} y \textbf{Tendermint-Termination},
  % todos los servidores correctos estarán de acuerdo en que $t$ forma
  % parte de un bloque y, por lo tanto, todos recibirán la petición \<DeliverTx>($t$)
  % en el mismo orden respecto a las otras peticiones \<DeliverTx> - ya que estas peticiones se
  % realizan de forma asíncrona pero en orden, puesto que las transacciones dentro del bloque
  % ya fueron decididas y ordenadas al momento de hacerse.
\end{proof}

\begin{property}[Tendermint-Vanilla-Deliver-Add]\label{tendermint:vanilla-deliver-add}
  Sea $v$ un servidor correcto.
  Si $v$ recibe una petición $\<DeliverTx>(t)$, donde $t$ es una transacción válida,
  entonces necesariamente, en el pasado, un cliente invocó $\<add>(e)$ sobre un servidor,
  donde $e=t$.
  % NOTA: acá no se puede asegurar que fue invocado en un servidor correcto.
\end{property}

\begin{proof}
  Sea $v$ un servidor correcto que recibe una petición $\<DeliverTx>(t)$, donde $t$
  es una transacción válida.
  Por la propiedad \emph{Tendermint-DeliverTx-BroadcastTx}~\ref{tendermint:delivery-broadcast}
  sabemos que necesariamente, en el pasado, 
  \<broadcastTx>($t$) fue invocado en algún servidor.
  %
  Como $t$ es una transacción válida, el elemento $e = t$ también lo es.
  %
  Por el modelo de computación definido en la sección \ref{sec:model_system}, un nodo bizantino no
  puede generar un elemento válido.
  Por lo tanto, \<broadcastTx>($t$) tuvo que haber sido invocado por un nodo correcto.
  %
  Puesto que \<broadcastTx> solo se llama como parte de la definición de \<add>, con certeza
  un cliente invocó $\<add>(e)$ en dicho servidor, donde $e = t$.
  %NOTA: si el servidor no es correcto podría invocar \<broadcastTx>($t$) sin necesidad de
  %un cliente invocando add? No porque la transacción es válida.
\end{proof}

% \begin{property}[Tendermint-Eventual-Mempool]\label{tendermint:eventual-mempool}
%   Sea $t$ una transacción válida.
%   Si se invoca \<broadcastTx>($t$) sobre un servidor correcto, luego $t$ terminará
%   en la mempool de todos los servidores correctos.
% \end{property}

% \begin{proof}
%   Por la propiedad \textbf{Tendermint-Eventual-CheckTx} se tiene que todos los servidores
%   correctos reciben la petición \<CheckTx>($t$).
%   Dado que $t$ es una transacción válida, es decir, una transacción para la cual la evaluación
%   de \<CheckTx>($t$) es \texttt{true}, $t$ será añadida a la mempool de todos los servidores
%   correctos.
% \end{proof}


% \begin{property}[Tendermint-Eventual-DeliverTx]\label{tendermint:eventual-delivertx}
%   Sea $t$ una transacción en la mempool de un servidor correcto.
%   Eventualmente, todos los servidores correctos recibirán la petición \<DeliverTx>($t$)
%   (y en el mismo orden respecto a las otras peticiones \<DeliverTx>).
% \end{property}

% \begin{proof}
%   Por la propiedad \textbf{Tendermint-Eventual-Injection} se tiene que eventualmente
%   $t$ forma parte de un bloque.
%   Por las propiedades \textbf{Tendermint-Agreement} y \textbf{Tendermint-Termination},
%   todos los servidores correctos estarán de acuerdo en que $t$ forma
%   parte de un bloque y, por lo tanto, todos recibirán la petición \<DeliverTx>($t$)
%   en el mismo orden respecto a las otras peticiones \<DeliverTx> (ya que estas peticiones se
%   realizan de forma asíncrona pero en orden, puesto que las transacciones dentro del bloque
%   ya fueron decididas y ordenadas al momento de hacerse).
% \end{proof}

\begin{property}[Tendermint-Compresschain-Delivery]\label{tendermint:compresschain-delivery}
  Sea $e$ un elemento válido y nuevo, y $v$ un servidor correcto. Luego de cada invocación
  $v.\<add>(e)$ por parte de un cliente, eventualmente se produce
  una petición $v.\<DeliverTx>(t)$, en donde
  $t$ es un lote comprimido de elementos, y uno de esos elementos
  es $e$.
\end{property}

\begin{proof}
  Sea $e$ un elemento válido y nuevo, y $v$ un servidor correcto.
  Por definción de \<add> en el algoritmo \ref{alg:api-brotli}, la invocación
  $v.\<add>(e)$ se traduce en la llamada \texttt{CompressCollector.AddElement($e$)}.
  Como se puede observar en el algoritmo ~\ref{alg:collector-brotli}, dado que $e$ es válido,
  será codificado adecuadamente y añadido a un lote $t$ que eventualmente estará listo\footnote{Como
  se mencionó en la sección ~\ref{subsec:compresschain-algorithms},
  un lote se considera listo para ser enviado una vez que, o bien alcanza un tamaño
  máximo, o bien una cantidad razonable de tiempo transacurrió desde que el primer
  elemento llegó. Por este motivo podemos asegurar que todo lote eventualmente será
  considerado listo.} y se invocará \<broadcastTx>($t$) sobre el servidor $v$.
  Por la propiedad \emph{Tendermint-Eventual-CheckTx}~\ref{tendermint:eventual-checktx}, $v$
  recibirá eventualmente la petición \<CheckTx>($t$).
  Por hipótesis se tiene que $e$ es un elemento válido y nuevo, por lo cual, siendo $e$ un elemento de $t$
  y considerando la definición de \<CheckTx> en la línea \ref{alg:brotli_check_tx} del algoritmo
  \ref{alg:abci-brotli}, se deduce que la llamada a \<CheckTx>($t$) retornará \texttt{true}
  en $v$, por lo cual $t$ pasará a formar parte de la mempool de $v$.
  Luego, por la propiedad \emph{Tendermint-Eventual-Injection}~\ref{tendermint:eventual-injection} sabemos que la
  transacción $t$ formará parte de un bloque.
  Por definición de \<DeliverTx>, dado que $t$ es una transacción parte de un bloque,
  el servidor $v$ eventualmente recibirá una petición \<DeliverTx>($t$).
  % Por las propiedades \textbf{Tendermint-Agreement} y \textbf{Tendermint-Termination},
  % todos los servidores correctos estarán de acuerdo en que $t$ forma
  % parte de un bloque y, por lo tanto, todos recibirán la petición \<DeliverTx>($t$)
  % en el mismo orden respecto a las otras peticiones \<DeliverTx> - ya que estas peticiones se
  % realizan de forma asíncrona pero en orden, puesto que las transacciones dentro del bloque
  % ya fueron decididas y ordenadas al momento de hacerse.

  % NOTA: A $e$ le pedimos solo que sea válido?? O que sea válido y nuevo? VÁLIDO Y NUEVO.
\end{proof}

\begin{property}[Tendermint-Compresschain-Deliver-Add]\label{tendermint:compresschain-deliver-add}
  Sea $v$ un servidor correcto y $e$ un elemento válido.
  Sea $t$ un lote de elementos comprimidos, donde uno de esos elementos es $e$.
  Si $v$ recibe una petición $\<DeliverTx>(t)$,
  entonces necesariamente, en el pasado, un cliente invocó $\<add>(e)$ sobre un servidor.
  %NOTA: acá no se puede asegurar que fue invocado en un servidor correcto.
\end{property}

\begin{proof}
  Sea $v$ un servidor correcto que recibe una petición $\<DeliverTx>(t)$.
  Por la propiedad \emph{Tendermint-DeliverTx-BroadcastTx}~\ref{tendermint:delivery-broadcast}
  sabemos que necesariamente, en el pasado, 
  \<broadcastTx>($t$) fue invocado en algún servidor.
  Por el modelo de computación definido en la sección \ref{sec:model_system}, un nodo bizantino no
  puede generar un elemento válido.
  Por lo tanto, el lote de elementos $t$ difundido en la red de Tendemrint tuvo que haberse generado
  con al menos un elemento generado por un cliente, puesto que $e$ es válido.
  De ahí se concluye que un cliente tiene que haber invocado $\<add>(e)$ en un servidor y que
  \<broadcastTx> se invocó como parte de la definición de \<AddElement> una vez que el lote estuvo listo,
  como se puede ver en la línea \ref{line:compresschain-broadcast} del
  algoritmo ~\ref{alg:collector-brotli}.

  % Si \<broadcastTx>($t$) fue invocado, entonces con certeza el lote de elementos comprimido $t$
  % fue construido por el \collector a partir de elementos añadidos al mismo.
  % En particular, un cliente tiene que haber invocado
  % $\<add>(e)$ en un servidor - puesto que \<broadcastTx> solo
  % se llama como parte de la definición de \<AddElement> cuando un lote está listo,
  % como se puede ver en la línea \ref{line:compresschain-broadcast} del
  % algoritmo ~\ref{alg:collector-brotli}.

  % NOTA: si el servidor no es correcto podría invocar \<broadcastTx>($t$) sin necesidad de
  % un cliente invocando add? No, porque contiene un elemento válido y los elementos válidos no pueden
  % ser generados por nodos bizantinos.
\end{proof}

\begin{property}[Tendermint-Haschain-Delivery]\label{tendermint:hashchain-delivery}
  VER SI LA NECESITO
  Sea $e$ un elemento válido y $v$ un servidor correcto. Luego de cada invocación
  $v.\<add>(e)$ por parte de un cliente, eventualmente se produce
  una petición $v.\<DeliverTx>(t)$, en donde
  $t$ es una tupla $(h, s)$, siendo
  \begin{itemize}
    \item $h$ un lote hasheado de elementos, donde uno de esos elementos es $e$,
    \item y $s$ una firma válida de dicho hash realizada con la clave privada de $v$.
  \end{itemize}
 
\end{property}

\begin{proof}
  Sea $e$ un elemento válido y $v$ un servidor correcto.
  Por definción de \<add> en el algoritmo \ref{alg:api-hashchain}, la invocación
  $v.\<add>(e)$ se traduce en la llamada \texttt{HashCollector.AddElement($e$)}.
  Como se puede observar en el algoritmo ~\ref{alg:collector-hash}, $e$ será codificado
  adecuadamente y añadido a un lote que eventualmente estará listo, se hasheará,
  se firmará, y se invocará \<broadcastTx>($t$) sobre el servidor $v$, en donde $t$
  será una tupla conformada por el hash y la firma.

  Por la propiedad \textbf{Tendermint-Eventual-CheckTx}, $v$
  recibirá eventualmente la petición \<CheckTx>($t$).
  Considerando que la firma es válida (acá se podría justificar con un poco de más detalle),
  la llamada a \<CheckTx>($t$) retornará \texttt{true}
  en $v$, por lo cual $t$ pasará a formar parte de la mempool de $v$.

  Luego, por la propiedad \textbf{Tendermint-Eventual-Injection} sabemos que la
  transacción $t$ formará parte de un bloque.
  Por definición de \<DeliverTx>, dado que $t$ es una transacción parte de un bloque,
  el servidor $v$ eventualmente recibirá una petición \<DeliverTx>($t$).

  NOTA: A $e$ le pedimos solo que sea válido?? O que sea válido y nuevo?? Por ahora, únicamente válido.
\end{proof}

\begin{property}[Tendermint-Haschain-Eventual-Consolidation]\label{tendermint:hashchain-eventual-consolidation}
  Sea $e$ un elemento válido y $v$ un servidor correcto. Si un cliente invoca
  $v.\<add>(e)$, eventualmente un hash proveniente de un lote que contiene a $e$ consolidará.
\end{property}

\begin{proof}
  Sea $e$ un elemento válido y $v$ un servidor correcto.
  Si un cliente invoca $v.\<add>(e)$, sabemos por la propiedad \textit{Tendermint-Haschain-Delivery} que,
  eventualmente $v$ recibirá la petición $\<DeliverTx>(t)$, en donde
  $t$ es una tupla $(h, s)$, siendo
  \begin{itemize}
    \item $h$ un lote hasheado de elementos, donde uno de esos elementos es $e$,
    \item y $s$ una firma válida de dicho hash realizada con la clave privada de $v$.
  \end{itemize}
  Por la propiedad \textit{Tendermint-Global-DeliverTx}, sabemos que todos los nodos correctos
  recibirán eventualmente la misma petición $\<DeliverTx>(t)$.

  Sea $w$ un nodo correcto que recibe $\<DeliverTx>(t)$. Como lo indica la definición presentada en el algoritmo,
  $w$ chequeará que $s$ sea una firma válida (lo cual es) y luego sumará la nueva firma a las firmas para el hash $h$.
  Seguido de esto, si $w$ no conoce aún el reverso de $h$, entonces lanzará una acción asíncrona para revertirlo.
  Si $w$ ya conoce el reverso de $h$ es porque ya invocó al proceso de inversión de hashes previamente.

  Supongamos que $w$ no conoce el reverso de $h$. Como se puede ver en la definición de \<reverse>,
  $w$ se conectará con su propio \hcollector para obtener el lote asociado
  a $h$. Con seguridad obtendrá el reverso puesto que su \hcollector se comunicará con el \hcollector de $v$ (que es correcto
  por hipótesis y conoce el reverso de $h$) porque $s$ es una firma asociada a $v$. EL \hcollector de $v$ ejecutará \<Reverse>
  del algoritmo ~\ref{alg:collector-hash}, obteniendo el lote desde su base de datos y devolviéndolo.

  Siguiendo la definición de \<DeliverTx> en $w$, una vez que obtiene el lote asociado a $h$, firmará $h$ con su propia clave privada
  y lo difundirá como una nueva transacción,
  lo cual hará que eventualmente llegue una nueva petición $\<DeliverTx>(t')$, donde $t' = (h, s')$, siendo $s'$ la firma generada
  con la clave privada de $w$.

  Dado que este proceso se repetirá para todo servidor correcto, y considerando que \SPH es menor o igual a la cantidad de nodos
  correctos, con certeza $h$ obtendrá las \SPH firmas y, por lo tanto, consolidará.
\end{proof}

\section{Prueba de correctitud para \vanilla}\label{sec:proof-vanilla}

Muchas propiedades de \setchain razonan sobre el resultado $(S, H, h)$ de una invocación
a $v.\<get>$ sobre un servidor $v$.
%
Siendo que en \vanilla \<get> se limita a retornar los valores actuales de $v.\THESET$, $v.\HISTORY$ y $v.\EPOCH$,
en las demostraciones se razonará directamente sobre la construcción de ellos, omitiendo la invocación
a \<get>.

\newcounter{lemma:vanilla}
\setcounter{lemma:vanilla}{\value{lemma}}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Consistent Sets}~\ref{api:consistent-set} de \setchain,
  que establece que las épocas solo contienen elementos que provienen del conjunto de solo crecimiento.
\end{lemma}

\begin{proof}
  Esto es trivialmente correcto debido a que la
  construcción de $\THESET$ y de $\HISTORY$ se hace a partir de los mismos elementos, como se puede ver en las líneas
  \ref{line:abci-vanilla-set} y \ref{line:abci-vanilla-history} en el Algoritmo~\ref{alg:abci-vanilla}.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Add-Get-Local}~\ref{api:history->theset-local} de \setchain,
  que declara que todo elemento válido añadido a un
  servidor correcto $v$ es eventualmente retornado en todas las llamadas futuras a $v$.\<get>.
\end{lemma}

\begin{proof}
  Sea $e \in $ \(V\) y $v$ un servidor correcto, para los cuales un cliente invoca $v.\<add>(e)$.
  Como $e \in $ \(V\), sabemos que $e$ es válido.
  Si $e$ no es nuevo, entonces $e \in v.\THESET$ y la demostración es trivial.
  Si $e$ es nuevo, por la propiedad Tendermint-Vanilla-Delivery~\ref{tendermint:vanilla-delivery}
  \ sabemos que
  eventualmente $v$ recibirá una petición $\<DeliverTx>(t)$, en donde $t = e$.
  Como se puede observar
  en la condición \texttt{if} de la línea~\ref{line:abci-vanilla-if} y en la definición de \texttt{isValidTransaction}
  en el Algoritmo~\ref{alg:abci-vanilla},
  se analizan dos aspectos: que $e$ sea válido
  y que $e$ no forme parte de $v.\HISTORY$.
  Ambas condiciones se cumplen por hipótesis.
  % Si el elemento a añadir ya es
  % parte de $\HISTORY$ entonces necesariamente $e$ pertenece a $\THESET$ (ver propiedad anterior)
  % y, por lo tanto, es retornado en todas la llamadas a $v$.\<get>.
  % Por el contrario, si el elemento $e$ es nuevo, entonces
  Por lo tanto, $e$ será añadido a $v.\THESET$ como se indica en la
  línea ~\ref{line:abci-vanilla-set}, y retornado como parte de él en todas las futuras invocaciones a
  $v$.\<get>.
\end{proof}

\begin{lemma}\label{proof:get-global}
  La implementación \vanilla cumple la propiedad \textit{Get-Global}~\ref{api:history->theset} de \setchain,
  que establece que los elementos presentes en un servidor correcto
  son propagados a todos los servidores correctos.
\end{lemma}

\begin{proof}
  Sean $v$ y $w$ dos servidores correctos y $e \in $ \(U\), tal que  $e \in v.\THESET$.
  Debemos probar que eventualmente se cumplirá $e \in w.\THESET$.
  Si $e \in v.\THESET$, entonces, por construcción de $\THESET$, necesariamente $v$ en algún momento recibió una
  petición \<DeliverTx>($t$), donde $t = e$.
  Si un servidor correcto recibe una petición \<DeliverTx>($t$), por la propiedad
  \emph{Tendermint-Global-DeliverTx}~\ref{tendermint:global-delivery}
  \ todos los
  servidores correctos, y en particular $w$, reciben dicha petición \<DeliverTx>($t$).
  Dado que $e$ es válido por hipótesis, se tienen dos opciones: o bien $e$ es parte de $w.\HISTORY$,
  en cuyo caso ya se cumple $e \in w.\THESET$ (ver propiedad anterior), o bien $e$ es un elemento nuevo.
  En este último caso,
  $e$ será añadido a
  $w.\THESET$, como se muestra en la línea~\ref{line:abci-vanilla-set} en el Algoritmo~\ref{alg:abci-vanilla}.
  Por lo tanto, eventualmente se cumplirá $e \in w.\THESET$.

  % Si un servidor correcto recibe una petición \<DeliverTx>($t$), por la propiedad
  % \textbf{Tendermint-Global-DeliverTx}
  % todos los
  % servidores correctos, y en particular $w$, reciben dicha petición \<DeliverTx>($t$),
  % añadiéndo a $e$ a su conjunto
  % $\THESET$, como se muestra en la línea


  % Esto implica que el servidor decidió dicha transacción, puesto que la petición \<DeliverTx> se
  % envía una vez que las transacciones fueron decididas y ordenadas.
  % Luego, por la propiedad de \textit{Tendermint-Agreement}, todos los nodos correctos decidirán
  % la misma transacción asociada al elemento $e$, y por tanto recibirán la petición \<DeliverTx>
  % para ella, añadiéndo a $e$ a su conjunto $\THESET$, como se muestra en la línea
  % \ref{line:abci-vanilla-set} en el Algoritmo~\ref{alg:abci-vanilla}.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Eventual-Get}~\ref{api:theset->history}
  de \setchain, que establece que todos los elementos añadidos son eventualmente estampados
  con un número de época.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e \in U$. Si $e \in v.\THESET$, entonces por construcción de
  $\THESET$, necesariamente $v$ en algún momento recibió una
  petición \<DeliverTx>($t$), donde $t = e$.
  Como se puede ver en las líneas ~\ref{line:abci-vanilla-set} y ~\ref{line:abci-vanilla-history} en
  el Algoritmo~\ref{alg:abci-vanilla}, inmediatamente después de agregar un elemento a $v.\THESET$,
  el elemento se agrega a $v.\HISTORY$. Por lo tanto, con seguridad, el elemento $e$ será eventualmente
  agregado a $v.\HISTORY$ y, por lo tanto, estampado con un número de época.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Unique Epoch}~\ref{api:local_unique_stamp} de \setchain,
  que establece que un elemento puede estar en a lo sumo una época.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto e ${i,i'\leq v.\EPOCH}$ con ${i\neq i'}$.
  Queremos probar que $v.\HISTORY(i)\cap{}v.\HISTORY(i')=\emptyset$.
  %

  La demostración se hará por el absurdo.
  Sin pérdida de generalidad, suponemos que ${i < i'}$. Sea $e$ un elemento $\in v.\HISTORY(i)$ .
  Por lo tanto, $e$ fue estampado con el número de época $i$.
  %
  Suponemos ahora que también se cumple $e \in v.\HISTORY(i')$. Es decir, 
  $e$ fue estampado con el número de época $i'$.
  Para que $e$ también haya sido añadido a la época $i'$, necesariamente debe haber llegado
  una petición \<DeliverTx> para la transacción asociada al elemento $e$ que, al procesarse,
  incluyó a $e$ como parte de $v.\HISTORY(i')$.
  Por construcción, esto necesariamente debe haber pasado en la línea
  \ref{line:abci-vanilla-history} en el Algoritmo~\ref{alg:abci-vanilla},
  con lo cual se concluye que la condición del \texttt{if} de
  la línea ~\ref{line:abci-vanilla-if} evaluó a \texttt{true} (*)
  (ya que de otro modo, el elemento no hubiese sido añadido).
  %

  Dado que ${i < i'}$, y las peticiones se hacen ordenadamente, al momento de la
  petición \<DeliverTx> mencionada anteriormente, la época $i$ ya fue construida,
  y por lo tanto se tiene
  $e \in v.\HISTORY(i)$.
  Por este motivo, al procesar dicha petición \<DeliverTx>, la condición \texttt{if} de
  la línea ~\ref{line:abci-vanilla-if} evaluará a \texttt{false}, dado que 
  \texttt{not} $e$ \texttt{in} $v.\HISTORY$ es falso, puesto que $e \in v.\HISTORY(i)$ .
  Esto lleva a una contradicción por (*).
  La contradicción proviene de suponer que $e \in v.\HISTORY(i')$.
  Por lo tanto, se concluye que $e \not\in v.\HISTORY(i')$. Luego se tiene
  $v.\HISTORY(i)\cap{}v.\HISTORY(i')=\emptyset$.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \textit{Consistent Gets}~\ref{api:consistent-gets} de \setchain,
  que establece que los servidores están de acuerdo en el contenido
  de las épocas.
\end{lemma}

\begin{proof}
  Sean $v$ y $w$ dos servidores correctos, e $i\leq \min(v.\EPOCH, w.\EPOCH)$.
  Queremos probar que $v.\HISTORY(i)=w.\HISTORY(i)$.

  Se seguirá un razonamiento similar al presentado en la demostración del
  Lema ~\ref{proof:get-global}.
  Sea $e$ un elemento $\in v.\HISTORY(i)$. 
  Por construcción de $\HISTORY$, necesariamente $v$ en un momento determinado recibió una
  petición \<DeliverTx>($t$), donde $t = e$, lo cual
  produjo que $e$ fuera estampado con el número de época $i$.
  % Esto implica que el servidor decidió dicha transacción, puesto que la petición \<DeliverTx> se
  % envía una vez que las transacciones fueron decididas y ordenadas.
  % Luego, por la propiedad de \textit{Tendermint-Agreement}, todos los nodos correctos y, en particular $w$,
  % deciden la misma transacción asociada al elemento $e$ (en el mismo orden que $v$).
  Por la propiedad \emph{Tendermint-Global-DeliverTx}~\ref{tendermint:global-delivery} \ podemos
  asegurar que todos los servidores correctos,
  y en particular $w$, reciben la petición \<DeliverTx>($t$) en el mismo orden en que lo hace $v$, es decir,
  durante la construcción de la época $i$, añadiendo a $e$ a $w.\HISTORY(i)$, como se muestra en la línea
  \ref{line:abci-vanilla-history} en el Algoritmo~\ref{alg:abci-vanilla}.
  El mismo razonamiento se puede hacer para un elemento $e \in w.\HISTORY(i)$.
  Luego, $v.\HISTORY(i)=w.\HISTORY(i)$.
\end{proof}

\begin{lemma}\label{lemma:vanilla-add-before-get}
  La implementación \vanilla cumple la propiedad \textit{Add-before-Get}~\ref{api:get->add} de \setchain,
  que determina que todo elemento en $\THESET$ proviene del resultado de un cliente
  añadiendo un elemento.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e \in \THESET$. Por construcción de $\THESET$,
  necesariamente $v$ en algún momento recibió una
  petición $\<DeliverTx>(t)$, donde $t = e$, y $t$ es una transacción válida.
  Luego, por la propiedad \textit{Tendermint-Vanilla-Deliver-Add}~\ref{tendermint:vanilla-deliver-add}
  en el pasado existitó una operación
  $w.\<add>(e)$ en algún servidor $w$.
\end{proof}

Notemos que el Lema ~\ref{lemma:vanilla-add-before-get} considera de la misma manera a los elementos de cliente como a los elementos
de prueba de época. Es decir, incluso un elemento de prueba de época $e'$ fue añadido mediante una llamada
a $w.\<add>(e')$ en algún servidor correcto $w$, donde el \textit{cliente} que invocó tal llamada fue el mismo proceso
que corre la ABCI correspondiente al servidor $w$.


\section{Prueba de correctitud para \compresschain}\label{sec:proof-compresschain}

\begin{lemma}
  La implementación \compresschain cumple la propiedad \textit{Consistent Sets}~\ref{api:consistent-set} de \setchain.
  %que establece que las épocas solo contienen elementos que provienen del conjunto de solo crecimiento.
\end{lemma}

\begin{proof}
  Esto es trivialmente correcto debido a que la
  construcción de $\THESET$ y de $\HISTORY$ se hace a partir de los mismos elementos, como se puede ver en las líneas
  \ref{line:abci-compresschain-the-set} y \ref{line:abci-compresschain-history} en el Algoritmo~\ref{alg:abci-brotli}.
\end{proof}

\begin{lemma}
  La implementación \compresschain cumple la propiedad \textit{Add-Get-Local}~\ref{api:history->theset-local} de \setchain.
  %que declara que todo elemento válido añadido a un
  %servidor correcto $v$ es eventualmente retornado en todas las llamadas futuras a $v$.\<get>.
\end{lemma}

\begin{proof}
  Sea $e \in $ \(V\) y $v$ un servidor correcto, para los cuales un cliente invoca $v.\<add>(e)$.
  Como $e \in $ \(V\), sabemos que $e$ es válido.
  Si $e$ no es nuevo, entonces $e \in v.\THESET$ y la demostración es trivial.
  Si $e$ es nuevo, por la propiedad \textit{Tendermint-Compresschain-Delivery}~\ref{tendermint:compresschain-delivery} sabemos que
  eventualmente $v$ recibirá una petición $\<DeliverTx>(t)$, donde $t$ es un lote de elementos comprimidos
  y uno de esos elementos es $e$.
  Como se puede observar
  en la condición \texttt{if} de la línea ~\ref{line:abci-compresschain-if} en el Algoritmo~\ref{alg:abci-brotli},
  se analizan dos aspectos: que $e$ sea válido
  y que $e$ no forme parte de $\HISTORY$. Ambas condiciones se cumplen por hipótesis.
  Por lo tanto, $e$ será añadido a $\THESET$ como se indica en la
  línea ~\ref{line:abci-compresschain-the-set}, y retornado como parte de él en todas las futuras invocaciones a
  $v$.\<get>.
\end{proof}

\begin{lemma}
  La implementación \compresschain cumple la propiedad \textit{Get-Global}~\ref{api:history->theset} de \setchain.
  %que establece que los elementos presentes en un servidor correcto
  %son propagados a todos los servidores correctos.
\end{lemma}

\begin{proof}
  Sean $v$ y $w$ dos servidores correctos y $e$ un elemento válido, tal que  $e \in v.\THESET$.
  Debemos probar que eventualmente se cumplirá $e \in w.\THESET$.
  Si $e \in v.\THESET$, entonces, por construcción de $\THESET$, necesariamente $v$ en algún momento recibió una
  petición \<DeliverTx>($t$), donde $t$ es un lote comprimido de elementos, y uno de esos elementos
  es $e$.
  Si un servidor correcto recibe una petición \<DeliverTx>($t$), por la propiedad
  \textbf{Tendermint-Global-DeliverTx}
  todos los
  servidores correctos, y en particular $w$, reciben dicha petición \<DeliverTx>($t$).
  Dado que $e$ es válido por hipótesis, se tienen dos opciones: o bien $e$ es parte de $w.\HISTORY$,
  en cuyo caso ya se cumple $e \in w.\THESET$ (ver propiedad anterior), o bien $e$ es un elemento nuevo.
  En este último caso,
  $e$ será añadido a
  $w.\THESET$, como se muestra en la línea
  \ref{line:abci-compresschain-the-set} en el Algoritmo~\ref{alg:abci-brotli}.
  Por lo tanto, se cumplirá eventualmente $e \in w.\THESET$.
\end{proof}

\begin{lemma}
  La implementación \compresschain cumple la propiedad \textit{Eventual-Get}~\ref{api:theset->history}
  de \setchain.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e \in U$. Si $e \in v.\THESET$, entonces por construcción de
  $\THESET$, necesariamente $v$ en algún momento recibió una
  petición \<DeliverTx>($t$), donde $t$ es un lote comprimido de elementos, y uno de esos elementos
  es $e$.
  Como se puede ver en la definición de \<DeliverTx> y en las líneas \ref{line:abci-compresschain-the-set}
  y \ref{line:abci-compresschain-history} de \texttt{newEpoch} en
  el Algoritmo~\ref{alg:abci-brotli}, inmediatamente después de agregar un elemento a $\THESET$,
  el elemento se agrega a $\HISTORY$. Por lo tanto, con seguridad, el elemento $e$ será eventualmente
  agregado a $v.\HISTORY$ y, por lo tanto, estampado con un número de época.
\end{proof}

\begin{lemma}
  La implementación \compresschain cumple la propiedad \textit{Unique Epoch}~\ref{api:local_unique_stamp} de \setchain.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto e ${i,i'\leq v.\EPOCH}$ con ${i\neq i'}$.
  Queremos probar que $v.\HISTORY(i)\cap{}v.\HISTORY(i')=\emptyset$.
  %

  La demostración se hará por el absurdo.
  Sin pérdida de generalidad, suponemos que ${i < i'}$. Sea $e$ un elemento $\in \HISTORY(i)$ .
  Por lo tanto, $e$ fue estampado con el número de época $i$.
  %
  Suponemos ahora que también se cumple $e \in \HISTORY(i')$. Es decir, 
  $e$ fue estampado con el número de época $i'$.
  Para que $e$ también haya sido añadido a la época $i'$, necesariamente debe haber llegado
  una petición \<DeliverTx>$(t)$, donde $t$ es un lote comprimido de elementos, y uno de esos
  elementos es $e$. Al procesarse dicha transacción, se debe haber
  incluido a $e$ como parte de $\HISTORY(i')$.
  %
  Por construcción, esto necesariamente debe haber pasado en la línea
  \ref{line:abci-compresschain-history} en el Algoritmo~\ref{alg:abci-brotli},
  con lo cual se concluye que la condición del \texttt{if} de
  la línea ~\ref{line:abci-compresschain-if} evaluó a \texttt{true} (*)
  (ya que de otro modo, el elemento no hubiese sido añadido).
  %

  Dado que ${i < i'}$, y las peticiones se hacen ordenadamente, al momento de la
  petición \<DeliverTx>$(t)$, la época $i$ ya fue construida, y por lo tanto se tiene
  $e \in \HISTORY(i)$.
  Por este motivo, al procesar la petición \<DeliverTx>$(t)$, la condición \texttt{if} de
  la línea ~\ref{line:abci-compresschain-if} evaluará a \texttt{false}, dado que 
  \texttt{not} $e$ \texttt{in} $\HISTORY$ es falso, puesto que $e \in \HISTORY(i)$.
  Esto lleva a una contradicción por (*).
  La contradicción proviene de suponer que $e \in \HISTORY(i')$.
  Por lo tanto, se concluye que $e \not\in \HISTORY(i')$. Esto vale para cualquier elemento $e$.
  Luego se tiene $\HISTORY(i)\cap{}\HISTORY(i')=\emptyset$.
\end{proof}

\begin{lemma}
  La implementación \compresschain cumple la propiedad \textit{Consistent Gets}~\ref{api:consistent-gets} de \setchain.
\end{lemma}

\begin{proof}
  Sean $v$ y $w$ dos servidores correctos, e $i\leq \min(v.\EPOCH, w.\EPOCH)$.
  Queremos probar que $v.\HISTORY(i)=w.\HISTORY(i)$.

  Se seguirá un razonamiento similar al presentado en la demostración del
  \textbf{Lema ~\ref{proof:get-global}}.
  Sea $e$ un elemento $\in v.\HISTORY(i)$. 
  Por construcción de $\HISTORY$, necesariamente $v$ en un momento determinado recibió una
  petición \<DeliverTx>($t$), donde $t$ es un lote comprimido de elementos, y uno de esos
  elementos es $e$. Como consecuencia de esta petición,
  $e$ fue estampado con el número de época $i$.
  % Esto implica que el servidor decidió dicha transacción, puesto que la petición \<DeliverTx> se
  % envía una vez que las transacciones fueron decididas y ordenadas.
  % Luego, por la propiedad de \textit{Tendermint-Agreement}, todos los nodos correctos y, en particular $w$,
  % deciden la misma transacción asociada al elemento $e$ (en el mismo orden que $v$).
  Por la propiedad \textbf{Tendermint-Global-DeliverTx} podemos asegurar que todos los servidores correctos,
  y en particular $w$, reciben la petición \<DeliverTx>($t$) en el mismo orden en que lo hace $v$, es decir,
  durante la construcción de la época $i$, añadiendo a $e$ a $w.\HISTORY(i)$, como se muestra en la línea
  \ref{line:abci-compresschain-history} en el Algoritmo~\ref{alg:abci-brotli}.
\end{proof}

\begin{lemma}
  La implementación \compresschain cumple la propiedad \textit{Add-before-Get}~\ref{api:get->add} de \setchain.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e \in \THESET$. Por construcción de $\THESET$,
  necesariamente $e$ es un elemento válido, y $v$ en algún momento recibió una
  petición \<DeliverTx>$(t)$, donde $t$ es un lote comprimido de elementos, y uno de esos
  elementos es $e$.
  Luego, por la propiedad \textit{Tendermint-Compresschain-Deliver-Add} en el pasado existitó una operación
  $w.\<add>(e)$ en algún servidor $w$.
\end{proof}

\section{Prueba de correctitud para \hashchain}\label{sec:proof-hashchain}

\begin{lemma}
  La implementación \hashchain cumple la propiedad \textit{Consistent Sets}~\ref{api:consistent-set} de \setchain.
  %que establece que las épocas solo contienen elementos que provienen del conjunto de solo crecimiento.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto sobre el que se invoca $v.\<get>$.
  Por definición de \<get> en el Algoritmo~\ref{alg:api-hashchain}, esto se traduce como una llamada a
  \<Query> en el Algoritmo~\ref{alg:abci-hash1}.
  Sea $(\THESET, \HISTORY, \EPOCH)$ el resultado de dicha invocación.
  Queremos probar que para todo $i \leq \EPOCH, \HISTORY(i) \subseteq \THESET$.
  Sea $e$ un elemento $\in \HISTORY(i)$ para algún $i \leq \EPOCH$.
  Por construcción de \HISTORY, $e$ fue necesariamente agregado en la línea \ref{line:abci-hashchain-history}
  como parte de la ejecución de \<Query>.
  Se deduce entonces que $e$ es un elemento válido proveniente de un lote asociado al hash correspondiente a
  la época $i$.

  Dado que la variable \texttt{hash\_to\_batch} solo se modifica en la línea \ref{line:abci-hashchain-hash-to-batch} como
  parte de \<reverse>, se concluye que dicho código tiene que haber sido ejecutado previamente, lo cual implica también que
  $e$ fue añadido a \THESET con anterioridad.
  Por lo tanto, se tiene $e \in \THESET$, concluyendo que $\HISTORY(i) \subseteq \THESET$ para todo $i \leq \EPOCH$.
  % Esto es trivialmente correcto debido a que la
  % construcción de $\THESET$ y de $\HISTORY$ se hacen a partir de los mismos elementos (ver definición de
  % \<reverse> y \<Query> en el Algoritmo~\ref{alg:abci-hash1} y ~\ref{alg:abci-hash2}).
\end{proof}

\begin{lemma}
  La implementación \hashchain cumple la propiedad \textit{Add-Get-Local}~\ref{api:history->theset-local} de \setchain.
  %que declara que todo elemento válido añadido a un
  %servidor correcto $v$ es eventualmente retornado en todas las llamadas futuras a $v$.\<get>.
\end{lemma}

\begin{proof}
  Sea $e$ un elemento válido y $v$ un servidor correcto, para los cuales un cliente invoca $v.\<add>(e)$.
  Por definción de \<add> en el algoritmo \ref{alg:api-hashchain}, la invocación
  $v.\<add>(e)$ se traduce en la llamada \texttt{HashCollector.AddElement($e$)}.
  Como se puede observar en el algoritmo ~\ref{alg:collector-hash}, $e$ será codificado
  adecuadamente y añadido a un lote que eventualmente estará listo, se hasheará,
  se firmará, y se invocará \<broadcastTx>($t$) sobre el servidor $v$, en donde $t = (h, s)$
  será una tupla conformada por el hash del lote que contiene a $e$
  y una firma válida para el mismo. A su vez, la correspondencia entre el hash y el lote
  será añadido a una base de datos local.

  Por la propiedad \textit{Tendermint-Eventual-CheckTx}, $v$
  recibirá eventualmente la petición \<CheckTx>($t$).
  Considerando que la firma $s$ es válida por hipótesis, luego se abren dos casos:
  que el lote asociado a $h$ ya sea conocido o no.

  Si \texttt{hash\_to\_batch[h]} ya existe, entonces con certeza previamente
  fue recibido el mismo hash, revertido, y añadido a \texttt{hash\_to\_batch}.
  Esto únicamente se hace como parte de \<reverse>, en donde, como se puede ver en la línea
  \ref{line:abci-hashchain-the-set}, $e$ tuvo que haber sido añadido a \THESET,
  puesto que es un elemento válido por hipótesis.

  Si, por el contrario, \texttt{hash\_to\_batch[h]} no existe, entonces se invocará
  a \<reverse>.
  De este modo, se comunicará con su propio \hcollector para revertir el hash.
  Con seguridad, el \hcollector tendrá el lote asociado a dicho hash en su base de datos local
  y lo retornará, de manera que el elemento $e$ (parte del lote) será añadido a \THESET
  de acuerdo a la línea \ref{line:abci-hashchain-the-set}.

  Por lo tanto, todas las invocaciones a $v.\<get>$ eventualmente tendrán al elemento $e$
  como parte de \THESET.
\end{proof}

\begin{lemma}
  La implementación \hashchain cumple la propiedad \textit{Get-Global}~\ref{api:history->theset} de \setchain.
  %que establece que los elementos presentes en un servidor correcto
  %son propagados a todos los servidores correctos.
\end{lemma}

\begin{proof}
  Sean $v$ y $w$ dos servidores correctos y $e$ un elemento válido, tal que  $e \in v.\THESET$.
  Debemos probar que eventualmente se cumplirá $e \in w.\THESET$.
  Si $e \in v.\THESET$, entonces, por construcción de $\THESET$, necesariamente $v$ en algún momento
  ejecutó \<reverse>, revirtió $h$ correctamente y, como consecuencia,
  añadió a $e$ a \THESET (ver línea \ref{line:abci-hashchain-the-set}).

  La función \<reverse> puede ser invocada como consecuencia de una petición \<CheckTx> o como consecuencia
  de una petición \<DeliverTx>.
  Si proviene de la ejecución de \<CheckTx>, entonces como se muestra en la línea \ref{line:spawn-reverse-checktx}
  de su definición, inmediatamente después de lanzar una llamada asíncrona a \<reverse>, la petición retornó
  \texttt{True}.
  Como consecuencia de esto, la transacción en cuestión (llamémosla $t = (h,s)$) fue añadida a la mempool de $v$ y,
  por el lema \textit{Tendermint-Eventual-Injection} sabemos que eventualmente $v$ recibirá una petición $\<DeliverTx>(t)$.
  Aún más, por el lema todos los servidores correctos recibirán $\<DeliverTx>(t)$.

  Por lo tanto, podemos concluir que todos los servidores correctos y, en particular $w$, recibirán la petición $\<DeliverTx>(t)$.
  Como consecuencia de esta ejecutarán \<reverse> (si es que ya no lo hicieron) añadiendo a $e$ a \THESET. 
\end{proof}

\begin{lemma}
  La implementación \hashchain cumple la propiedad \textit{Eventual-Get}~\ref{api:theset->history}
  de \setchain.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e \in U$. Si $e \in v.\THESET$, entonces por construcción de
  $\THESET$, necesariamente $v$ en algún momento ejecutó \<reverse> para un hash $h$, donde el lote asociado a $h$
  contenía $e$ como elemento.
  La función \<reverse> puede ser invocada como consecuencia de una petición \<CheckTx> o como consecuencia
  de una petición \<DeliverTx>.

  Si proviene de la ejecución de \<CheckTx>, entonces como se muestra en la línea \ref{line:spawn-reverse-checktx}
  de su definición, inmediatamente después de lanzar una llamada asíncrona a \<reverse>, la petición retornó
  \texttt{True}.
  Como consecuencia de esto, la transacción en cuestión (llamémosla $t = (h,s)$) fue añadida a la mempool de $v$ y,
  por el lema \textit{Tendermint-Eventual-Injection} sabemos que eventualmente $v$ recibirá una petición $\<DeliverTx>(t)$.

  Por lo tanto, podemos concluir que eventualmente $v$ recibirá una petición \<DeliverTx>($t$).
  Debido a esto, todos los servidores correctos recibirán eventualmente una petición \<DeliverTx>($t$),
  el hash $h$ asociado a dicha transacción consolidarará y, finalmente, $v$ añadirá a $e$ a \HISTORY 
  como se muestra en la línea \ref{line:abci-hashchain-history}.
\end{proof}

\begin{lemma}
  La implementación \hashchain cumple la propiedad \textit{Unique Epoch}~\ref{api:local_unique_stamp} de \setchain.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto e ${i,i'\leq v.\EPOCH}$ con ${i\neq i'}$.
  Queremos probar que $v.\HISTORY(i)\cap{}v.\HISTORY(i')=\emptyset$.
  %

  Esto es trivialmente correcto debido a que un elemento $e$ se agrega a \HISTORY[j]
  únicamente si no pertenece a \HISTORY[j'] con $j' \in {0, 1, ..., j -1}$, como se puede
  ver en la cláusula \texttt{if} de la línea \ref{line:abci-hashchain-history-if}.
  %
\end{proof}

\begin{lemma}
  La implementación \hashchain cumple la propiedad \textit{Consistent Gets}~\ref{api:consistent-gets} de \setchain.
\end{lemma}

\begin{proof}
  Sean $v$ y $w$ dos servidores correctos, e $i\leq \min(v.\EPOCH, w.\EPOCH)$.
  Queremos probar que $v.\HISTORY(i)=w.\HISTORY(i)$.

  ...
\end{proof}

\begin{lemma}
  La implementación \hashchain cumple la propiedad \textit{Add-before-Get}~\ref{api:get->add} de \setchain.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e \in \THESET$.
  ...
  ¿un servidor maligno no podría invocat Tendermint.Broadcast(h,s)?
\end{proof}

% \subsection{Otras cosas}
% \begin{property}[Safety]\label{tendermint:safety}
%   Si hay menos de 1/3 del poder de voto en manos bizantinas y al menos un validador correcto
%   decide el bloque $B$, entonces ningún validador correcto decidirá un bloque distinto a $B$.
% \end{property}

% \begin{property}[Liveness]\label{tendermint:liveness}
%   Si hay menos de 1/3 de poder de voto en manos bizantinas, luego el procolo de Tendermint
%   no se bloquea (es decir, no hay \textit{deadlock}).
% \end{property}

% En el contexto de Tendermint, denotamos con \textit{n} el poder de voto total de los procesos
% en el sistema, y asumimos una cota superior \textit{f} en el poder de voto total proveniente de
% los procesos bizantinos.
% %
% El algoritmo de consenso de Tendermint asume que $n > 3f$, es decir, requiere que el poder de voto
% en manos de procesos bizantinos sea menor a 1/3 del poder de voto total.
% Por simplicidad, en ocasiones se considera $n = 3f + 1$.

% Tendermint resuelve el problema de la replicación de máquinas de estados ejecutando instancias de
% consenso secuencialmente para acordar cada bloque de transacciones que serán luego ejecutadas por el
% servicio siendo replicado.
% Se considera una variante del problema de consenso bizantino llamado \textit{Validity Predicate-based Byzantine consensus}
% que es motivado por los sistemas de blockchain~\cite{Crain2017LeaderRandomizationSignaturefreeBC}.
% El problema es definido por propiedades de acuerdo, terminación, y validés.

% Esta variante del problema de consenso bizantino tiene un predicado específico a la aplicación
% denotado \textit{valid()} que indica si un valor es válido. En el contexto de sistemas de blockchain, por ejemplo,
% un valor no es válido si no contiene un hash apropiado del último bloque añadido a la blockchain.

% \begin{property}[Agreement]\label{tendermint:agreement1}
%   Dos procesos correctos nunca deciden valores distintos.
% \end{property}

% \begin{property}[Termination]\label{tendermint:termination1}
%     Todos los procesos correctos deciden eventualmente un valor.
% \end{property}

% \begin{property}[Validity]\label{tendermint:validity}
%     Un valor decidido es válido. Es decir, satisface el predicado predefinido
%     denotado con \textit{valid}.
% \end{property}
% %

% Las propiedades ~\ref{tendermint:safety} y ~\ref{tendermint:liveness} son demostradas en ~\cite{Kwon2014TendermintC}.
% Las propiedades ~\ref{tendermint:agreement1}, ~\ref{tendermint:termination1} y ~\ref{tendermint:validity}
% son demostradas en ~\cite{Buchman.2018.Tendermint}.

% En esta sección se introducen las propiedades que deben cumplir las implementaciones
% correctas de \setchain.
% La especificación dada asume que los clientes interactúan con servidores correctos,
% aunque en realidad los clientes no pueden estar seguros de que el servidor que están
% contactando no sea bizantino.
% Como ya fue mencionado anteriormente, las propiedades siempren razonan sobre los servidores
% correctos, dado que los servidores bizantinos no proveen ninguna garantía.
% %

% Empezamos requiriendo que en \setchain toda operación \<add> y \<get> ejecutada sobre un servidor
% correcto eventualmente termine.
% Se dice que un elemento $e$ está en la época $i$ en el historial $H$ (retornado por una invocación
% a \<get>) si $e \in H(i)$.
% Se dice que un elemento $i$ está en $H$ is existe una época $i$ tal que $e \in H(i)$.

% % ? Esta es la property que Marga indicó que falta en el preliminar de Setchain
% La primera propiedad establece que las épocas solo contienen elementos que provienen del conjunto
% de solo crecimiento.

% % 1. Cada elemento válido agregado en un servidor correcto eventualmente es retor-
% % nado en todas las futuras invocaciones a get hechas sobre servidores correctos.
% La segunda propiedad declara que todo elemento añadido a un servidor correcto es eventualmente
% retornado en todas las llamadas a \<get> futuras.

% % ?
% La siguiente propiedad establece que los elementos presentes es un servidor correcto son propagados
% a todos los servidores correctos.

% Se asume en el resto de este trabajo que en cualquier punto de tiempo hay un instante futuro en el
% cual una nueva época será generada. Esto es un supuesto razonable en cual escenario práctico.

% % 2. Todos los elementos válidos agregados en un servidor correcto deben eventual-
% % mente ser estampados con un número de época en todos los servidores correctos.
% La siguiente propiedad establece que todos los elementos añadidos son eventualmente estampados
% con un número de época.

% % ?
% La siguiente propiedad establece que un elemento puede estar en a lo sumo una época,
% y que ningún elemento puede estar en dos épocas diferentes incluso si los conjuntos historiales se
% obtienen de invocaciones \<get> a distintos servidores (ambos correctos).

% % 4. Dos servidores correctos cualesquieras están de acuerdo en el contenido de todas
% % las épocas que hayan sido computadas
% La siguiente propiedad establece que los servidores están de acuerdo en el contenido
% de las épocas.

% % 5. Cada elemento que se estampa con una época proviene del resultado de un cliente
% % añadiendo el elemento.
% Finalmente, se requiere que todo elemento in el historia provenga del resultado de un cliente
% añadiendo un elemento.


% Faltarían las siguientes propiedades
