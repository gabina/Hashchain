\section{Objetivo del capítulo}
En este capítulo se exponen las pruebas de correctitud de los algoritmos presentados para
\vanilla, \compresschain, y \hashchain en el capítulo~\ref{chapter:sol}.
Es decir, se prueba que dichos algoritmos satisfacen las propiedades deseadas para una
implementación de \setchain introducidas en~\ref{sec:setchain-properties}.

\section{Propiedades de Tendermint}\label{sec:properties}
Dado que todas las soluciones presentadas en este trabajo son construidas sobre Tendermint,
para probar la correctitud de ellas, será necesario recapitular las propiedades que la
plataforma Tendermint garantiza.

\subsection{Modelo de computación}
El modelo de Tendermint considera un sistema de procesos que se comunican mediante el intercambio de
mensajes.
Los procesos pueden ser correctos o defectuosos, donde un proceso defectuoso se comporta de maneras
arbitrarias. Es decir, se consideran procesos bizantinos.

Se asume que cada proceso tiene una cantidad determinada de \textit{poder de voto} (el poder de
voto de un proceso puede ser 0).
%
En el contexto de Tendermint, denotamos con \textit{n} el poder de voto total de los validadores
en el sistema, y asumimos una cota superior \textit{f} en el poder de voto total proveniente de
los validadores bizantinos.
%
El algoritmo de consenso de Tendermint asume que $n > 3f$, es decir, requiere que el poder de voto
en manos de validadores bizantinos sea menor a 1/3 del poder de voto total.
% We consider a system of processes that communicate by exchanging messages. Processes can be correct or
% faulty, where a faulty process can behave in an arbitrary way, i.e., we consider Byzantine faults. We assume
% that each process has some amount of voting power (voting power of a process can be 0). Processes in our
% model are not part of a single administrative domain; therefore we cannot enforce a direct network connectivity
% between all processes. Instead, we assume that each process is connected to a subset of processes called peers,
% such that there is an indirect communication channel between all correct processes. Communication between
% processes is established using a gossip protocol

Para lograr homogeneidad con el modelo de computación presentado en ~\ref{sec:model_system},
consideramos que el poder de voto de cada validador es igual a 1, y por lo tanto existen exactamente
$n$ procesos en total y a lo sumo $f$ procesos bizantinos.
 
\subsection{Propiedades nativas}
Se presentan dos propiedades fundamentales de Tendermint, debidamente demostradas en \cite{Buchman.2018.Tendermint}.

\newcounter{prop:tendermint}
\setcounter{prop:tendermint}{\value{property}}

\begin{property}[Tendermint-Agreement]\label{tendermint:agreement}
  Dos procesos correctos nunca deciden valores distintos.
\end{property}

\begin{property}[Tendermint-Termination]\label{tendermint:termination}
    Todos los procesos correctos deciden finalmente un valor.
\end{property}

A continuación se presenta una propiedad que se desprende de las propiedades anteriores
y de la concepción de Tendermint
como máquina de replicación de estados.

\begin{property}[Tendermint-Global-Requests]\label{tendermint:global-delivery}
  Si un sevidor correcto recibe una cadena de peticiones
  \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit,
  entonces todos los servidores correctos reciben dichas peticiones en el mismo orden.
  Aún más, esta serie de peticiones arriban a todos los servidores correctos en
  el mismo orden con respecto a cualquier otra cadena de peticiones.
  % Si un servidor correcto $v$ recibe una petición $\<DeliverTx>(t)$, entonces todos
  % los servidores correctos reciben la misma petición $\<DeliverTx>(t)$ eventualmente.
  % Aún más, esta petición se hace en el mismo orden con respecto a otras
  % peticiones $\<DeliverTx>$ en todos los servidores correctos.
\end{property}

% \begin{proof}
%   Si un servidor correcto $v$ recibe una petición $\<DeliverTx>(t)$ entonces, por definición
%   de \<DeliverTx>, $t$ fue decidida como una transacción parte de un bloque.
%   Por las propiedades \emph{Tendermint-Agreement}~\ref{tendermint:agreement} y
%   \emph{Tendermint-Termination}~\ref{tendermint:termination},
%   podemos asegurar que todos los servidores correctos deciden a $t$ como
%   parte del mismo bloque y, por lo tanto, todos recibirán la petición \<DeliverTx>($t$),
%   incluso 
%   en el mismo orden respecto a las otras peticiones \<DeliverTx> para el mismo bloque
%   - ya que estas peticiones se
%   realizan de forma asíncrona pero en orden, una vez que las transacciones dentro del bloque
%   ya fueron decididas y ordenadas.
% \end{proof}


\subsection{Propiedades adicionales}
En el contexto de estas demostraciones
se asume una mempool de tamaño tal que nunca se satura.
Es decir, el ratio de invocaciones \<add> por parte de los clientes nunca
llena la capacidad de la mempool, de modo que los elementos enviados por clientes
nunca son descartados por mempool llena.
De aquí se desprenden las siguientes propiedades.

\begin{property}[Tendermint-Eventual-CheckTx]\label{tendermint:eventual-checktx}
  Sea $t$ una transacción.
  Si se invoca \<broadcastTx>($t$) sobre un servidor correcto $v$, luego
  $v$ recibirá la petición \<CheckTx>($t$).
\end{property}

\begin{property}[Tendermint-Eventual-Injection]\label{tendermint:eventual-injection}
  Sea $t$ una transacción en la mempool de un servidor correcto.
  En algún momento $t$ formará parte de un bloque.
\end{property}

% No la necesito si add-before-get se cumple trivialmente
% \begin{property}[Tendermint-DeliverTx-BroadcastTx]\label{tendermint:delivery-broadcast}
%   Sea $v$ un servidor correcto.
%   Si $v$ recibe una petición $\<DeliverTx>(t)$,
%   entonces necesariamente, en el pasado, 
%   \<broadcastTx>($t$) fue invocado en algún servidor.
%   % NOTA: acá no se puede asegurar que fue invocado en un servidor correcto,
%   % ni tampoco que la transacción es válida.
% \end{property}

% \begin{property}[Tendermint-Delivery-Mempool]\label{tendermint:delivery-mempool}
%   Sea $v$ un servidor correcto.
%   Si $v$ recibe una petición $\<DeliverTx>(t)$,
%   entonces necesariamente, en el pasado, $t$ formó parte de la mempool de un
%   servidor correcto y fue propuesto para formar parte de un bloque.
% \end{property}

% \begin{property}[Tendermint-Mempool-Broadcast]\label{tendermint:mempool-broadcast}
%   Sea $v$ un servidor correcto.
%   Si $t$ forma parte de la mempool de $v$, entonces necesariamente, en el pasado,
%   \<broadcastTx>($t$) fue invocado en algún servidor correcto y la petición
%   $\<CheckTx>(t)$ en $v$ retornó \texttt{True}.
% \end{property}

\section{Pruebas de correctitud}
\subsection{Consideraciones generales}\label{subsection:proof-comments}
Muchas propiedades de \setchain razonan sobre el resultado $(S, H, h)$ de una invocación
a $v.\<get>$ sobre un servidor $v$.
%
Siendo que en todas las implementaciones \<get> retorna los valores actuales de $v.\THESET$, $v.\HISTORY$ y $v.\EPOCH$,
en las demostraciones se razonará directamente sobre la construcción de ellos, omitiendo la invocación
a \<get>.
%
Esto requiere un tratamiento especial para \hashchain, siendo que allí la definición de \<Query>~\ref{alg:hash_query}
(asociada a \<get>) no solo se limita a retornar la terna mencionada sino que además inicia la construcción
de $\HISTORY$ y difunde las pruebas de época, a través de la llamada a \<updateHistory>~\ref{alg:hash_update_history}.
%
Sin embargo, como fue mencionado en la sección \ref{subsec:hashchain-algorithms} ambos procesos podrían
ser ejecutados periódicamente mediante planificación, independientemente de la petición de consultas.

A su vez, para todo servidor correcto $v$, $v.\HISTORY$ y $v.\THESET$ son estructuras que solo crecen, por lo que una
vez que un elemento fue añadido a ellas, nunca será removido.

Por otro lado, como se presentó en el modelo de computación definido en la sección \ref{sec:model_system},
un nodo bizantino no puede generar un elemento válido.
%
Es decir, los elementos válidos son solo creados por clientes (no por procesos bizantinos).
%
Además, suponemos que los elementos solo pueden ser añadidos mediante una llamada a \<add>.
%
Por lo tanto, la propiedad \emph{Add-before-get} \ref{api:get->add} de \setchain se cumple
trivialmente para todas las soluciones presentadas en este trabajo.
%
Notemos que consideramos de la misma manera a los elementos de cliente como a los elementos
de prueba de época. Es decir, incluso un elemento de prueba de época $e'$ fue añadido mediante una llamada
a $w.\<add>(e')$ en algún servidor correcto $w$, donde el \textit{cliente} que invocó tal llamada fue el
mismo proceso que corre la ABCI correspondiente al servidor $w$.

\subsection{\vanilla}\label{subsec:proof-vanilla}

\newcounter{lemma:vanilla}
\setcounter{lemma:vanilla}{\value{lemma}}

\begin{lemma}\label{lemma:vanilla-consistent-set}
  La implementación \vanilla cumple la propiedad ~\ref{api:consistent-set} \textit{Consistent Sets} de \setchain,
  que establece que las épocas solo contienen elementos que provienen del conjunto de solo crecimiento.
\end{lemma}

\begin{proof}
  Esto es trivialmente correcto debido a que la
  construcción de $\THESET$ y de $\HISTORY$ se hace a partir de los mismos elementos, como se puede ver en las líneas
  \ref{line:abci-vanilla-set} y \ref{line:abci-vanilla-history} en el Algoritmo~\ref{alg:abci-vanilla}.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad ~\ref{api:history->theset-local} \textit{Add-Get-Local} de \setchain,
  que declara que todo elemento válido añadido a un
  servidor correcto $v$ es con el tiempo retornado en todas las llamadas futuras a $v$.\<get>.
\end{lemma}

\begin{proof}
  Sea $e \in $ \(V\) y $v$ un servidor correcto, para los cuales un cliente invoca $v.\<add>(e)$.
  Como $e \in $ \(V\), sabemos que $e$ es válido ($\bigstar$).
  %Si $e \in v.\HISTORY$, entonces, por la propiedad anterior, $e \in v.\THESET$ y la demostración es trivial.
  %Suponemos entonces $e \notin v.\HISTORY$ ($\clubsuit$).
  Por definción de \<add> en el algoritmo \ref{alg:api-vanilla}, la invocación
  $v.\<add>(e)$ se traduce en la llamada \<broadcastTx>($t$) sobre el servidor $v$,
  donde $t = e$. Por la propiedad~\ref{tendermint:eventual-checktx} \emph{Tendermint-Eventual-CheckTx},
  $v$ recibirá con el tiempo la petición \<CheckTx>($t$).
  Por $\bigstar$ se tiene que $e$ es un elemento válido.
  Si $e \in v.\HISTORY$, entonces, por la propiedad anterior, $e \in v.\THESET$ y la demostración es trivial.
  Suponemos entonces $e \notin v.\HISTORY$ ($\clubsuit$).
  Por lo cual, siendo $t = e$
  y considerando la definición de \<CheckTx> en la línea \ref{alg:van_check_tx} del algoritmo
  \ref{alg:abci-vanilla}, se deduce que la llamada a \<CheckTx>($t$) retornará \texttt{True}
  en $v$, por lo cual $t$ pasará a formar parte de la mempool de $v$.
  Luego, por la propiedad~\ref{tendermint:eventual-injection} \emph{Tendermint-Eventual-Injection} sabemos
  que la transacción $t$ formará parte de un bloque.
  Por definición de \<DeliverTx>, dado que $t$ es una transacción parte de un bloque,
  el servidor $v$ tarde o temprano recibirá una petición \<DeliverTx>($t$),
  en donde $t = e$.
  Como se puede observar
  en la condición \texttt{if} de la línea~\ref{line:abci-vanilla-if} y en la definición de
  \<isValidTransaction>~\ref{alg:van_is_valid_tx}
  en el Algoritmo~\ref{alg:abci-vanilla},
  se analizan dos aspectos: que $e$ sea válido
  y que $e$ no forme parte de $v.\HISTORY$.
  Ambas condiciones se cumplen por $\bigstar$ y $\clubsuit$, respectivamente.
  Por lo tanto, $e$ será añadido a $v.\THESET$ como se indica en la
  línea ~\ref{line:abci-vanilla-set}, y retornado como parte de él en todas las futuras invocaciones a
  $v$.\<get>.
\end{proof}

\begin{lemma}\label{proof:get-global}
  La implementación \vanilla cumple la propiedad~\ref{api:history->theset} \textit{Get-Global} de \setchain,
  que establece que los elementos presentes en un servidor correcto
  son propagados a todos los servidores correctos.
\end{lemma}

\begin{proof}
  Sean $v$ y $w$ dos servidores correctos y $e \in $ \(U\), tal que  $e \in v.\THESET$.
  Debemos probar que con el tiempo se cumplirá $e \in w.\THESET$.
  Si $e \in v.\THESET$, entonces, por construcción de $\THESET$, necesariamente $v$ en algún momento recibió una
  petición \<DeliverTx>($t$), donde $t = e$, y $e$ es válido.
  Si un servidor correcto recibe una petición \<DeliverTx>($t$), necesariamente lo hace como parte de una cadena de
  peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit.
  Luego, por la propiedad~\ref{tendermint:global-delivery}
  \emph{Tendermint-Global-Requests} todos los
  servidores correctos, y en particular $w$, reciben la misma serie de peticiones, incluyendo la petición \<DeliverTx>($t$).
  Dado que $e$ es válido, se tienen dos opciones: o bien $e$ es parte de $w.\HISTORY$,
  en cuyo caso ya se cumple $e \in w.\THESET$ (ver lema \ref{lemma:vanilla-consistent-set}), o bien $e$ es un elemento
  nuevo ($e \notin w.\HISTORY$).
  En este último caso,
  $e$ será añadido a
  $w.\THESET$, como se muestra en la línea~\ref{line:abci-vanilla-set} en el Algoritmo~\ref{alg:abci-vanilla}.
  Por lo tanto, se cumplirá $e \in w.\THESET$.

  % Si un servidor correcto recibe una petición \<DeliverTx>($t$), por la propiedad
  % \textbf{Tendermint-Global-Requests}
  % todos los
  % servidores correctos, y en particular $w$, reciben dicha petición \<DeliverTx>($t$),
  % añadiéndo a $e$ a su conjunto
  % $\THESET$, como se muestra en la línea


  % Esto implica que el servidor decidió dicha transacción, puesto que la petición \<DeliverTx> se
  % envía una vez que las transacciones fueron decididas y ordenadas.
  % Luego, por la propiedad de \textit{Tendermint-Agreement}, todos los nodos correctos decidirán
  % la misma transacción asociada al elemento $e$, y por tanto recibirán la petición \<DeliverTx>
  % para ella, añadiéndo a $e$ a su conjunto $\THESET$, como se muestra en la línea
  % \ref{line:abci-vanilla-set} en el Algoritmo~\ref{alg:abci-vanilla}.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad~\ref{api:theset->history} \textit{Eventual-Get}
  de \setchain, que establece que todos los elementos añadidos en algún momento son estampados
  con un número de época.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e \in U$. Si $e \in v.\THESET$, entonces por construcción de
  $\THESET$, necesariamente $v$ en algún momento recibió una
  petición \<DeliverTx>($t$), donde $t = e$, y $e$ es válido.
  Como se puede ver en las líneas ~\ref{line:abci-vanilla-set} y ~\ref{line:abci-vanilla-history} en
  el Algoritmo~\ref{alg:abci-vanilla}, inmediatamente después de agregar un elemento a $v.\THESET$,
  el elemento se agrega a $v.\HISTORY$. Por lo tanto, con seguridad, el elemento $e$ será en algún momento
  agregado a $v.\HISTORY$.
  Si un servidor correcto recibe una petición \<DeliverTx>($t$), necesariamente lo hace como parte de una cadena de
  peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit.
  De aquí se desprende entonces que $v$ recibirá una petición \EndBlock que, como se muestra
  en la línea \ref{line:epoch-increment}, incrementa el número de época, provocando que, a partir de ese momento, todas las invocaciones
  a \<get> incluyan la nueva época que contiene a $e$ como parte de ella.

\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad~\ref{api:local_unique_stamp} \textit{Unique Epoch} de \setchain,
  que establece que un elemento puede estar en a lo sumo una época.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto e ${i,i'\leq v.\EPOCH}$ con ${i\neq i'}$.
  Queremos probar que $v.\HISTORY(i)\cap{}v.\HISTORY(i')=\emptyset$.
  %

  Esto es trivialmente correcto debido a que un elemento $e$ se agrega a \HISTORY[j]
  únicamente si no pertenece a $\HISTORY[j']$ con $j' \in \{0, 1, ..., j -1\}$.
  Esto se puede ver en la cláusula \texttt{if} de la línea \ref{line:abci-vanilla-if}
  y en la definición de \<isValidTransaction> de la línea \ref{alg:van_is_valid_tx},
  presentes en el Algoritmo \ref{alg:abci-vanilla}.
  % La demostración se hará por el absurdo.
  % Sin pérdida de generalidad, suponemos que ${i < i'}$. Sea $e$ un elemento $\in v.\HISTORY(i)$ .
  % Por lo tanto, $e$ fue estampado con el número de época $i$.
  % %
  % Suponemos ahora que también se cumple $e \in v.\HISTORY(i')$. Es decir, 
  % $e$ fue estampado con el número de época $i'$.
  % Para que $e$ también haya sido añadido a la época $i'$, necesariamente debe haber llegado
  % una petición \<DeliverTx> para la transacción asociada al elemento $e$ que, al procesarse,
  % incluyó a $e$ como parte de $v.\HISTORY(i')$.
  % Por construcción, esto necesariamente debe haber pasado en la línea
  % \ref{line:abci-vanilla-history} en el Algoritmo~\ref{alg:abci-vanilla},
  % con lo cual se concluye que la condición del \texttt{if} de
  % la línea ~\ref{line:abci-vanilla-if} evaluó a \texttt{True} ($\star$), ya que de otro modo
  % el elemento no hubiese sido añadido.
  % %

  % Dado que ${i < i'}$ y las épocas se construyen ordenadamente, al momento de la
  % petición \<DeliverTx> mencionada anteriormente, la época $i$ ya fue construida,
  % y por lo tanto se tiene
  % $e \in v.\HISTORY(i)$.
  % Por este motivo, al procesar dicha petición \<DeliverTx>, la condición \texttt{if} de
  % la línea ~\ref{line:abci-vanilla-if} evaluará a \texttt{false}, dado que 
  % \texttt{not} $e$ \texttt{in} $v.\HISTORY$ es falso, puesto que $e \in v.\HISTORY(i)$ .
  % Esto lleva a una contradicción por ($\star$).
  % La contradicción proviene de suponer que $e \in v.\HISTORY(i')$.
  % Por lo tanto, se concluye que $e \not\in v.\HISTORY(i')$. Luego se tiene
  % $v.\HISTORY(i)\cap{}v.\HISTORY(i')=\emptyset$.
\end{proof}

\begin{lemma}
  La implementación \vanilla cumple la propiedad \ref{api:consistent-gets} \textit{Consistent Gets} de \setchain,
  que establece que los servidores están de acuerdo en el contenido
  de las épocas.
\end{lemma}

\begin{proof}
  Sean $v$ y $w$ dos servidores correctos, e $i\leq$ min$(v.\EPOCH, w.\EPOCH)$.
  Queremos probar que $v.\HISTORY(i)=w.\HISTORY(i)$.

  Se demostrará $v.\HISTORY(i)=w.\HISTORY(i)$ por inducción fuerte en el número de época.

  \textbf{Caso base}. 
  % Se seguirá un razonamiento similar al presentado en la demostración del
  % Lema ~\ref{proof:get-global}.
  Sea un elemento $e$ $\in v.\HISTORY(1)$~\footnote{Por definición de \setchain, $\HISTORY$ empieza en la época 1.}. 
  Por construcción de $\HISTORY$, necesariamente $v$ en un momento determinado recibió una
  petición \<DeliverTx>($t$), donde $t = e$, y $e$ es válido.
  Naturalmente, esta petición \<DeliverTx>($t$) arriba a $v$ como parte de una cadena de
  peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit.
  Esto produjo que $e$ fuera añadido a $v.\HISTORY(1)$,
  como se muestra en la línea
  \ref{line:abci-vanilla-history} en el Algoritmo~\ref{alg:abci-vanilla}.
  Posteriormente, $v.\EPOCH$
  fue incrementado de 0 a 1 como parte del proceso de la petición \EndBlock,
  como se muestra en la línea \ref{line:epoch-increment}.
  De esta forma, $e$ fue estampado con el número de época 1 en $v$.
  % Esto implica que el servidor decidió dicha transacción, puesto que la petición \<DeliverTx> se
  % envía una vez que las transacciones fueron decididas y ordenadas.
  % Luego, por la propiedad de \textit{Tendermint-Agreement}, todos los nodos correctos y, en particular $w$,
  % deciden la misma transacción asociada al elemento $e$ (en el mismo orden que $v$).
  Por la propiedad~\ref{tendermint:global-delivery} \emph{Tendermint-Global-Requests} podemos
  asegurar que todos los servidores correctos,
  y en particular $w$, reciben la cadena de peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit
  en el mismo orden en que lo hace $v$.
  % petición \<DeliverTx>($t$) en el mismo orden en que lo hace $v$, es decir,
  % durante la construcción de la época $i$,
  Por lo tanto, de forma análoga, $w$ añadirá $e$ a $w.\HISTORY(1)$.
  Posteriormente, $w.\EPOCH$ será incrementado de 0 a 1 como parte del proceso de la petición
  \EndBlock.
  De esta forma, $e$ es estampado con el número de época 1 en $w$.
  Así queda demostrado $v.\HISTORY(1) \subseteq w.\HISTORY(1)$.
  El mismo razonamiento se puede seguir para demostrar $w.\HISTORY(1) \subseteq v.\HISTORY(1)$.
  Luego, queda demostrada la propiedad para el caso base: $v.\HISTORY(1)=w.\HISTORY(1)$.
  
  \textbf{Caso inductivo}.
  Sea un elemento $e$ $\in v.\HISTORY(n+1)$. Análogamente a lo mencionado anteriormente,
  a $v$ llegó una cadena de peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit
  que provocó que $e$ fuera añadido a $v.\HISTORY(n+1)$ y, posteriormente, que $v.\EPOCH$
  fuera incrementado de n a n+1 como parte del proceso de la petición \EndBlock.
  Por la propiedad~\ref{tendermint:global-delivery} \emph{Tendermint-Global-Requests}
  podemos asegurar que la misma cadena de peticiones llegó a $w$.
  A su vez, por la hipótesis inductiva fuerte, sabemos que
  $v.\HISTORY(j)=w.\HISTORY(j), \forall j \leq n$.
  Por lo tanto, podemos asegurar que al procesarse la petición $w.\<DeliverTx>(t)$, donde
  $t = e$, la definición de \<isValidTransaction>
  de la línea \ref{alg:van_is_valid_tx} retorna \texttt{True}, puesto que
  $e \notin w.\HISTORY(j) \forall j \leq n$.
  De este modo, $e$ es añadido a $w.\HISTORY(n+1)$, y, posteriormente, $v.\EPOCH$
  se incrementa de n a n+1 como parte del proceso de la petición \EndBlock.
  Así queda demostrado $v.\HISTORY(n+1) \subseteq w.\HISTORY(n+1)$.
  El mismo razonamiento se puede seguir para demostrar $w.\HISTORY(n+1) \subseteq v.\HISTORY(n+1)$.
  Luego, queda demostrada la propiedad para el caso inductivo: $v.\HISTORY(n+1)=w.\HISTORY(n+1)$.
\end{proof}

\begin{lemma}\label{lemma:vanilla-add-before-get}
  La implementación \vanilla cumple la propiedad~\ref{api:get->add} \textit{Add-before-Get} de \setchain,
  que determina que todo elemento en $\THESET$ proviene del resultado de un cliente
  añadiendo un elemento.
\end{lemma}

\begin{proof}
  Se cumple trivialmente por lo mencionado en \ref{subsection:proof-comments}.
\end{proof}

\subsection{\compresschain}\label{sec:proof-compresschain}

\begin{lemma}\label{lemma:compresschain-consistent-set}
  La implementación \compresschain cumple la propiedad~\ref{api:consistent-set} \textit{Consistent Sets} de \setchain.
  %que establece que las épocas solo contienen elementos que provienen del conjunto de solo crecimiento.
\end{lemma}

\begin{proof}
  Esto es trivialmente correcto debido a que la
  construcción de $\THESET$ y de $\HISTORY$ se hace a partir de los mismos elementos, como se puede ver en las líneas
  \ref{line:abci-compresschain-the-set} y \ref{line:abci-compresschain-history} en el Algoritmo~\ref{alg:abci-brotli}.
\end{proof}

\begin{lemma}
  La implementación \compresschain cumple la propiedad~\ref{api:history->theset-local} \textit{Add-Get-Local} de \setchain.
  %que declara que todo elemento válido añadido a un
  %servidor correcto $v$ es eventualmente retornado en todas las llamadas futuras a $v$.\<get>.
\end{lemma}

\begin{proof}
  Sea $e \in $ \(V\) y $v$ un servidor correcto, para los cuales un cliente invoca $v.\<add>(e)$.
  Como $e \in $ \(V\), sabemos que $e$ es válido ($\bigstar$).
  % Si $e \in v.\HISTORY$, entonces, por la propiedad anterior, $e \in v.\THESET$ y la demostración es trivial.
  % Suponemos entonces $e \notin v.\HISTORY$ ($\clubsuit$).
  Por definción de \<add> en el algoritmo \ref{alg:api-brotli}, la invocación
  $v.\<add>(e)$ se traduce en la llamada \texttt{CompressCollector.AddElement($e$)}.
  Como se puede observar en el algoritmo ~\ref{alg:collector-brotli}, dado que $e$ es válido,
  será codificado adecuadamente y añadido a un lote $t$ que con el tiempo estará listo\footnote{Como
  se mencionó en la sección ~\ref{subsec:compresschain-algorithms},
  un lote se considera listo para ser enviado una vez que, o bien alcanza un tamaño
  máximo, o bien una cantidad razonable de tiempo transacurrió desde que el primer
  elemento llegó. Por este motivo podemos asegurar que todo lote en algún momento será
  considerado listo.} y se invocará \<broadcastTx>($t$) sobre el servidor $v$.
  Por la propiedad~\ref{tendermint:eventual-checktx} \emph{Tendermint-Eventual-CheckTx}, $v$
  recibirá con el tiempo la petición \<CheckTx>($t$).
  Por $\bigstar$ se tiene que $e$ es un elemento válido.
  Si $e \in v.\HISTORY$, entonces, por la propiedad anterior, $e \in v.\THESET$ y la demostración es trivial.
  Suponemos entonces $e \notin v.\HISTORY$ ($\clubsuit$).
  Por lo cual, siendo $e$ un elemento de $t$
  y considerando la definición de \<CheckTx> en la línea \ref{alg:brotli_check_tx} del algoritmo
  \ref{alg:abci-brotli}, se deduce que la llamada a \<CheckTx>($t$) retornará \texttt{True}
  en $v$, por lo cual $t$ pasará a formar parte de la mempool de $v$.
  Luego, por la propiedad~\ref{tendermint:eventual-injection} \emph{Tendermint-Eventual-Injection} sabemos que la
  transacción $t$ formará parte de un bloque.
  Por definición de \<DeliverTx>, dado que $t$ es una transacción parte de un bloque,
  el servidor $v$ a la larga recibirá una petición \<DeliverTx>($t$).
  Como se puede observar
  en la condición \texttt{if} de la línea ~\ref{line:abci-compresschain-if} en el Algoritmo~\ref{alg:abci-brotli},
  se analizan dos aspectos: que $e$ sea válido
  y que $e$ no forme parte de $\HISTORY$.
  Ambas condiciones se cumplen por $\bigstar$ y $\clubsuit$, respectivamente.
  Por lo tanto, $e$ será añadido a $\THESET$ como se indica en la
  línea ~\ref{line:abci-compresschain-the-set}, y retornado como parte de él en todas las futuras invocaciones a
  $v$.\<get>.
\end{proof}

\begin{lemma}\label{proof:compresschain-get-global}
  La implementación \compresschain cumple la propiedad~\ref{api:history->theset} \textit{Get-Global} de \setchain.
  %que establece que los elementos presentes en un servidor correcto
  %son propagados a todos los servidores correctos.
\end{lemma}

\begin{proof}
  Sean $v$ y $w$ dos servidores correctos y $e \in U$, tal que  $e \in v.\THESET$.
  Debemos probar que se cumplirá $e \in w.\THESET$.
  Si $e \in v.\THESET$, entonces, por construcción de $\THESET$, necesariamente $e$ es válido y
  $v$ en algún momento recibió una
  petición \<DeliverTx>($t$), donde $t$ es un lote comprimido de elementos, y uno de esos elementos
  es $e$.
  Si un servidor correcto recibe una petición \<DeliverTx>($t$), necesariamente lo hace como parte de una cadena de
  peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit.
  Luego, por la propiedad~\ref{tendermint:global-delivery}
  \emph{Tendermint-Global-Requests} todos los
  servidores correctos, y en particular $w$, reciben la misma serie de peticiones, incluyendo la petición \<DeliverTx>($t$).
  Dado que $e$ es válido, se tienen dos opciones: o bien $e$ es parte de $w.\HISTORY$,
  en cuyo caso ya se cumple $e \in w.\THESET$ (ver lema \ref{lemma:compresschain-consistent-set}), o bien $e$ es un elemento
  nuevo ($e \notin w.\HISTORY$).
  En este último caso,
  $e$ será añadido a
  $w.\THESET$, como se muestra en la línea
  \ref{line:abci-compresschain-the-set} en el Algoritmo~\ref{alg:abci-brotli}.
  Por lo tanto, se cumplirá $e \in w.\THESET$.
\end{proof}

\begin{lemma}
  La implementación \compresschain cumple la propiedad~\ref{api:theset->history} \textit{Eventual-Get}
  de \setchain.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e \in U$. Si $e \in v.\THESET$, entonces por construcción de
  $\THESET$, necesariamente $e$ es válido y $v$ en algún momento recibió una
  petición \<DeliverTx>($t$), donde $t$ es un lote comprimido de elementos, y uno de esos elementos
  es $e$.
  Como se puede ver en la definición de \<DeliverTx> y en las líneas \ref{line:abci-compresschain-the-set}
  y \ref{line:abci-compresschain-history} de \texttt{newEpoch} en
  el Algoritmo~\ref{alg:abci-brotli}, inmediatamente después de agregar un elemento a $\THESET$,
  el elemento se agrega a $\HISTORY$. En algún momento la iteración sobre los elementos del lote termina y,
  como se muestra en la línea \ref{line:abci-compresschain-epoch-increment} se incrementa $\EPOCH$.
  Por lo tanto, con seguridad, el elemento $e$ será
  agregado a $v.\HISTORY$ y se producirá el incremento de $v.\EPOCH$, estampando a $e$ con un número de época.
\end{proof}

\begin{lemma}
  La implementación \compresschain cumple la propiedad~\ref{api:local_unique_stamp} \textit{Unique Epoch} de \setchain.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto e ${i,i'\leq v.\EPOCH}$ con ${i\neq i'}$.
  Queremos probar que $v.\HISTORY(i)\cap{}v.\HISTORY(i')=\emptyset$.
  %

  Esto es trivialmente correcto debido a que un elemento $e$ se agrega a \HISTORY[j]
  únicamente si no pertenece a $\HISTORY[j']$ con $j' \in \{0, 1, ..., j -1\}$.
  Esto se puede ver en la cláusula \texttt{if} de la línea \ref{line:abci-compresschain-if}
  presente en el Algoritmo \ref{alg:abci-brotli}.
  % La demostración se hará por el absurdo.
  % Sin pérdida de generalidad, suponemos que ${i < i'}$. Sea $e$ un elemento $\in \HISTORY(i)$ .
  % Por lo tanto, $e$ fue estampado con el número de época $i$.
  % %
  % Suponemos ahora que también se cumple $e \in \HISTORY(i')$. Es decir, 
  % $e$ fue estampado con el número de época $i'$.
  % Para que $e$ también haya sido añadido a la época $i'$, necesariamente debe haber llegado
  % una petición \<DeliverTx>$(t)$, donde $t$ es un lote comprimido de elementos, y uno de esos
  % elementos es $e$. Al procesarse dicha transacción, se debe haber
  % incluido a $e$ como parte de $\HISTORY(i')$.
  % %
  % Por construcción, esto necesariamente debe haber pasado en la línea
  % \ref{line:abci-compresschain-history} en el Algoritmo~\ref{alg:abci-brotli},
  % con lo cual se concluye que la condición del \texttt{if} de
  % la línea ~\ref{line:abci-compresschain-if} evaluó a \texttt{True} ($\star$),
  % ya que de otro modo el elemento no hubiese sido añadido.
  % %

  % Dado que ${i < i'}$ y las épocas se construyen ordenadamente, al momento de la
  % petición \<DeliverTx>$(t)$, la época $i$ ya fue construida, y por lo tanto se tiene
  % $e \in \HISTORY(i)$.
  % Por este motivo, al procesar la petición \<DeliverTx>$(t)$, la condición \texttt{if} de
  % la línea ~\ref{line:abci-compresschain-if} evaluará a \texttt{false}, dado que 
  % \texttt{not} $e$ \texttt{in} $\HISTORY$ es falso, puesto que $e \in \HISTORY(i)$.
  % Esto lleva a una contradicción por ($\star$).
  % La contradicción proviene de suponer que $e \in \HISTORY(i')$.
  % Por lo tanto, se concluye que $e \not\in \HISTORY(i')$. Esto vale para cualquier elemento $e$.
  % Luego se tiene $\HISTORY(i)\cap{}\HISTORY(i')=\emptyset$.
\end{proof}

\begin{lemma}
  La implementación \compresschain cumple la propiedad~\ref{api:consistent-gets} \textit{Consistent Gets} de \setchain.
\end{lemma}

\begin{proof}
  % Sea $e$ un elemento $\in v.\HISTORY(i)$. 
  % Por construcción de $\HISTORY$, necesariamente $e$ es válido y $v$ en un momento determinado recibió una
  % petición \<DeliverTx>($t$), donde $t$ es un lote comprimido de elementos, y uno de esos
  % elementos es $e$. Como consecuencia de esta petición,
  % $e$ fue estampado con el número de época $i$.
  % Por la propiedad \emph{Tendermint-Global-Requests}~\ref{tendermint:global-delivery} podemos asegurar que todos los servidores correctos,
  % y en particular $w$, reciben la petición \<DeliverTx>($t$) en el mismo orden en que lo hace $v$, es decir,
  % durante la construcción de la época $i$, añadiendo a $e$ a $w.\HISTORY(i)$, como se muestra en la línea
  % \ref{line:abci-compresschain-history} en el Algoritmo~\ref{alg:abci-brotli}.
  % El mismo razonamiento se puede hacer para un elemento $e \in w.\HISTORY(i)$.
  % Luego, $v.\HISTORY(i)=w.\HISTORY(i)$.
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
  Sean $v$ y $w$ dos servidores correctos, e $i\leq$ min$(v.\EPOCH, w.\EPOCH)$.
  Queremos probar que $v.\HISTORY(i)=w.\HISTORY(i)$.

  Se demostrará $v.\HISTORY(i)=w.\HISTORY(i)$ por inducción fuerte en el número de época.

  \textbf{Caso base}. 
  % Se seguirá un razonamiento similar al presentado en la demostración del
  % Lema ~\ref{proof:get-global}.
  Sea un elemento $e$ $\in v.\HISTORY(1)$.
  Por construcción de $\HISTORY$, necesariamente $e$ es válido y $v$ en un momento determinado recibió una
  petición \<DeliverTx>($t$), donde $t$ es un lote comprimido de elementos, y uno de esos
  elementos es $e$.
  % Por construcción de $\HISTORY$, necesariamente $v$ en un momento determinado recibió una
  % petición \<DeliverTx>($t$), donde $t = e$, y $e$ es válido.
  Esto produjo que $e$ fuera añadido a $v.\HISTORY(1)$ como se muestra en la línea
  \ref{line:abci-compresschain-history}.
  Posteriormente, cuando la iteración sobre los elementos del lote finaliza,
  $v.\EPOCH$ es incrementado de 0 a 1, como se muestra en la línea
  \ref{line:abci-compresschain-epoch-increment}
  en el Algoritmo~\ref{alg:abci-brotli}.
  De esta forma, $e$ fue estampado con el número de época 1 en $v$.
  Naturalmente, esta petición \<DeliverTx>($t$) arriba a $v$ como parte de una cadena de
  peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit.
  % Esto implica que el servidor decidió dicha transacción, puesto que la petición \<DeliverTx> se
  % envía una vez que las transacciones fueron decididas y ordenadas.
  % Luego, por la propiedad de \textit{Tendermint-Agreement}, todos los nodos correctos y, en particular $w$,
  % deciden la misma transacción asociada al elemento $e$ (en el mismo orden que $v$).
  Por la propiedad~\ref{tendermint:global-delivery} \emph{Tendermint-Global-Requests} podemos
  asegurar que todos los servidores correctos,
  y en particular $w$, reciben la cadena de peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit
  en el mismo orden en que lo hace $v$.
  % petición \<DeliverTx>($t$) en el mismo orden en que lo hace $v$, es decir,
  % durante la construcción de la época $i$,
  Por lo tanto, de forma análoga, $w$ añadirá $e$ a $w.\HISTORY(1)$ y, posteriormente,
  $w.\EPOCH$ será incrementado de 0 a 1.
  De esta forma, $e$ es estampado con el número de época 1 en $w$.
  Así queda demostrado $v.\HISTORY(1) \subseteq w.\HISTORY(1)$.
  El mismo razonamiento se puede seguir para demostrar $w.\HISTORY(1) \subseteq v.\HISTORY(1)$.
  Luego, queda demostrada la propiedad para el caso base: $v.\HISTORY(1)=w.\HISTORY(1)$.
  
  \textbf{Caso inductivo}.
  Sea un elemento $e$ $\in v.\HISTORY(n+1)$. Análogamente a lo mencionado anteriormente,
  a $v$ llegó una cadena de peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit
  que provocó que $e$ fuera añadido a $v.\HISTORY(n+1)$ y que $v.\EPOCH$
  fuera incrementado de n a n+1.
  Por la propiedad~\ref{tendermint:global-delivery} \emph{Tendermint-Global-Requests}
  podemos asegurar que la misma cadena de peticiones llegó a $w$.
  A su vez, por la hipótesis inductiva fuerte, sabemos que
  $v.\HISTORY(j)=w.\HISTORY(j), \forall j \leq n$.
  Por lo tanto, podemos asegurar que al procesarse la petición $w.\<DeliverTx>(t)$,
  donde $t$ es un lote comprimido de elementos, y uno de esos
  elementos es $e$, la cláusula \texttt{if} de la línea \ref{line:abci-compresschain-if}
  retorna \texttt{True}, puesto que
  $e \notin w.\HISTORY(j) \forall j \leq n$.
  % $t = e$, la definición de \<isValidTransaction>
  % de la línea \ref{alg:van_is_valid_tx} retorna \texttt{True}, puesto que
  % $e \notin w.\HISTORY(j) \forall j \leq n$.
  De este modo, $e$ es añadido a $w.\HISTORY(n+1)$, y $v.\EPOCH$ se incrementa de n a n+1.
  Así queda demostrado $v.\HISTORY(n+1) \subseteq w.\HISTORY(n+1)$.
  El mismo razonamiento se puede seguir para demostrar $w.\HISTORY(n+1) \subseteq v.\HISTORY(n+1)$.
  Luego, queda demostrada la propiedad para el caso inductivo: $v.\HISTORY(n+1)=w.\HISTORY(n+1)$.
\end{proof}

\begin{lemma}
  La implementación \compresschain cumple la propiedad~\ref{api:get->add} \textit{Add-before-Get} de \setchain.
\end{lemma}

\begin{proof}
  Se cumple trivialmente por lo mencionado en \ref{subsection:proof-comments}.
\end{proof}

\subsection{\hashchain}\label{sec:proof-hashchain}

\subsubsection{Consideraciones generales}\label{subsection:hashchain-proof-comments}
Para estas demostraciones consideramos que dos lotes de elementos distintos nunca
tienen el mismo hash asociado, es decir, no se considera la posibilidad de colisiones.

\subsubsection{Propiedades derivadas}
Con el objetivo de simplificar las pruebas, se definen y demuestran
tres propiedades derivadas antes de proceder con la demostración de los lemas.

\begin{property}[Haschain-Global-Consolidation]\label{tendermint:hashchain-global-consolidation}
  Si un hash $h$ consolida en un servidor correcto, a la larga consolidará en todos
  los servidores correctos.
\end{property}
  
\begin{proof}
  Sea $v$ un servidor correcto.
  Sea $h$ un hash que consolida en $v$.
  Por lo tanto, \<shouldConsolidateHash>($h$) retornó \texttt{True}, es decir, se recolectaron
  \SPH firmas para $h$.
  Dado que en \texttt{hash\_to\_signatures} solo se añaden firmas en la línea \ref{alg:hash-new-sign}
  de \<DeliverTx> tras chequear que la misma sea válida (ver línea \ref{line:hash-check-sign}),
  concluimos que $v$ recibió \SPH peticiones \<DeliverTx> para $h$ con distintas firmas válidas.
  Dichas peticiones \<DeliverTx> arriban como parte de una cadena
  de peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit.
  Por la propiedad~\ref{tendermint:global-delivery} \emph{Tendermint-Global-Requests}
  podemos asegurar que la misma cadena de peticiones llegará a todos los servidores correctos.
  De este modo, todos los servidores correctos recibirán \SPH firmas válidas y distintas para $h$,
  de modo que dicho hash consolidará en todos los servidores correctos.
\end{proof}

\begin{property}[Haschain-Local-Consolidation]\label{tendermint:hashchain-local-consolidation}
  Si un hash $h$ consolida en un servidor correcto $v$, tarde o temprano todos los elementos
  asociados a $h$ son añadidos a $v.\HISTORY$.
\end{property}
  
\begin{proof}
  A continuación se proporciona una descripción general de la demostración. Una demostración
  por inducción en el número de época se podría realizar siguiendo una estructura similar a la
  presentada en la demostración del lema \ref{lemma:hashchain-consistent-gets}.
  
  Sea $v$ un servidor correcto.
  Sea $h$ un hash que consolida en $v$.
  Por lo tanto, \<shouldConsolidateHash>($h$) retornó \texttt{True}, es decir, se recolectaron
  \SPH firmas válidas y distintas para $h$.
  Dado que $\SPH \geq f + 1$, podemos asegurar que al menos un servidor correcto (llamemoslo $w$) firmó $h$.
  Con seguridad, dicho servidor correcto conoce el hash y, por lo tanto, garantiza que lo revertirá
  cuando $v$ procese la petición \<DeliverTx> asociada a $h$ y a la firma de $w$ (si es que $v$
  aún no tenía el lote asociado a $h$). 
  De este modo, se asegura que $v$ tiene los elementos asociados a $h$ y, por lo tanto, podrá añadirlos
  a $\HISTORY$ cuando se procese \<updateHistory>.
  El mismo razonamiento se puede utilizar para las épocas anteriores.
  
  % NOTA: habría que usar inducción en el nro de época.
\end{proof}

\begin{property}[Haschain-Broadcast-Consolidation]\label{tendermint:hashchain-broadcast-consolidation}
  Sea $v$ un servidor correcto. Sea $e$ un elemento válido tal que $e \in l$, y sea $h$ el hash asociado al lote $l$.
  Si se invoca \<broadcastTx>($h, s$) en $v$, donde $s$ es la firma de $h$ con la clave privada de $v$,
  entonces tarde o temprano $e \in v.\HISTORY$.
\end{property}

\begin{proof}
  Supongamos que se invoca \<broadcastTx>($h, s$) en $v$.
  Por la propiedad~\ref{tendermint:eventual-checktx} \emph{Tendermint-Eventual-CheckTx}, $v$
  recibirá la petición \<CheckTx>($h, s$).
  Siguiendo la definición de \<CheckTx>~\ref{alg:hash_check_tx}, si la firma es válida ($s$ lo es puesto que
  $v$ es correcto) se abren dos casos: que $v$ conozca el hash o que aún no lo conozca.
  Si $v$ no tiene el lote $l$ asociado al hash $h$, entonces trivialmente retornará \texttt{True}.
  Si $v$ tiene el lote $l$ asociado al hash $h$, entonces si $l$ pasa \<isValidBatch>, retornará \texttt{True}.
  Por el contrario, si $l$ no pasa \<isValidBatch>, siendo que $e \in l$ y $e$ es válido, necesariamente tenemos
  que $e \in v.\HISTORY$. En tal caso, la propiedad queda demostrada.

  Suponemos entonces que $v$.\<CheckTx>($h, s$) retorna \texttt{True}.
  Por lo tanto, $t$ pasará a formar parte de la mempool de $v$.
  Luego, por la propiedad~\ref{tendermint:eventual-injection} \emph{Tendermint-Eventual-Injection}
  sabemos que la transacción $t$ formará parte de un bloque.
  Por definición de \<DeliverTx>, dado que $t$ es una transacción parte de un bloque,
  el servidor $v$ recibirá una petición \<DeliverTx>($t$) como parte de una cadena
  de peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit.
  Por la propiedad~\ref{tendermint:global-delivery} \emph{Tendermint-Global-Requests}
  podemos asegurar que la misma cadena de peticiones llegará a todos los servidores correctos.
  Sea $w$ un servidor correcto cualquiera.
  Como parte de la ejecución de \<DeliverTx>($t$) en $w$, si aún no tiene
  el lote $l$ asociado, $w$ intentará revertir $h$ comunicándose con el \hcollector
  de $v$, quien, con seguridad, devolverá el lote asociado a $h$.
  Así, como parte de \<tryReverse>, $w$ firmará $h$ con
  su propia clave privada.
  Esto ocurrirá para todos los servidores correctos.
  Siguiendo un razonamiento idéntico al ya explicado, podemos concluir que $v$ recibirá peticiones
  \<DeliverTx> para todas las transacciones del tipo $(h, s')$, donde $s'$ es una firma
  válida para $h$ generada con la clave privada de un servidor correcto, siempre que $w$.\<CheckTx>($h, s'$)
  retorne \texttt{True} en todo servidor correcto $w$.
  De este modo, el hash consolidará en $v$ y, por la propiedad \ref{tendermint:hashchain-local-consolidation}
  \textit{Haschain-Local-Consolidation}, todos sus elementos serán añadidos a $v.\HISTORY$ (incluyendo a $e$).
  La única excepción a esto se dará en el caso en que $w$.\<CheckTx>($h, s'$) retorne \texttt{False}
  para algún servidor correcto $w$,
  significando que $e \in w.\HISTORY$.
  En ese caso, un hash $h'$ que contiene a $e$ consolidó en $w$ (puesto que solo se agregan elementos a $\HISTORY$
  cuando un hash consolida).
  Por la propiedad \ref{tendermint:hashchain-global-consolidation} \textit{Haschain-Global-Consolidation},
  con el tiempo ese mismo hash consolidará en $v$.
  A su vez, por la propiedad \ref{tendermint:hashchain-local-consolidation} \textit{Haschain-Local-Consolidation} se añadirá
  $e$ a $v.\HISTORY$.
\end{proof}

\begin{lemma}\label{lemma:hashchain-consistent-set}
  La implementación \hashchain cumple la propiedad~\ref{api:consistent-set} \textit{Consistent Sets} de \setchain.
  %que establece que las épocas solo contienen elementos que provienen del conjunto de solo crecimiento.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto sobre el que se invoca $v.\<get>$.
  Por definición de \<get> en el Algoritmo~\ref{alg:api-hashchain}, esto se traduce como una llamada a
  \<Query> en el Algoritmo~\ref{alg:abci-hash1}.
  Sea $(\THESET, \HISTORY, \EPOCH)$ el resultado de dicha invocación.
  Queremos probar que para todo $i \leq \EPOCH, \HISTORY(i) \subseteq \THESET$.
  Sea $e$ un elemento $\in \HISTORY(i)$ para algún $i \leq \EPOCH$.
  Por construcción de \HISTORY, $e$ fue necesariamente agregado en la línea \ref{line:abci-hashchain-history}
  como parte de la ejecución de \<updateHistory>.
  Se deduce entonces que $e$ es un elemento válido proveniente de un lote asociado al hash correspondiente a
  la época $i$.

  Dado que la variable \texttt{hash\_to\_batch} solo se modifica en la línea \ref{line:abci-hashchain-hash-to-batch} como
  parte de \<tryReverse>~\ref{alg:hash_revert},
  se concluye que dicho código tiene que haber sido ejecutado previamente, lo cual implica también que
  $e$ fue añadido a $\THESET$ con anterioridad.
  Por lo tanto, se tiene $e \in \THESET$, concluyendo que $\HISTORY(i) \subseteq \THESET$ para todo $i \leq \EPOCH$.
\end{proof}

\begin{lemma}
  La implementación \hashchain cumple la propiedad~\ref{api:history->theset-local} \textit{Add-Get-Local} de \setchain.
  %que declara que todo elemento válido añadido a un
  %servidor correcto $v$ es eventualmente retornado en todas las llamadas futuras a $v$.\<get>.
\end{lemma}

\begin{proof}
  Sea $e$ un elemento válido y $v$ un servidor correcto, para los cuales un cliente invoca $v.\<add>(e)$.
  Por definción de \<add> en el algoritmo \ref{alg:api-hashchain}, la invocación
  $v.\<add>(e)$ se traduce en la llamada \texttt{HashCollector.AddElement($e$)}.
  Como se puede observar en el algoritmo ~\ref{alg:collector-hash}, $e$ será codificado
  adecuadamente y añadido a un lote $l$ que a la larga estará listo, se hasheará,
  se firmará, y se invocará \<broadcastTx>($t$) sobre el servidor $v$, en donde $t = (h, s)$
  será una tupla conformada por el hash del lote que contiene a $e$
  y una firma válida para el mismo ($\bigstar$). A su vez, la correspondencia entre el hash y el lote
  será añadido a una base de datos local.

  Por la propiedad~\ref{tendermint:eventual-checktx} \emph{Tendermint-Eventual-CheckTx}, $v$
  recibirá la petición \<CheckTx>($t$).
  Consideremos la definición de la línea \ref{alg:hash_check_tx} en el Algoritmo~\ref{alg:abci-hash1}.
  Dado que la firma $s$ es válida por $\bigstar$, se abren dos casos:
  que el lote asociado a $h$ ya sea conocido o no.

  Si el lote asociado a $h$ ya es conocido, es decir, si $h$ \texttt{in hash\_to\_batch},
  entonces con certeza previamente se recibió una petición \<CheckTx> o \<DeliverTx> asociada al
  hash $h$,
  $h$ fue revertido, y se añadió su lote asociado\footnote{Por lo mencionado en
  las consideraciones generales de \hashchain \ref{subsection:hashchain-proof-comments}, dicho lote es $l$,
  puesto que no se considera la posibilidad de colisiones.} a \texttt{hash\_to\_batch}.
  Esto únicamente se hace como parte de \<tryReverse>~\ref{alg:hash_revert},
  en donde, como se puede ver en la línea
  \ref{line:abci-hashchain-the-set}, $e$ tuvo que haber sido añadido a \THESET,
  puesto que es un elemento válido por hipótesis.

  Si, por el contrario,
  el lote asociado a $h$ no es aún conocido, es decir, si \texttt{not} $h$ \texttt{in hash\_to\_batch},
  entonces se invocará a \<tryReverse>.
  De este modo, se comunicará con su propio \hcollector para revertir el hash (la firma $s$ está asociada a él).
  Con seguridad, el \hcollector tendrá el lote asociado a dicho hash en su base de datos local
  (puesto que fue el \hcollector creador de dicho hash) y lo retornará, de manera que el
  elemento $e$ (parte del lote) será añadido a $\THESET$
  de acuerdo a la línea \ref{line:abci-hashchain-the-set} en el Algoritmo~\ref{alg:abci-hash2}.

  Por lo tanto, todas las invocaciones a $v.\<get>$ con el tiempo tendrán al elemento $e$
  como parte de \THESET.
\end{proof}

\begin{lemma}
  La implementación \hashchain cumple la propiedad~\ref{api:history->theset} \textit{Get-Global} de \setchain.
  %que establece que los elementos presentes en un servidor correcto
  %son propagados a todos los servidores correctos.
\end{lemma}

\begin{proof}
  Sean $v$ y $w$ dos servidores correctos y $e \in U$, tal que  $e \in v.\THESET$.
  Debemos probar que se cumplirá $e \in w.\THESET$.
  Si $e \in v.\THESET$, entonces, por construcción de $\THESET$, necesariamente $v$ en algún momento
  ejecutó \<tryReverse>($h, s$)~\ref{alg:hash_revert}, donde $h$ es el hash asociado a un lote que contiene a $e$
  y $s$ es una firma válida para ese hash.
  De este modo, revirtió $h$ correctamente y, como consecuencia,
  añadió a $e$ a $\THESET$ (ver línea \ref{line:abci-hashchain-the-set} en el Algoritmo~\ref{alg:abci-hash2}).
  A su vez, como parte de \<tryReverse>, $v$ difundió $h$ con su propia firma $s'$ (a menos que $s$ ya fuera la firma de $v$,
  en cuyo caso ya lo había difundido previamente).
  Esto se observa en las líneas \ref{alg:hash-if-broadcast-hash} y \ref{alg:hash-broadcast-hash}.
  En cualquier caso, podemos asegurar que se invocó \<broadcastTx>($h, s'$) en $v$.
  Por la propiedad \ref{tendermint:hashchain-broadcast-consolidation} \textit{Haschain-Broadcast-Consolidation},
  sabemos que a la larga $e \in v.\HISTORY$.
  Esto significa que un hash $h'$ (no se puede asegurar que $h'=h$) asociado a un lote que contiene a $e$ consolidó en $v$.
  Por la propiedad \ref{tendermint:hashchain-global-consolidation} \textit{Haschain-Global-Consolidation},
  sabemos que $h'$ consolidará en todos los servidores correctos y, en particular, en $w$.
  Luego, gracias a la propiedad \ref{tendermint:hashchain-local-consolidation} \textit{Haschain-Local-Consolidation}
  podemos asegurar que $e \in w.\HISTORY$.
  Finalmente, por el lema \ref{lemma:hashchain-consistent-set} ya demostrado, tenemos que $e \in w.\THESET$.
\end{proof}

\begin{lemma}
  La implementación \hashchain cumple la propiedad \textit{Eventual-Get}~\ref{api:theset->history}
  de \setchain.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto y $e \in U$. Si $e \in v.\THESET$ y $e \in \HISTORY$, luego
  la propiedad vale trivialmente. Suponemos que $e \notin \HISTORY$.
  Si $e \in v.\THESET$, entonces por construcción de
  $\THESET$, necesariamente $e$ es válido y $v$ en algún momento ejecutó \<tryReverse>~\ref{alg:hash_revert} para un
  hash $h$, donde el lote asociado a $h$ contenía a $e$ como elemento.
  Como parte de \<tryReverse>, $v$ difundió $h$ con su propia firma $s'$ (a menos que $s$ ya fuera la firma de $v$,
  en cuyo caso ya lo había difundido previamente).
  En cualquier caso, podemos asegurar que se invocó 
  \<broadcastTx>($h, s'$) en $v$.
  Luego, por la propiedad \ref{tendermint:hashchain-broadcast-consolidation} \textit{Haschain-Broadcast-Consolidation}
  podemos asegurar que tarde o temprano $e \in v.\HISTORY$.
\end{proof}

\begin{lemma}
  La implementación \hashchain cumple la propiedad \textit{Unique Epoch}~\ref{api:local_unique_stamp} de \setchain.
\end{lemma}

\begin{proof}
  Sea $v$ un servidor correcto e ${i,i'\leq v.\EPOCH}$ con ${i\neq i'}$.
  Queremos probar que $v.\HISTORY(i)\cap{}v.\HISTORY(i')=\emptyset$.
  %

  Esto es trivialmente correcto debido a que un elemento $e$ se agrega a \HISTORY[j]
  únicamente si no pertenece a $\HISTORY[j']$ con $j' \in \{0, 1, ..., j -1\}$, como se puede
  ver en la cláusula \texttt{if} de la línea \ref{line:abci-hashchain-history-if}
  en el Algoritmo \ref{alg:abci-hash1}.
  %
\end{proof}

\begin{lemma}\label{lemma:hashchain-consistent-gets}
  La implementación \hashchain cumple la propiedad \textit{Consistent Gets}~\ref{api:consistent-gets} de \setchain.
\end{lemma}

\begin{proof}
  Sean $v$ y $w$ dos servidores correctos, e $i\leq$ min$(v.\EPOCH, w.\EPOCH)$.
  Queremos probar que $v.\HISTORY(i)=w.\HISTORY(i)$.

  Se demostrará $v.\HISTORY(i)=w.\HISTORY(i)$ por inducción fuerte en el número de época.

  \textbf{Caso base}. 
  Sea un elemento $e$ $\in v.\HISTORY(1)$.
  Por construcción de $\HISTORY$, necesariamente $e$ es válido y $v$ recibió al menos \SPH
  peticiones \<DeliverTx>($h, s$), donde $h$ es un hash asociado a un lote que contiene a $e$,
  y $s$ es una firma válida de $h$ (generada con la clave privada de un servidor).
  Esto produjo que \texttt{hash\_to\_signature[$h$]} acumulara firmas como se muestra en la línea
  \ref{alg:hash-new-sign} de la definición de \<DeliverTx>, y que en algún momento
  \<shouldConsolidateHash>($h$) retorne \texttt{True}, asignándole el número de época 1 al hash $h$
  (ver línea \ref{alg:hash-epoch-to-hash} en el Algoritmo~\ref{alg:abci-hash1}).
  Luego, en la posterior ejecución de \<updateHistory>, $e$ es añadido a $v.\HISTORY(1)$
  como se muestra en la línea \ref{line:abci-hashchain-history} (necesariamente $h$ fue revertido
  correctamente en algún momento anterior).
  Naturalmente, estas peticiones \<DeliverTx>($h, s$) arriban a $v$ como parte de cadenas de
  peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit.
  Por la propiedad~\ref{tendermint:global-delivery} \emph{Tendermint-Global-Requests} podemos
  asegurar que todos los servidores correctos,
  y en particular $w$, reciben las cadenas de peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit
  en el mismo orden en que lo hace $v$.
  Por lo tanto, de forma análoga, $h$ consolidará en $w$.
  A su vez, dado que $\SPH \geq f + 1$, podemos asegurar que al menos un servidor correcto firmó $h$.
  Con seguridad, dicho servidor correcto conoce el hash y, por lo tanto, garantiza que lo revertirá
  cuando $w$ procese su petición.
  De esta forma, con certeza se añadirá $e$ a $w.\HISTORY(1)$.
  Así queda demostrado $v.\HISTORY(1) \subseteq w.\HISTORY(1)$.
  El mismo razonamiento se puede seguir para demostrar $w.\HISTORY(1) \subseteq v.\HISTORY(1)$.
  Luego, queda demostrada la propiedad para el caso base: $v.\HISTORY(1)=w.\HISTORY(1)$.
  
  \textbf{Caso inductivo}.
  Sea un elemento $e \in v.\HISTORY(n+1)$. Análogamente a lo mencionado anteriormente,
  a $v$ llegaron cadenas de peticiones \BeginBlock, [\DeliverTx, ...], \EndBlock, \Commit
  que provocaron que un hash $h$ (asociado a un lote $l$ tal que $e \in l$) consolidara,
  haciendo que $e$ fuera añadido a $v.\HISTORY(n+1)$.
  Por la propiedad~\ref{tendermint:global-delivery} \emph{Tendermint-Global-Requests}
  podemos asegurar que las mismas cadenas de peticiones llegaron a $w$.
  A su vez, siguiendo el razonamiento explicado en el caso base, podemos asegurar que $w$ es capaz
  de revertir el hash $h$ y obtener el lote $l$.
  Por la hipótesis inductiva fuerte, sabemos que
  $v.\HISTORY(j)=w.\HISTORY(j), \forall j \leq n$.
  Por lo tanto, podemos asegurar que, una vez que $h$ consolida en $w$, cuando se procesa
  \<updateHistory> para la época $n+1$, la cláusula \texttt{if} de la línea \ref{line:abci-hashchain-history-if}
  retorna \texttt{True}, puesto que
  $e \notin w.\HISTORY(j) \forall j \leq n$.
  De este modo, $e$ es añadido a $w.\HISTORY(n+1)$.
  Así queda demostrado $v.\HISTORY(n+1) \subseteq w.\HISTORY(n+1)$.
  El mismo razonamiento se puede seguir para demostrar $w.\HISTORY(n+1) \subseteq v.\HISTORY(n+1)$.
  Luego, queda demostrada la propiedad para el caso inductivo: $v.\HISTORY(n+1)=w.\HISTORY(n+1)$.
\end{proof}

\begin{lemma}
  La implementación \hashchain cumple la propiedad \textit{Add-before-Get}~\ref{api:get->add} de \setchain.
\end{lemma}

\begin{proof}
  Se cumple trivialmente por lo mencionado en \ref{subsection:proof-comments}.
\end{proof}

\section{Conclusión}
Habiendo demostrado que \vanilla, \compresschain y \hashchain cumplen todas las propiedaes
de \setchain presentadas en la sección \ref{sec:setchain-properties}, queda entonces probado
que las tres soluciones propuestas en este trabajo son implementaciones correctas de \setchain.
